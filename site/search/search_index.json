{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"photonic_crystal/","title":"Photonic Crystal","text":""},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D","title":"<code>Crystal2D</code>","text":"<p>               Bases: <code>PhotonicCrystal</code></p> <p>This class provides methods to define and simulate 2D photonic crystals with various lattice types and geometries.  It allows for the calculation and visualization of dielectric distributions and electromagnetic fields within the crystal.</p> <p>Attributes:</p> Name Type Description <code>geometry_lattice</code> <code>Lattice</code> <p>The lattice structure of the photonic crystal.</p> <code>k_points</code> <code>list</code> <p>List of k-points for the simulation.</p> <code>geometry</code> <code>list</code> <p>List of geometric objects defining the photonic crystal.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points for the simulation.</p> <code>epsilon</code> <code>ndarray</code> <p>Dielectric distribution of the photonic crystal.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the Crystal2D object with the specified parameters.</p> <code>plot_epsilon</code> <p>Plots the dielectric distribution interactively using Plotly.</p> <code>plot_field</code> <p>Plots the electromagnetic field distribution interactively using Plotly.</p> <code>basic_geometry</code> <p>Defines a basic geometry for the photonic crystal.</p> <code>ellipsoid_geometry</code> <p>Defines an ellipsoid geometry for the photonic crystal.</p> <code>advanced_material_geometry</code> <p>Defines an advanced material geometry for the photonic crystal.</p> <code>basic_lattice</code> <p>Defines the basic lattice structure for the photonic crystal.</p> <code>square_lattice</code> <p>Defines a square lattice for the photonic crystal.</p> <code>triangular_lattice</code> <p>Defines a triangular lattice for the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>class Crystal2D(PhotonicCrystal):\n    \"\"\"\n    This class provides methods to define and simulate 2D photonic crystals with various lattice types and geometries. \n    It allows for the calculation and visualization of dielectric distributions and electromagnetic fields within the crystal.\n\n    Attributes:\n        geometry_lattice (mp.Lattice): The lattice structure of the photonic crystal.\n        k_points (list): List of k-points for the simulation.\n        geometry (list): List of geometric objects defining the photonic crystal.\n        k_points_interpolated (list): Interpolated k-points for the simulation.\n        epsilon (ndarray): Dielectric distribution of the photonic crystal.\n\n    Methods:\n        __init__(self, lattice_type=None, num_bands=6, resolution=(32, 32), interp=4, periods=3, pickle_id=None, geometry=None, use_XY=True, k_point_max=0.2):\n            Initializes the Crystal2D object with the specified parameters.\n        plot_epsilon(self, fig=None, title='Epsilon', **kwargs):\n            Plots the dielectric distribution interactively using Plotly.\n        plot_field(self, runner=\"run_tm\", k_point=mp.Vector3(0, 0), periods=5, fig=None, title=\"Field Visualization\", colorscale='RdBu'):\n            Plots the electromagnetic field distribution interactively using Plotly.\n        basic_geometry(radius_1=0.2, eps_atom_1=1, radius_2=None, eps_atom_2=None, eps_bulk=12):\n            Defines a basic geometry for the photonic crystal.\n        ellipsoid_geometry(e1=0.2, e2=0.3, eps_atom=1, eps_bulk=12):\n            Defines an ellipsoid geometry for the photonic crystal.\n        advanced_material_geometry(radius_1=0.2, epsilon_diag=mp.Vector3(12, 12, 12), epsilon_offdiag=mp.Vector3(0, 0, 0), chi2_diag=mp.Vector3(0, 0, 0), chi3_diag=mp.Vector3(0, 0, 0), eps_atom_1=1):\n            Defines an advanced material geometry for the photonic crystal.\n        basic_lattice(lattice_type='square'):\n            Defines the basic lattice structure for the photonic crystal.\n        square_lattice():\n            Defines a square lattice for the photonic crystal.\n        triangular_lattice():\n            Defines a triangular lattice for the photonic crystal.\n    \"\"\"\n\n\n\n    def __init__(self,\n                lattice_type = \"square\",\n                num_bands: int = 6,\n                resolution: tuple[int, int] | int = 32,\n                interp: int =4,\n                periods: int =3, \n                pickle_id = None,\n                geometry = None,\n                use_XY = True,\n                k_point_max = 0.2):\n\n        \"\"\"\n        Initializes the Crystal2D object with the specified parameters.\n\n        Args:\n            lattice_type (str): The type of lattice. Default is 'square' other option is 'triangular'. It determines the k-points if use_XY is False.\n            num_bands (int): The number of bands to calculate. Default is 6.\n            resolution (tuple[int, int] | int): The resolution of the simulation. Default is (32, 32).\n            interp (int): The interpolation factor for k-points. Default is 4.\n            periods (int): The number of periods to simulate. Default is 3.\n            pickle_id (str): The ID for pickling the simulation. Default is None.\n            geometry (list): The geometry of the photonic crystal. Default is None.\n            use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n        \"\"\"\n\n        super().__init__(lattice_type, num_bands, resolution, interp, periods, pickle_id, use_XY=use_XY)\n\n        self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n        if use_XY is True:\n            self.k_points = [\n                mp.Vector3(k_point_max, 0, 0),      # X\n                mp.Vector3(0, 0 ,0 ),       # Gamma\n                mp.Vector3(0, k_point_max,0)        # Y\n            ]\n        self.geometry = geometry if geometry is not None else self.basic_geometry()\n        self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n\n\n\n    def plot_epsilon(self, fig=None, title='Epsilon', **kwargs)-&gt; go.Figure:\n        \"\"\"\n        Plot the dielectric distribution interactively using Plotly.\n\n        Args:\n            fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n            title (str, optional): The title of the plot. Default is 'Epsilon'.\n            **kwargs: Additional keyword arguments for Plotly.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n\n        with suppress_output():\n            if self.epsilon is None:\n                md = mpb.MPBData(rectify=True, periods=self.periods, resolution=self.resolution)\n                converted_eps = md.convert(self.ms.get_epsilon())\n            else:\n                converted_eps = self.epsilon\n            if fig is None:\n                fig = go.Figure()\n\n            fig.add_trace(go.Heatmap(z=converted_eps.T, colorscale='Viridis'))\n            fig.update_layout(\n                title=dict(\n                    text=f\"{title}&lt;br&gt;Dielectric Distribution\",\n                    x=0.5,\n                    y=0.95,\n                    xanchor='center',\n                    yanchor='top'\n                ),\n                coloraxis_colorbar=dict(title='$\\\\epsilon $'),\n                xaxis_showgrid=False, \n                yaxis_showgrid=False,\n                xaxis_zeroline=False, \n                yaxis_zeroline=False,\n                xaxis_visible=False, \n                yaxis_visible=False\n            )       \n        self.epsilon = converted_eps\n        print(self.epsilon)    \n        return fig\n\n\n\n\n\n    def plot_field(self, \n                runner=\"run_tm\", \n                k_point=mp.Vector3(0, 0), \n                periods=5, \n                fig=None,\n                title=\"Field Visualization\", \n                colorscale='RdBu')-&gt; go.Figure:\n        \"\"\"\n        Plot the electromagnetic field distribution interactively using Plotly.\n\n        Args:\n            runner (str): The runner for the simulation. Default is 'run_tm'.\n            k_point (mp.Vector3): The k-point for the simulation. Default is mp.Vector3(0, 0).\n            periods (int): The number of periods to extract. Default is 5.\n            fig (go.Figure): The Plotly figure to add the field plot to. Default is None.\n            title (str): The title of the plot. Default is 'Field Visualization'.\n            colorscale (str): The colorscale for the heatmap. Default is 'RdBu'.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n\n        raw_fields = []\n        freqs = []\n\n        self.ms = mpb.ModeSolver(geometry=self.geometry,\n                                geometry_lattice=self.geometry_lattice,\n                                k_points=[k_point],\n                                resolution=self.resolution,\n                                num_bands=self.num_bands)\n\n        def get_zodd_fields(ms, band):\n            raw_fields.append(ms.get_hfield(band, bloch_phase=True))\n        def get_zeven_fields(ms, band):\n            raw_fields.append(ms.get_efield(band, bloch_phase=True))\n        def get_freqs(ms, band):\n            freqs.append(ms.freqs[band-1])\n\n\n        with suppress_output():\n            if runner == \"run_te\" or runner == \"run_zeven\":\n                self.ms.run_te(mpb.output_at_kpoint(k_point, mpb.fix_hfield_phase, get_zodd_fields, get_freqs))\n                field_type = \"H-field\"\n                print(f\"frequencies: {freqs}\")\n\n            elif runner == \"run_tm\" or runner == \"run_zodd\":\n                self.ms.run_tm(mpb.output_at_kpoint(k_point, mpb.fix_efield_phase, get_zeven_fields, get_freqs))\n                field_type = \"E-field\"\n                print(f\"frequencies: {freqs}\")\n\n            else:\n                raise ValueError(\"Invalid runner. Please enter 'run_te', 'run_zeven', or 'run_tm' or 'run_zodd'.\")\n\n            md = mpb.MPBData(rectify=True, periods=periods, resolution=self.resolution)\n            fields = []        \n            for field in raw_fields:\n                field = field[..., 0, 2]  # Get just the z component of the fields\n\n                fields.append(md.convert(field))\n\n\n\n            eps = md.convert(self.ms.get_epsilon())\n        #print(fields)\n        num_plots = len(fields)\n        if num_plots == 0:\n            print(\"No field data to plot.\")\n            return\n\n        if fig is None:\n            fig = go.Figure()\n\n        # Automatically generate the subtitle with the k-vector and field type\n        subtitle = f\"{field_type}, z-component&lt;br&gt;k = ({k_point.x:.4f}, {k_point.y:.4f})\"\n\n        # Initialize an empty list for dropdown menu options\n        dropdown_buttons = []\n\n        # Calculate the midpoint between min and max of the permittivity (eps)\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n        for i, (field, freq) in enumerate(zip(fields, freqs)):\n            visible_status = [False] * (2 * num_plots)\n            visible_status[2 * i] = True  # Make the current contour (eps) visible\n            visible_status[2 * i + 1] = True  # Make the current heatmap (field) visible\n\n            # Add the contour plot for permittivity (eps) at the midpoint\n            fig.add_trace(go.Contour(z=eps.T,\n                                    contours=dict(\n                                        start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                        end=midpoint,\n                                        size=0.1,  # A small size to keep it as a single contour\n                                        coloring='none'  # No filling\n                                    ),\n                                    line=dict(color='black', width=2),\n                                    showscale=False,\n                                    opacity=0.7,\n                                    visible=True if i == 0 else False))  # Initially visible only for the first plot\n\n            # Add the heatmap for the real part of the electric field\n            fig.add_trace(go.Heatmap(z=np.real(field).T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=False, visible=True if i == 0 else False))\n\n            # Create a button for each field dataset for the dropdown\n            dropdown_buttons.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status},  # Update visibility for both eps and field\n                                            {'title':f\"{title}&lt;br&gt;Mode {i + 1}, freq={freq:0.3f}: {subtitle}\"}\n                                        ]))\n            mode = {\n                \"k_point\" : k_point,\n                \"frequency\" : freq,\n                \"field\" : field,\n                \"field_type\" : field_type,\n            }\n\n\n\n        # Add the dropdown menu to the layout\n        fig.update_layout(\n            updatemenus=[dict(active=0,  # The first dataset is active by default\n                            buttons=dropdown_buttons,\n                            x=1.15, y=1.15,  # Positioning the dropdown to the top right\n                            xanchor='left', yanchor='top')],\n            title=f\"{title}&lt;br&gt;Mode {1}, freq={freqs[0]:0.3f}: {subtitle}\",  # Main title + subtitle\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800\n        )\n\n\n        # Display the plot\n        return fig\n\n\n\n\n    @staticmethod\n    def basic_lattice(lattice_type='square')-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n        \"\"\"\n        Define the basic lattice of the photonic crystal.\n\n        Args:\n            lattice_type (str): The type of lattice. Default is 'square'.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n        \"\"\"\n        if lattice_type == 'square':\n            return Crystal2D.square_lattice()\n        elif lattice_type == 'triangular':\n            return Crystal2D.triangular_lattice()\n        else:\n            raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n\n\n\n    @staticmethod\n    def square_lattice()-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n        \"\"\"\n        Define the square lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0, 1))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # M\n            mp.Vector3(0.5, 0.5),       # X\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n\n    @staticmethod\n    def triangular_lattice()-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n        \"\"\"\n        Define the triangular lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # K\n            mp.Vector3(-1./3, 1./3),    # M\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n\n    @staticmethod\n    def basic_geometry(radius_1=0.2, \n                       eps_atom_1=1, \n                       radius_2=None, \n                       eps_atom_2=None,\n                       eps_bulk = 12, \n                       )-&gt; list: \n        \"\"\"\n        Define a basic geometry for the photonic crystal.\n        So far only one atom has been tested. It uses cylinders to define the geometry.\n\n        Args:\n            radius_1 (float): The radius of the first atom. Default is 0.2.\n            eps_atom_1 (float): The dielectric constant of the first atom. Default is 1.\n            radius_2 (float, optional): The radius of the second atom. Default is None.\n            eps_atom_2 (float, optional): The dielectric constant of the second atom. Default is None.\n            eps_bulk (float): The dielectric constant of the bulk. Default is 12.\n\n        Returns:\n            list: A list of geometric objects defining the photonic crystal.\n\n\n        \"\"\"\n\n        geometry = [\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf),\n                material=mp.Medium(epsilon=eps_bulk)),\n            ]\n        if radius_2 is None:\n            geometry.append(mp.Cylinder(radius_1, \n                                        material=mp.Medium(epsilon=eps_atom_1),\n                                        center = mp.Vector3(0,0)))\n        else:\n            geometry.append(mp.Cylinder(radius_1, \n                                        material=mp.Medium(epsilon=eps_atom_1),\n                                        center = mp.Vector3(-0.5,-0.5)))\n            geometry.append(mp.Cylinder(radius_2, \n                                        material=mp.Medium(epsilon=eps_atom_2),\n                                        center = mp.Vector3(.5,.5)))\n        return geometry\n\n    @staticmethod\n    def ellipsoid_geometry(e1: float=0.2, \n                           e2: float = 0.3,\n                           eps_atom: float = 1, \n                           eps_bulk: float= 12)-&gt;update:\n        \"\"\"\n        Define an ellipsoid geometry for the photonic crystal.\n\n        Args:\n            e1 (float): The first radius of the ellipsoid. Default is 0.2.\n            e2 (float): The second radius of the ellipsoid. Default is 0.3.\n            eps_atom (float): The dielectric constant of the atom. Default is 1.\n            eps_bulk (float): The dielectric constant of the bulk. Default is 12.\n\n        Returns:\n            list: A list of geometric objects defining the photonic crystal.\n        \"\"\"\n\n        geometry = [\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf),\n                material=mp.Medium(epsilon=eps_bulk)),\n            ]   \n\n        size=mp.Vector3(e1,e2, mp.inf)\n        geometry.append(mp.Ellipsoid(size=size,\n                                     material=mp.Medium(epsilon=eps_atom),\n                                     center=mp.Vector3(0,0)))\n        return geometry\n\n    @staticmethod\n    def advanced_material_geometry(\n        radius_1 = 0.2,\n        epsilon_diag = mp.Vector3(12, 12, 12),\n        epsilon_offdiag = mp.Vector3(0, 0, 0),\n        chi2_diag = mp.Vector3(0,0,0),\n\n        chi3_diag = mp.Vector3(0,0,0),\n\n        eps_atom_1 = 1\n    )-&gt; list:\n        \"\"\"\n        Define an advanced material geometry for the photonic crystal.\n\n        Args:\n            radius_1 (float): The radius of the atom. Default is 0.2.\n            epsilon_diag (mp.Vector3): The diagonal components of the dielectric tensor. Default is (12, 12, 12).\n            epsilon_offdiag (mp.Vector3): The off-diagonal components of the dielectric tensor. Default is (0, 0, 0).\n            chi2_diag (mp.Vector3): The diagonal components of the second-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n            chi3_diag (mp.Vector3): The diagonal components of the third-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n            eps_atom_1 (float): The dielectric constant of the atom. Default is 1.\n\n        Returns:\n            list: A list of geometric objects defining the photonic crystal.\n        \"\"\"\n\n\n        geometry =[\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf),\n                material = mp.Medium(\n                    epsilon_diag=epsilon_diag,\n                    epsilon_offdiag = epsilon_offdiag, \n                    E_chi2_diag = chi2_diag, \n                    E_chi3_diag = chi3_diag,\n                )\n            )\n        ]\n\n        geometry.append(mp.Cylinder(radius_1, \n                                        material=mp.Medium(epsilon=eps_atom_1),\n                                        center = mp.Vector3(0,0)))\n        return geometry\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.__init__","title":"<code>__init__(lattice_type='square', num_bands=6, resolution=32, interp=4, periods=3, pickle_id=None, geometry=None, use_XY=True, k_point_max=0.2)</code>","text":"<p>Initializes the Crystal2D object with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. Default is 'square' other option is 'triangular'. It determines the k-points if use_XY is False.</p> <code>'square'</code> <code>num_bands</code> <code>int</code> <p>The number of bands to calculate. Default is 6.</p> <code>6</code> <code>resolution</code> <code>tuple[int, int] | int</code> <p>The resolution of the simulation. Default is (32, 32).</p> <code>32</code> <code>interp</code> <code>int</code> <p>The interpolation factor for k-points. Default is 4.</p> <code>4</code> <code>periods</code> <code>int</code> <p>The number of periods to simulate. Default is 3.</p> <code>3</code> <code>pickle_id</code> <code>str</code> <p>The ID for pickling the simulation. Default is None.</p> <code>None</code> <code>geometry</code> <code>list</code> <p>The geometry of the photonic crystal. Default is None.</p> <code>None</code> <code>use_XY</code> <code>bool</code> <p>Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.</p> <code>True</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def __init__(self,\n            lattice_type = \"square\",\n            num_bands: int = 6,\n            resolution: tuple[int, int] | int = 32,\n            interp: int =4,\n            periods: int =3, \n            pickle_id = None,\n            geometry = None,\n            use_XY = True,\n            k_point_max = 0.2):\n\n    \"\"\"\n    Initializes the Crystal2D object with the specified parameters.\n\n    Args:\n        lattice_type (str): The type of lattice. Default is 'square' other option is 'triangular'. It determines the k-points if use_XY is False.\n        num_bands (int): The number of bands to calculate. Default is 6.\n        resolution (tuple[int, int] | int): The resolution of the simulation. Default is (32, 32).\n        interp (int): The interpolation factor for k-points. Default is 4.\n        periods (int): The number of periods to simulate. Default is 3.\n        pickle_id (str): The ID for pickling the simulation. Default is None.\n        geometry (list): The geometry of the photonic crystal. Default is None.\n        use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n    \"\"\"\n\n    super().__init__(lattice_type, num_bands, resolution, interp, periods, pickle_id, use_XY=use_XY)\n\n    self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n    if use_XY is True:\n        self.k_points = [\n            mp.Vector3(k_point_max, 0, 0),      # X\n            mp.Vector3(0, 0 ,0 ),       # Gamma\n            mp.Vector3(0, k_point_max,0)        # Y\n        ]\n    self.geometry = geometry if geometry is not None else self.basic_geometry()\n    self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.advanced_material_geometry","title":"<code>advanced_material_geometry(radius_1=0.2, epsilon_diag=mp.Vector3(12, 12, 12), epsilon_offdiag=mp.Vector3(0, 0, 0), chi2_diag=mp.Vector3(0, 0, 0), chi3_diag=mp.Vector3(0, 0, 0), eps_atom_1=1)</code>  <code>staticmethod</code>","text":"<p>Define an advanced material geometry for the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>radius_1</code> <code>float</code> <p>The radius of the atom. Default is 0.2.</p> <code>0.2</code> <code>epsilon_diag</code> <code>Vector3</code> <p>The diagonal components of the dielectric tensor. Default is (12, 12, 12).</p> <code>Vector3(12, 12, 12)</code> <code>epsilon_offdiag</code> <code>Vector3</code> <p>The off-diagonal components of the dielectric tensor. Default is (0, 0, 0).</p> <code>Vector3(0, 0, 0)</code> <code>chi2_diag</code> <code>Vector3</code> <p>The diagonal components of the second-order nonlinear susceptibility tensor. Default is (0, 0, 0).</p> <code>Vector3(0, 0, 0)</code> <code>chi3_diag</code> <code>Vector3</code> <p>The diagonal components of the third-order nonlinear susceptibility tensor. Default is (0, 0, 0).</p> <code>Vector3(0, 0, 0)</code> <code>eps_atom_1</code> <code>float</code> <p>The dielectric constant of the atom. Default is 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of geometric objects defining the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef advanced_material_geometry(\n    radius_1 = 0.2,\n    epsilon_diag = mp.Vector3(12, 12, 12),\n    epsilon_offdiag = mp.Vector3(0, 0, 0),\n    chi2_diag = mp.Vector3(0,0,0),\n\n    chi3_diag = mp.Vector3(0,0,0),\n\n    eps_atom_1 = 1\n)-&gt; list:\n    \"\"\"\n    Define an advanced material geometry for the photonic crystal.\n\n    Args:\n        radius_1 (float): The radius of the atom. Default is 0.2.\n        epsilon_diag (mp.Vector3): The diagonal components of the dielectric tensor. Default is (12, 12, 12).\n        epsilon_offdiag (mp.Vector3): The off-diagonal components of the dielectric tensor. Default is (0, 0, 0).\n        chi2_diag (mp.Vector3): The diagonal components of the second-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n        chi3_diag (mp.Vector3): The diagonal components of the third-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n        eps_atom_1 (float): The dielectric constant of the atom. Default is 1.\n\n    Returns:\n        list: A list of geometric objects defining the photonic crystal.\n    \"\"\"\n\n\n    geometry =[\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf),\n            material = mp.Medium(\n                epsilon_diag=epsilon_diag,\n                epsilon_offdiag = epsilon_offdiag, \n                E_chi2_diag = chi2_diag, \n                E_chi3_diag = chi3_diag,\n            )\n        )\n    ]\n\n    geometry.append(mp.Cylinder(radius_1, \n                                    material=mp.Medium(epsilon=eps_atom_1),\n                                    center = mp.Vector3(0,0)))\n    return geometry\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.basic_geometry","title":"<code>basic_geometry(radius_1=0.2, eps_atom_1=1, radius_2=None, eps_atom_2=None, eps_bulk=12)</code>  <code>staticmethod</code>","text":"<p>Define a basic geometry for the photonic crystal. So far only one atom has been tested. It uses cylinders to define the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>radius_1</code> <code>float</code> <p>The radius of the first atom. Default is 0.2.</p> <code>0.2</code> <code>eps_atom_1</code> <code>float</code> <p>The dielectric constant of the first atom. Default is 1.</p> <code>1</code> <code>radius_2</code> <code>float</code> <p>The radius of the second atom. Default is None.</p> <code>None</code> <code>eps_atom_2</code> <code>float</code> <p>The dielectric constant of the second atom. Default is None.</p> <code>None</code> <code>eps_bulk</code> <code>float</code> <p>The dielectric constant of the bulk. Default is 12.</p> <code>12</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of geometric objects defining the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_geometry(radius_1=0.2, \n                   eps_atom_1=1, \n                   radius_2=None, \n                   eps_atom_2=None,\n                   eps_bulk = 12, \n                   )-&gt; list: \n    \"\"\"\n    Define a basic geometry for the photonic crystal.\n    So far only one atom has been tested. It uses cylinders to define the geometry.\n\n    Args:\n        radius_1 (float): The radius of the first atom. Default is 0.2.\n        eps_atom_1 (float): The dielectric constant of the first atom. Default is 1.\n        radius_2 (float, optional): The radius of the second atom. Default is None.\n        eps_atom_2 (float, optional): The dielectric constant of the second atom. Default is None.\n        eps_bulk (float): The dielectric constant of the bulk. Default is 12.\n\n    Returns:\n        list: A list of geometric objects defining the photonic crystal.\n\n\n    \"\"\"\n\n    geometry = [\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf),\n            material=mp.Medium(epsilon=eps_bulk)),\n        ]\n    if radius_2 is None:\n        geometry.append(mp.Cylinder(radius_1, \n                                    material=mp.Medium(epsilon=eps_atom_1),\n                                    center = mp.Vector3(0,0)))\n    else:\n        geometry.append(mp.Cylinder(radius_1, \n                                    material=mp.Medium(epsilon=eps_atom_1),\n                                    center = mp.Vector3(-0.5,-0.5)))\n        geometry.append(mp.Cylinder(radius_2, \n                                    material=mp.Medium(epsilon=eps_atom_2),\n                                    center = mp.Vector3(.5,.5)))\n    return geometry\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.basic_lattice","title":"<code>basic_lattice(lattice_type='square')</code>  <code>staticmethod</code>","text":"<p>Define the basic lattice of the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. Default is 'square'.</p> <code>'square'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Lattice, list[Vector3]]</code> <p>A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_lattice(lattice_type='square')-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n    \"\"\"\n    Define the basic lattice of the photonic crystal.\n\n    Args:\n        lattice_type (str): The type of lattice. Default is 'square'.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n    \"\"\"\n    if lattice_type == 'square':\n        return Crystal2D.square_lattice()\n    elif lattice_type == 'triangular':\n        return Crystal2D.triangular_lattice()\n    else:\n        raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.ellipsoid_geometry","title":"<code>ellipsoid_geometry(e1=0.2, e2=0.3, eps_atom=1, eps_bulk=12)</code>  <code>staticmethod</code>","text":"<p>Define an ellipsoid geometry for the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>e1</code> <code>float</code> <p>The first radius of the ellipsoid. Default is 0.2.</p> <code>0.2</code> <code>e2</code> <code>float</code> <p>The second radius of the ellipsoid. Default is 0.3.</p> <code>0.3</code> <code>eps_atom</code> <code>float</code> <p>The dielectric constant of the atom. Default is 1.</p> <code>1</code> <code>eps_bulk</code> <code>float</code> <p>The dielectric constant of the bulk. Default is 12.</p> <code>12</code> <p>Returns:</p> Name Type Description <code>list</code> <code>update</code> <p>A list of geometric objects defining the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef ellipsoid_geometry(e1: float=0.2, \n                       e2: float = 0.3,\n                       eps_atom: float = 1, \n                       eps_bulk: float= 12)-&gt;update:\n    \"\"\"\n    Define an ellipsoid geometry for the photonic crystal.\n\n    Args:\n        e1 (float): The first radius of the ellipsoid. Default is 0.2.\n        e2 (float): The second radius of the ellipsoid. Default is 0.3.\n        eps_atom (float): The dielectric constant of the atom. Default is 1.\n        eps_bulk (float): The dielectric constant of the bulk. Default is 12.\n\n    Returns:\n        list: A list of geometric objects defining the photonic crystal.\n    \"\"\"\n\n    geometry = [\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf),\n            material=mp.Medium(epsilon=eps_bulk)),\n        ]   \n\n    size=mp.Vector3(e1,e2, mp.inf)\n    geometry.append(mp.Ellipsoid(size=size,\n                                 material=mp.Medium(epsilon=eps_atom),\n                                 center=mp.Vector3(0,0)))\n    return geometry\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.plot_epsilon","title":"<code>plot_epsilon(fig=None, title='Epsilon', **kwargs)</code>","text":"<p>Plot the dielectric distribution interactively using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the epsilon plot to. Default is None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Epsilon'.</p> <code>'Epsilon'</code> <code>**kwargs</code> <p>Additional keyword arguments for Plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_epsilon(self, fig=None, title='Epsilon', **kwargs)-&gt; go.Figure:\n    \"\"\"\n    Plot the dielectric distribution interactively using Plotly.\n\n    Args:\n        fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n        title (str, optional): The title of the plot. Default is 'Epsilon'.\n        **kwargs: Additional keyword arguments for Plotly.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n\n    with suppress_output():\n        if self.epsilon is None:\n            md = mpb.MPBData(rectify=True, periods=self.periods, resolution=self.resolution)\n            converted_eps = md.convert(self.ms.get_epsilon())\n        else:\n            converted_eps = self.epsilon\n        if fig is None:\n            fig = go.Figure()\n\n        fig.add_trace(go.Heatmap(z=converted_eps.T, colorscale='Viridis'))\n        fig.update_layout(\n            title=dict(\n                text=f\"{title}&lt;br&gt;Dielectric Distribution\",\n                x=0.5,\n                y=0.95,\n                xanchor='center',\n                yanchor='top'\n            ),\n            coloraxis_colorbar=dict(title='$\\\\epsilon $'),\n            xaxis_showgrid=False, \n            yaxis_showgrid=False,\n            xaxis_zeroline=False, \n            yaxis_zeroline=False,\n            xaxis_visible=False, \n            yaxis_visible=False\n        )       \n    self.epsilon = converted_eps\n    print(self.epsilon)    \n    return fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.plot_field","title":"<code>plot_field(runner='run_tm', k_point=mp.Vector3(0, 0), periods=5, fig=None, title='Field Visualization', colorscale='RdBu')</code>","text":"<p>Plot the electromagnetic field distribution interactively using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>runner</code> <code>str</code> <p>The runner for the simulation. Default is 'run_tm'.</p> <code>'run_tm'</code> <code>k_point</code> <code>Vector3</code> <p>The k-point for the simulation. Default is mp.Vector3(0, 0).</p> <code>Vector3(0, 0)</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 5.</p> <code>5</code> <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the field plot to. Default is None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Field Visualization'.</p> <code>'Field Visualization'</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the heatmap. Default is 'RdBu'.</p> <code>'RdBu'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field(self, \n            runner=\"run_tm\", \n            k_point=mp.Vector3(0, 0), \n            periods=5, \n            fig=None,\n            title=\"Field Visualization\", \n            colorscale='RdBu')-&gt; go.Figure:\n    \"\"\"\n    Plot the electromagnetic field distribution interactively using Plotly.\n\n    Args:\n        runner (str): The runner for the simulation. Default is 'run_tm'.\n        k_point (mp.Vector3): The k-point for the simulation. Default is mp.Vector3(0, 0).\n        periods (int): The number of periods to extract. Default is 5.\n        fig (go.Figure): The Plotly figure to add the field plot to. Default is None.\n        title (str): The title of the plot. Default is 'Field Visualization'.\n        colorscale (str): The colorscale for the heatmap. Default is 'RdBu'.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n\n    raw_fields = []\n    freqs = []\n\n    self.ms = mpb.ModeSolver(geometry=self.geometry,\n                            geometry_lattice=self.geometry_lattice,\n                            k_points=[k_point],\n                            resolution=self.resolution,\n                            num_bands=self.num_bands)\n\n    def get_zodd_fields(ms, band):\n        raw_fields.append(ms.get_hfield(band, bloch_phase=True))\n    def get_zeven_fields(ms, band):\n        raw_fields.append(ms.get_efield(band, bloch_phase=True))\n    def get_freqs(ms, band):\n        freqs.append(ms.freqs[band-1])\n\n\n    with suppress_output():\n        if runner == \"run_te\" or runner == \"run_zeven\":\n            self.ms.run_te(mpb.output_at_kpoint(k_point, mpb.fix_hfield_phase, get_zodd_fields, get_freqs))\n            field_type = \"H-field\"\n            print(f\"frequencies: {freqs}\")\n\n        elif runner == \"run_tm\" or runner == \"run_zodd\":\n            self.ms.run_tm(mpb.output_at_kpoint(k_point, mpb.fix_efield_phase, get_zeven_fields, get_freqs))\n            field_type = \"E-field\"\n            print(f\"frequencies: {freqs}\")\n\n        else:\n            raise ValueError(\"Invalid runner. Please enter 'run_te', 'run_zeven', or 'run_tm' or 'run_zodd'.\")\n\n        md = mpb.MPBData(rectify=True, periods=periods, resolution=self.resolution)\n        fields = []        \n        for field in raw_fields:\n            field = field[..., 0, 2]  # Get just the z component of the fields\n\n            fields.append(md.convert(field))\n\n\n\n        eps = md.convert(self.ms.get_epsilon())\n    #print(fields)\n    num_plots = len(fields)\n    if num_plots == 0:\n        print(\"No field data to plot.\")\n        return\n\n    if fig is None:\n        fig = go.Figure()\n\n    # Automatically generate the subtitle with the k-vector and field type\n    subtitle = f\"{field_type}, z-component&lt;br&gt;k = ({k_point.x:.4f}, {k_point.y:.4f})\"\n\n    # Initialize an empty list for dropdown menu options\n    dropdown_buttons = []\n\n    # Calculate the midpoint between min and max of the permittivity (eps)\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n    for i, (field, freq) in enumerate(zip(fields, freqs)):\n        visible_status = [False] * (2 * num_plots)\n        visible_status[2 * i] = True  # Make the current contour (eps) visible\n        visible_status[2 * i + 1] = True  # Make the current heatmap (field) visible\n\n        # Add the contour plot for permittivity (eps) at the midpoint\n        fig.add_trace(go.Contour(z=eps.T,\n                                contours=dict(\n                                    start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                    end=midpoint,\n                                    size=0.1,  # A small size to keep it as a single contour\n                                    coloring='none'  # No filling\n                                ),\n                                line=dict(color='black', width=2),\n                                showscale=False,\n                                opacity=0.7,\n                                visible=True if i == 0 else False))  # Initially visible only for the first plot\n\n        # Add the heatmap for the real part of the electric field\n        fig.add_trace(go.Heatmap(z=np.real(field).T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=False, visible=True if i == 0 else False))\n\n        # Create a button for each field dataset for the dropdown\n        dropdown_buttons.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status},  # Update visibility for both eps and field\n                                        {'title':f\"{title}&lt;br&gt;Mode {i + 1}, freq={freq:0.3f}: {subtitle}\"}\n                                    ]))\n        mode = {\n            \"k_point\" : k_point,\n            \"frequency\" : freq,\n            \"field\" : field,\n            \"field_type\" : field_type,\n        }\n\n\n\n    # Add the dropdown menu to the layout\n    fig.update_layout(\n        updatemenus=[dict(active=0,  # The first dataset is active by default\n                        buttons=dropdown_buttons,\n                        x=1.15, y=1.15,  # Positioning the dropdown to the top right\n                        xanchor='left', yanchor='top')],\n        title=f\"{title}&lt;br&gt;Mode {1}, freq={freqs[0]:0.3f}: {subtitle}\",  # Main title + subtitle\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800\n    )\n\n\n    # Display the plot\n    return fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.square_lattice","title":"<code>square_lattice()</code>  <code>staticmethod</code>","text":"<p>Define the square lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Lattice, list[Vector3]]</code> <p>A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef square_lattice()-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n    \"\"\"\n    Define the square lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0, 1))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # M\n        mp.Vector3(0.5, 0.5),       # X\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.triangular_lattice","title":"<code>triangular_lattice()</code>  <code>staticmethod</code>","text":"<p>Define the triangular lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Lattice, list[Vector3]]</code> <p>A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef triangular_lattice()-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n    \"\"\"\n    Define the triangular lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # K\n        mp.Vector3(-1./3, 1./3),    # M\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab","title":"<code>CrystalSlab</code>","text":"<p>               Bases: <code>PhotonicCrystal</code></p> <p>CrystalSlab class represents a photonic crystal slab structure, inheriting from the PhotonicCrystal class. This class provides methods to define the lattice, geometry, and to plot various properties of the photonic crystal slab. Geometries can be added using mpb functions such as Cylinder, Ellipsoid, etc.</p> <p>Attributes:</p> Name Type Description <code>geometry_lattice</code> <code>Lattice</code> <p>The lattice structure of the photonic crystal.</p> <code>k_points</code> <code>list</code> <p>List of k-points for the simulation.</p> <code>geometry</code> <code>list</code> <p>List of geometric objects defining the photonic crystal.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points for the simulation.</p> <code>epsilon</code> <code>ndarray</code> <p>Dielectric function values obtained from the simulation.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the CrystalSlab object with the given parameters.</p> <code>plot_epsilon</code> <p>Plots the epsilon values obtained from the simulation using Plotly.</p> <code>basic_lattice</code> <p>Defines the basic lattice structure for the photonic crystal.</p> <code>square_lattice</code> <p>Defines the square lattice for the photonic crystal.</p> <code>triangular_lattice</code> <p>Defines the triangular lattice for the photonic crystal.</p> <code>basic_geometry</code> <p>Defines the basic geometry for the photonic crystal.</p> <code>ellipsoid_geometry</code> <p>Defines the geometry with ellipsoidal atoms for the photonic crystal.</p> <code>advanced_material_geometry</code> <p>Defines the advanced material geometry for the photonic crystal.</p> <code>plot_field</code> <p>Plots the field for a specific mode based on the given parameters.</p> <code>plot_field_components</code> <p>Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>class CrystalSlab(PhotonicCrystal):\n    \"\"\"\n    CrystalSlab class represents a photonic crystal slab structure, inheriting from the PhotonicCrystal class.\n    This class provides methods to define the lattice, geometry, and to plot various properties of the photonic crystal slab.\n    Geometries can be added using mpb functions such as Cylinder, Ellipsoid, etc.\n\n\n    Attributes:\n        geometry_lattice (mp.Lattice): The lattice structure of the photonic crystal.\n        k_points (list): List of k-points for the simulation.\n        geometry (list): List of geometric objects defining the photonic crystal.\n        k_points_interpolated (list): Interpolated k-points for the simulation.\n        epsilon (np.ndarray): Dielectric function values obtained from the simulation.\n\n    Methods:\n        __init__(self, lattice_type=None, num_bands=4, resolution=mp.Vector3(32,32,16), interp=2, periods=3, pickle_id=None, geometry=None, use_XY=True, k_point_max=0.2):\n            Initializes the CrystalSlab object with the given parameters.\n        plot_epsilon(self, fig=None, opacity=0.3, colorscale='PuBuGn', override_resolution_with=None, periods=1):\n            Plots the epsilon values obtained from the simulation using Plotly.\n        basic_lattice(lattice_type='square', height_supercell=4):\n            Defines the basic lattice structure for the photonic crystal.\n        square_lattice(height_supercell=4):\n            Defines the square lattice for the photonic crystal.\n        triangular_lattice(height_supercell=4):\n            Defines the triangular lattice for the photonic crystal.\n        basic_geometry(radius_1=0.2, eps_atom_1=1, radius_2=None, eps_atom_2=None, eps_bulk=12, height_supercell=4, height_slab=0.5, eps_background=1, eps_substrate=None):\n            Defines the basic geometry for the photonic crystal.\n        ellipsoid_geometry(e1=0.2, e2=0.3, eps_atom=1, height_supercell=4, height_slab=0.5, eps_background=1, eps_substrate=1, eps_diag=mp.Vector3(12, 12, 12), eps_offdiag=mp.Vector3(0, 0, 0), E_chi2_diag=mp.Vector3(0,0,0), E_chi3_diag=mp.Vector3(0,0,0)):\n            Defines the geometry with ellipsoidal atoms for the photonic crystal.\n        advanced_material_geometry(radius_1=0.2, epsilon_diag=mp.Vector3(12, 12, 12), epsilon_offdiag=mp.Vector3(0, 0, 0), chi2_diag=mp.Vector3(0,0,0), chi3_diag=mp.Vector3(0,0,0), eps_atom_1=1, eps_background=1, eps_substrate=1, height_supercell=4, height_slab=0.5):\n            Defines the advanced material geometry for the photonic crystal.\n        plot_field(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, component=2, quantity='real', colorscale='RdBu'):\n            Plots the field for a specific mode based on the given parameters.\n        plot_field_components(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', colorscale='RdBu'):\n            Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n    \"\"\"\n\n    def __init__(self,\n                lattice_type = \"square\",\n                num_bands: int = 4,\n                resolution = mp.Vector3(32,32,16),\n                interp: int =2,\n                periods: int =3, \n                pickle_id = None,\n                geometry = None, \n                use_XY = True,\n                k_point_max = 0.2):\n        \"\"\"\n        Initializes the CrystalSlab object with the given parameters.\n\n        Args:\n            lattice_type (str): The type of lattice. It can be 'square' or 'triangular'. Default is 'square'.\n            num_bands (int): The number of bands to calculate. Default is 4.\n            resolution (mp.Vector3): The resolution of the simulation. Default is mp.Vector3(32, 32, 16).\n            interp (int): The interpolation factor for k-points. Default is 2.\n            periods (int): The number of periods to use in some plotting functions. Default is 3.\n            pickle_id (str): The ID for pickling the simulation. Default is None.\n            geometry (list): The geometry of the photonic crystal. Default is None. If it is none, the basic geometry is used.\n            use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n            k_point_max (float): The maximum k-point value. Default is 0.2.\n        \"\"\"\n\n\n        super().__init__(lattice_type, num_bands, resolution, interp, periods, pickle_id, use_XY=True)\n\n\n        self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n        if use_XY is True: \n            self.k_points = [\n                mp.Vector3(k_point_max, 0, 0),      # X\n                mp.Vector3(0, 0 ,0 ),               # Gamma\n                mp.Vector3(0, k_point_max, 0)       # Y\n            ]\n        self.geometry = geometry if geometry is not None else self.basic_geometry()\n        self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n\n    def plot_epsilon(self,\n                    fig=None, \n                    opacity=0.3, \n                    colorscale='PuBuGn', \n                    override_resolution_with: None|int= None, \n                    periods = 1,\n                    )-&gt; go.Figure:\n        \"\"\"\n        Plot the epsilon values obtained from the simulation using Plotly.\n\n        Args:\n            fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n            opacity (float, optional): The opacity of the plot. Default is 0.3.\n            colorscale (str, optional): The colorscale for the plot. Default is 'PuBuGn'.\n            override_resolution_with (int, optional): The resolution to use for plotting. You can change the resolution just for the plot, but the simulation will still use the value set in the __init__ method. Default is None.\n            periods (int, optional): The number of periods to plot. Default is 1.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n\n        if self.epsilon is None:\n\n            if override_resolution_with is None:\n                resolution = self.resolution\n            else:\n                resolution = override_resolution_with\n            md = mpb.MPBData(rectify=True, periods=periods, resolution=resolution)\n\n\n            converted_eps = md.convert(self.ms.get_epsilon())\n        else:\n            converted_eps = self.epsilon\n        self.epsilon = converted_eps\n        if fig is None:\n            fig = go.Figure()\n\n        z_points = converted_eps.shape[2]//periods\n        z_mid = converted_eps.shape[2]//2\n        epsilon = converted_eps[..., z_mid-z_points//2:z_mid+z_points//2-1] \n        print(epsilon.shape)\n        epsilon = np.transpose(epsilon,(1,0,2)) \n\n        # Create indices for x, y, z axes (meshgrid)\n        x, y, z = np.meshgrid(np.arange(epsilon.shape[0]),\n                            np.arange(epsilon.shape[1]),\n                            np.arange(epsilon.shape[2]))\n\n        # Flatten the arrays for Plotly\n        x_flat = x.flatten()\n        y_flat = y.flatten()\n        z_flat = z.flatten()\n        epsilon_flat = epsilon.flatten()\n\n        # Get the minimum and maximum values from the epsilon array (ensure they are floats)\n        isomin_value = float(np.min(epsilon_flat))\n        isomax_value = float(np.max(epsilon_flat))\n\n        # Create the 3D volume plot using Plotly\n        fig = go.Figure(data=go.Volume(\n            x=x_flat, y=y_flat, z=z_flat,\n            value=epsilon_flat,  # Use the dielectric function values\n            isomin=isomin_value,\n            isomax=isomax_value,\n            opacity=opacity,  # Adjust opacity to visualize internal structure\n            surface_count=3,  # Number of surfaces to display\n            colorscale=colorscale,  # Color scale for the dielectric function\n            colorbar=dict(title='Dielectric Constant')\n        ))\n\n        # Add layout details\n        fig.update_layout(\n            title='3D Volume Plot of Dielectric Function',\n            scene=dict(\n            xaxis=dict(title='X', visible=True),\n            yaxis=dict(title='Y', visible=True),\n            zaxis=dict(title='Z', visible=True),\n            )\n        )\n\n        fig.update_layout(height=800, width=600)\n\n        return fig\n\n    @staticmethod\n    def basic_lattice(lattice_type='square', height_supercell=4)-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n        \"\"\"\n        Define the basic lattice structure for the photonic crystal.\n\n        Args:\n            lattice_type (str): The type of lattice. Default is 'square'.\n            height_supercell (int): The height of the supercell. Default is 4.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n        \"\"\"\n\n        if lattice_type == 'square':\n            return CrystalSlab.square_lattice()\n        elif lattice_type == 'triangular':\n            return CrystalSlab.triangular_lattice()\n        else:\n            raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n\n    @staticmethod\n    def square_lattice(height_supercell=4)-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n        \"\"\"\n        Define the square lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0, 1))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # M\n            mp.Vector3(0.5, 0.5),       # X\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n    @staticmethod\n    def triangular_lattice(height_supercell=4)-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n        \"\"\"\n        Define the triangular lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # K\n            mp.Vector3(-1./3, 1./3),    # M\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n    @staticmethod\n    def basic_geometry(radius_1=0.2,  \n                       eps_atom_1=1, \n                       radius_2=None, \n                       eps_atom_2=None,\n                       eps_bulk = 12,\n                       height_supercell=4, \n                       height_slab=0.5,\n                       eps_background=1,\n                       eps_substrate=None,\n                       )-&gt; list:\n        \"\"\"\n        Define the basic geometry for the photonic crystal.\n        Biatomic structures have not been tested. \n\n        Args:\n            radius_1 (float): The radius of the first atom. Default is 0.2.\n            eps_atom_1 (float): The dielectric constant of the first atom. Default is 1.\n            radius_2 (float, optional): The radius of the second atom. Default is None.\n            eps_atom_2 (float, optional): The dielectric constant of the second atom. Default is None.\n            eps_bulk (float): The dielectric constant of the bulk. Default is 12.\n            height_supercell (float): The height of the supercell. Default is 4.\n            height_slab (float): The height of the slab. Default is 0.5.\n            eps_background (float): The dielectric constant of the background. Default is 1.\n            eps_substrate (float, optional): The dielectric constant of the substrate. Default is None.\n\n        Returns:\n            list: A list of geometric objects defining the photonic crystal.\n        \"\"\"\n\n        geometry = []\n\n        #background\n        geometry.append(\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf, height_supercell),\n                material=mp.Medium(epsilon=eps_background)),\n\n        )\n\n        #substrate\n        if eps_substrate is not None:\n            geometry.append(mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf, height_supercell*0.5),\n                center = mp.Vector3(0, 0, -height_supercell*0.25),\n                material=mp.Medium(epsilon=eps_substrate)))\n\n\n        #slab\n        geometry.append(\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf, height_slab),\n                material=mp.Medium(epsilon=eps_bulk)),\n        )\n\n        #atoms    \n        if radius_2 is None:\n            geometry.append(mp.Cylinder(radius_1, \n                                        material=mp.Medium(epsilon=eps_atom_1),\n                                        height=height_slab))\n\n\n        else:\n            geometry.append(mp.Cylinder(radius_1, \n                                        material=mp.Medium(epsilon=eps_atom_1),\n                                        height=height_slab))\n            geometry.append(mp.Cylinder(radius_2, \n                                        material=mp.Medium(epsilon=eps_atom_2),\n                                        height=height_slab))\n\n        return geometry\n\n\n    def ellipsoid_geometry(e1: float=0.2,\n                           e2: float = 0.3,\n                           eps_atom = 1,\n                           height_supercell=4,\n                           height_slab=0.5,\n                           eps_background=1,\n                           eps_substrate=1,\n                           eps_diag = mp.Vector3(12, 12, 12),\n                           eps_offdiag = mp.Vector3(0, 0, 0),\n                           E_chi2_diag = mp.Vector3(0,0,0),\n                           E_chi3_diag = mp.Vector3(0,0,0),\n                           )-&gt; list:       \n        \"\"\"\n        Define an ellipsoid geometry for the photonic crystal.\n\n        Args:\n            e1 (float): The first radius of the ellipsoid. Default is 0.2.\n            e2 (float): The second radius of the ellipsoid. Default is 0.3.\n            eps_atom (float): The dielectric constant of the atom. Default is 1.\n            height_supercell (float): The height of the supercell. Default is 4.\n            height_slab (float): The height of the slab. Default is 0.5.\n            eps_background (float): The dielectric constant of the background. Default is 1.\n            eps_substrate (float): The dielectric constant of the substrate. Default is 1.\n            eps_diag (mp.Vector3): The diagonal components of the dielectric tensor. Default is (12, 12, 12).\n            eps_offdiag (mp.Vector3): The off-diagonal components of the dielectric tensor. Default is (0, 0, 0).\n            E_chi2_diag (mp.Vector3): The diagonal components of the second-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n            E_chi3_diag (mp.Vector3): The diagonal components of the third-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n\n        Returns:\n            list: A list of mpb geometric objects defining the photonic crystal.\n        \"\"\"\n\n        geometry = [\n            #background\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf, height_supercell),\n                material=mp.Medium(epsilon=eps_background)),\n            #substrate\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf, height_supercell*0.5),\n                center = mp.Vector3(0, 0, -height_supercell*0.25),\n                material=mp.Medium(epsilon=eps_substrate)),\n            #slab\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf, height_slab),\n                material=mp.Medium(epsilon_diag=eps_diag,\n                                   epsilon_offdiag = eps_offdiag,\n                                   E_chi2_diag = E_chi2_diag,\n                                   E_chi3_diag = E_chi3_diag)),\n            #atom\n            mp.Ellipsoid(size=mp.Vector3(e1,e2, mp.inf),\n                         material=mp.Medium(epsilon=eps_atom),\n                         center=mp.Vector3(0,0,0))\n        ]\n        return geometry\n\n\n\n    def advanced_material_geometry(\n        radius_1 = 0.2,\n        epsilon_diag = mp.Vector3(12, 12, 12),\n        epsilon_offdiag =  mp.Vector3(0, 0, 0),\n        chi2_diag =  mp.Vector3(0,0,0),  \n        chi3_diag =  mp.Vector3(0,0,0),\n        eps_atom_1 = 1, \n        eps_background  = 1, \n        eps_substrate = 1,\n        height_supercell = 4, \n        height_slab = 0.5\n    )-&gt; list:\n        \"\"\"\n        Define an advanced material geometry for the photonic crystal.\n\n        Args:\n            radius_1 (float): The radius of the atom. Default is 0.2.\n            epsilon_diag (mp.Vector3): The diagonal components of the dielectric tensor. Default is (12, 12, 12).\n            epsilon_offdiag (mp.Vector3): The off-diagonal components of the dielectric tensor. Default is (0, 0, 0).\n            chi2_diag (mp.Vector3): The diagonal components of the second-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n            chi3_diag (mp.Vector3): The diagonal components of the third-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n            eps_atom_1 (float): The dielectric constant of the atom. Default is 1.\n            eps_background (float): The dielectric constant of the background. Default is 1.\n            eps_substrate (float): The dielectric constant of the substrate. Default is 1.\n            height_supercell (float): The height of the supercell. Default is 4.\n            height_slab (float): The height of the slab. Default is 0.5.\n\n        Returns:\n            list: A list of geometric objects defining the photonic crystal.\n        \"\"\"\n\n\n        geometry = []\n\n        #background\n        geometry.append(\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf, height_supercell),\n                material=mp.Medium(epsilon=eps_background)),\n\n        )\n\n        #substrate\n        if eps_substrate is not None:\n            geometry.append(mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf, height_supercell*0.5),\n                center = mp.Vector3(0, 0, -height_supercell*0.25),\n                material=mp.Medium(epsilon=eps_substrate)))\n\n        #slab\n        geometry.append(\n            mp.Block(\n                size = mp.Vector3(mp.inf, mp.inf, height_slab),\n                material=mp.Medium(epsilon_diag=epsilon_diag, \n                                   epsilon_offdiag = epsilon_offdiag,\n                                   E_chi2_diag = chi2_diag,\n                                   E_chi3_diag = chi3_diag,)\n                                ),\n        )\n\n        #atom 1\n        geometry.append(mp.Cylinder(radius_1, \n                                        material=mp.Medium(epsilon=eps_atom_1),\n                                        height=height_slab))\n        return geometry\n\n\n\n    def plot_field(self, \n            target_polarization, \n            target_k_point, \n            target_frequency, \n            frequency_tolerance = 0.01, \n            k_point_max_distance = None,\n            periods: int=1, \n            component: int = 2, \n            quantity: str = \"real\", \n            colorscale: str = 'RdBu',                  \n            ):\n        \"\"\"\n        Plot the field for a specific mode based on the given parameters.\n\n        Args:\n            target_polarization (str): The polarization of the target mode.\n            target_k_point (tuple): The k-point of the target mode.\n            target_frequency (float): The frequency of the target mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            periods (int): The number of periods to extract. Default is 1.\n            component (int): The component of the field to plot (0 for x, 1 for y, 2 for z). Default is 2.\n            quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n            colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n        Returns:\n            tuple: A tuple containing the electric field figure and the magnetic field figure.\n        \"\"\"\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, freq_tolerance = frequency_tolerance, k_point_max_distance = k_point_max_distance)\n        print(len(target_modes))\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon()) \n\n        z_points = eps.shape[2] // periods\n        z_mid = eps.shape[2] // 2\n\n        # Now take only epsilon in the center of the slab\n        eps = eps[..., z_mid]\n        # Calculate the midpoint between min and max of the permittivity (eps)\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        num_plots = len(target_modes)\n\n        for i, mode in enumerate(target_modes):\n            # Initialize visibility status: False for all traces\n            visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n            visible_status_h = [False] * (2 * num_plots)\n\n            visible_status_e[2 * i] = True  # Set the contour plot visible\n            visible_status_h[2 * i] = True\n            visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n            visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n            k_point = mode[\"k_point\"]\n            freq    = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n\n            # Take the specified component of the fields in the center of the slab\n\n            e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n            h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n            e_field = e_field[..., z_points // 2, component]\n            h_field = h_field[..., z_points // 2, component]\n            with suppress_output():\n                e_field = md.convert(e_field) \n                h_field = md.convert(h_field)\n\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n            # Add the contour plot for permittivity (eps) at the midpoint\n            contour_e = go.Contour(z=eps.T,\n                                contours=dict(\n                                    start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                    end=midpoint,\n                                    size=0.1,  # A small size to keep it as a single contour\n                                    coloring='none'  # No filling\n                                ),\n                                line=dict(color='black', width=2),\n                                showscale=False,\n                                opacity=0.7,\n                                visible=True if i ==  0  else False)  # Only the first mode is visible\n            contour_h = contour_e  # Same contour for H-field figure\n\n            # Add the contour trace\n            fig_e.add_trace(contour_e)\n            fig_h.add_trace(contour_h)\n\n            # Add the heatmap for the electric field\n            heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n            # Add the heatmap for the magnetic field\n            heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n\n            # Add the heatmap trace\n            fig_e.add_trace(heatmap_e)\n            fig_h.add_trace(heatmap_h)\n\n\n\n            data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n            if component == 0: \n                component_str = \"x-component\"\n            elif component == 1:\n                component_str = \"y-component\"\n            else:\n                component_str = \"z-component\"\n            subtitle_e = f\"E-field, {component_str}, {quantity}\"\n            subtitle_h = f\"H-field, {component_str}, {quantity}\"\n            # Create a button for each field dataset for the dropdown\n            dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                        ]))\n            dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                        ]))\n\n        print(len(target_modes))\n        k_point = target_modes[0][\"k_point\"]\n        freq    = target_modes[0][\"freq\"]\n        data_str = f\"Mode {0} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n        fig_e.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_e,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n\n        )\n\n        fig_h.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_h,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n        )\n\n        return fig_e, fig_h\n\n\n\n    def plot_field_components(self,\n                            target_polarization,\n                            target_k_point,\n                            target_frequency,\n                            frequency_tolerance=0.01,\n                            k_point_max_distance=None,\n                            periods: int = 1,\n                            quantity: str = \"real\",\n                            colorscale: str = 'RdBu',\n                            )-&gt; tuple:\n        \"\"\"\n        Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n\n        Args:\n            target_polarization (str): The polarization of the target mode.\n            target_k_point (tuple): The k-point of the target mode.\n            target_frequency (float): The frequency of the target mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            periods (int): The number of periods to extract. Default is 1.\n            quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n            colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n        Returns:\n            tuple: A tuple containing the electric field figure and the magnetic field figure.\n        \"\"\"\n\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                        freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n        print(f\"Number of target modes found: {len(target_modes)}\")\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon())\n\n        z_points = eps.shape[2] // periods\n        z_mid = eps.shape[2] // 2\n\n        # Now take only epsilon in the center of the slab\n        eps = eps[..., z_mid]\n        # Calculate the midpoint between min and max of the permittivity (eps)\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n        fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n        fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        # For each mode, calculate separate min and max values for Ex, Ey, Ez (and similarly Hx, Hy, Hz)\n        for i, mode in enumerate(target_modes):\n            # Get field arrays for this mode\n            e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n            # Extract field components in the center of the slab\n            e_field_x = e_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n            e_field_y = e_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n            e_field_z = e_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n            h_field_x = h_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n            h_field_y = h_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n            h_field_z = h_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n\n            with suppress_output():\n                e_field_x = md.convert(e_field_x)\n                e_field_y = md.convert(e_field_y)\n                e_field_z = md.convert(e_field_z)\n                h_field_x = md.convert(h_field_x)\n                h_field_y = md.convert(h_field_y)\n                h_field_z = md.convert(h_field_z)\n\n            e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n            h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)                                    \n\n            # Select quantity to display (real, imag, abs)\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n            # Calculate the component-specific min/max for E and H fields of this mode\n            e_min = np.min(e_field)\n            e_max = np.max(e_field)\n            h_min = np.min(h_field)\n            h_max = np.max(h_field)\n\n            # Components of the E and H fields\n            Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n            Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n            # Define visibility settings per mode, including contours as always visible\n            visible_status_e = [False] * (len(target_modes) * 6)  # 3 components per mode, with contour for each\n            visible_status_h = [False] * (len(target_modes) * 6)\n            # Make the contour visible by default\n\n\n\n\n            # Make this mode's components and the corresponding contour visible in the initial layout \n            for j in range(6):\n                visible_status_e[6*i + j] = True\n                visible_status_h[6*i + j] = True\n\n\n            # Add contour traces for permittivity to each subplot of fig_e and fig_h for this mode\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n            # Add Ex, Ey, Ez with shared colorbar limits for the E field of this mode\n            fig_e.add_trace(go.Heatmap(z=Ex.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n            fig_e.add_trace(go.Heatmap(z=Ey.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n            fig_e.add_trace(go.Heatmap(z=Ez.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"E-field\", len=0.75, thickness=15), zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n            # Add Hx, Hy, Hz with shared colorbar limits for the H field of this mode\n            fig_h.add_trace(go.Heatmap(z=Hx.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n            fig_h.add_trace(go.Heatmap(z=Hy.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n            fig_h.add_trace(go.Heatmap(z=Hz.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"H-field\", len=0.75, thickness=15), zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n\n\n            # Dropdown data for E-field\n            k_point = mode[\"k_point\"]\n            freq = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n            mode_description = f\"Mode {i + 1}&lt;br&gt;k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n            dropdown_buttons_e.append(\n                dict(label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[{'visible': visible_status_e},\n                        {'title': f\"{mode_description}: {quantity} of E-field components\"}]))\n\n            dropdown_buttons_h.append(\n                dict(label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[{'visible': visible_status_h},\n                        {'title': f\"{mode_description}: {quantity} of H-field components\"}]))\n\n        # Layout and color settings\n        fig_e.update_layout(\n            title=f\"{mode_description}: {quantity} of E-field components\",\n            updatemenus=[dict(\n                active=len(target_modes) - 1,\n                buttons=dropdown_buttons_e)],\n            coloraxis=dict(colorbar=dict(len=0.75)),\n            width=1200, height=400,\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        fig_h.update_layout(\n            title=f\"{mode_description}: {quantity} of H-field components\",\n            updatemenus=[dict(\n                active=len(target_modes) - 1,\n                buttons=dropdown_buttons_h)],\n            coloraxis=dict(colorbar=dict(len=0.75)),\n            width=1200, height=400,\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        # Final adjustments\n        fig_e.update_xaxes(showticklabels=False)\n        fig_e.update_yaxes(showticklabels=False)\n        fig_h.update_xaxes(showticklabels=False)\n        fig_h.update_yaxes(showticklabels=False)\n\n        fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n        fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n        return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.__init__","title":"<code>__init__(lattice_type='square', num_bands=4, resolution=mp.Vector3(32, 32, 16), interp=2, periods=3, pickle_id=None, geometry=None, use_XY=True, k_point_max=0.2)</code>","text":"<p>Initializes the CrystalSlab object with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. It can be 'square' or 'triangular'. Default is 'square'.</p> <code>'square'</code> <code>num_bands</code> <code>int</code> <p>The number of bands to calculate. Default is 4.</p> <code>4</code> <code>resolution</code> <code>Vector3</code> <p>The resolution of the simulation. Default is mp.Vector3(32, 32, 16).</p> <code>Vector3(32, 32, 16)</code> <code>interp</code> <code>int</code> <p>The interpolation factor for k-points. Default is 2.</p> <code>2</code> <code>periods</code> <code>int</code> <p>The number of periods to use in some plotting functions. Default is 3.</p> <code>3</code> <code>pickle_id</code> <code>str</code> <p>The ID for pickling the simulation. Default is None.</p> <code>None</code> <code>geometry</code> <code>list</code> <p>The geometry of the photonic crystal. Default is None. If it is none, the basic geometry is used.</p> <code>None</code> <code>use_XY</code> <code>bool</code> <p>Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.</p> <code>True</code> <code>k_point_max</code> <code>float</code> <p>The maximum k-point value. Default is 0.2.</p> <code>0.2</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def __init__(self,\n            lattice_type = \"square\",\n            num_bands: int = 4,\n            resolution = mp.Vector3(32,32,16),\n            interp: int =2,\n            periods: int =3, \n            pickle_id = None,\n            geometry = None, \n            use_XY = True,\n            k_point_max = 0.2):\n    \"\"\"\n    Initializes the CrystalSlab object with the given parameters.\n\n    Args:\n        lattice_type (str): The type of lattice. It can be 'square' or 'triangular'. Default is 'square'.\n        num_bands (int): The number of bands to calculate. Default is 4.\n        resolution (mp.Vector3): The resolution of the simulation. Default is mp.Vector3(32, 32, 16).\n        interp (int): The interpolation factor for k-points. Default is 2.\n        periods (int): The number of periods to use in some plotting functions. Default is 3.\n        pickle_id (str): The ID for pickling the simulation. Default is None.\n        geometry (list): The geometry of the photonic crystal. Default is None. If it is none, the basic geometry is used.\n        use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n        k_point_max (float): The maximum k-point value. Default is 0.2.\n    \"\"\"\n\n\n    super().__init__(lattice_type, num_bands, resolution, interp, periods, pickle_id, use_XY=True)\n\n\n    self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n    if use_XY is True: \n        self.k_points = [\n            mp.Vector3(k_point_max, 0, 0),      # X\n            mp.Vector3(0, 0 ,0 ),               # Gamma\n            mp.Vector3(0, k_point_max, 0)       # Y\n        ]\n    self.geometry = geometry if geometry is not None else self.basic_geometry()\n    self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.advanced_material_geometry","title":"<code>advanced_material_geometry(radius_1=0.2, epsilon_diag=mp.Vector3(12, 12, 12), epsilon_offdiag=mp.Vector3(0, 0, 0), chi2_diag=mp.Vector3(0, 0, 0), chi3_diag=mp.Vector3(0, 0, 0), eps_atom_1=1, eps_background=1, eps_substrate=1, height_supercell=4, height_slab=0.5)</code>","text":"<p>Define an advanced material geometry for the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>radius_1</code> <code>float</code> <p>The radius of the atom. Default is 0.2.</p> <code>0.2</code> <code>epsilon_diag</code> <code>Vector3</code> <p>The diagonal components of the dielectric tensor. Default is (12, 12, 12).</p> <code>Vector3(12, 12, 12)</code> <code>epsilon_offdiag</code> <code>Vector3</code> <p>The off-diagonal components of the dielectric tensor. Default is (0, 0, 0).</p> <code>Vector3(0, 0, 0)</code> <code>chi2_diag</code> <code>Vector3</code> <p>The diagonal components of the second-order nonlinear susceptibility tensor. Default is (0, 0, 0).</p> <code>Vector3(0, 0, 0)</code> <code>chi3_diag</code> <code>Vector3</code> <p>The diagonal components of the third-order nonlinear susceptibility tensor. Default is (0, 0, 0).</p> <code>Vector3(0, 0, 0)</code> <code>eps_atom_1</code> <code>float</code> <p>The dielectric constant of the atom. Default is 1.</p> <code>1</code> <code>eps_background</code> <code>float</code> <p>The dielectric constant of the background. Default is 1.</p> <code>1</code> <code>eps_substrate</code> <code>float</code> <p>The dielectric constant of the substrate. Default is 1.</p> <code>1</code> <code>height_supercell</code> <code>float</code> <p>The height of the supercell. Default is 4.</p> <code>4</code> <code>height_slab</code> <code>float</code> <p>The height of the slab. Default is 0.5.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of geometric objects defining the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def advanced_material_geometry(\n    radius_1 = 0.2,\n    epsilon_diag = mp.Vector3(12, 12, 12),\n    epsilon_offdiag =  mp.Vector3(0, 0, 0),\n    chi2_diag =  mp.Vector3(0,0,0),  \n    chi3_diag =  mp.Vector3(0,0,0),\n    eps_atom_1 = 1, \n    eps_background  = 1, \n    eps_substrate = 1,\n    height_supercell = 4, \n    height_slab = 0.5\n)-&gt; list:\n    \"\"\"\n    Define an advanced material geometry for the photonic crystal.\n\n    Args:\n        radius_1 (float): The radius of the atom. Default is 0.2.\n        epsilon_diag (mp.Vector3): The diagonal components of the dielectric tensor. Default is (12, 12, 12).\n        epsilon_offdiag (mp.Vector3): The off-diagonal components of the dielectric tensor. Default is (0, 0, 0).\n        chi2_diag (mp.Vector3): The diagonal components of the second-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n        chi3_diag (mp.Vector3): The diagonal components of the third-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n        eps_atom_1 (float): The dielectric constant of the atom. Default is 1.\n        eps_background (float): The dielectric constant of the background. Default is 1.\n        eps_substrate (float): The dielectric constant of the substrate. Default is 1.\n        height_supercell (float): The height of the supercell. Default is 4.\n        height_slab (float): The height of the slab. Default is 0.5.\n\n    Returns:\n        list: A list of geometric objects defining the photonic crystal.\n    \"\"\"\n\n\n    geometry = []\n\n    #background\n    geometry.append(\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf, height_supercell),\n            material=mp.Medium(epsilon=eps_background)),\n\n    )\n\n    #substrate\n    if eps_substrate is not None:\n        geometry.append(mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf, height_supercell*0.5),\n            center = mp.Vector3(0, 0, -height_supercell*0.25),\n            material=mp.Medium(epsilon=eps_substrate)))\n\n    #slab\n    geometry.append(\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf, height_slab),\n            material=mp.Medium(epsilon_diag=epsilon_diag, \n                               epsilon_offdiag = epsilon_offdiag,\n                               E_chi2_diag = chi2_diag,\n                               E_chi3_diag = chi3_diag,)\n                            ),\n    )\n\n    #atom 1\n    geometry.append(mp.Cylinder(radius_1, \n                                    material=mp.Medium(epsilon=eps_atom_1),\n                                    height=height_slab))\n    return geometry\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.basic_geometry","title":"<code>basic_geometry(radius_1=0.2, eps_atom_1=1, radius_2=None, eps_atom_2=None, eps_bulk=12, height_supercell=4, height_slab=0.5, eps_background=1, eps_substrate=None)</code>  <code>staticmethod</code>","text":"<p>Define the basic geometry for the photonic crystal. Biatomic structures have not been tested. </p> <p>Parameters:</p> Name Type Description Default <code>radius_1</code> <code>float</code> <p>The radius of the first atom. Default is 0.2.</p> <code>0.2</code> <code>eps_atom_1</code> <code>float</code> <p>The dielectric constant of the first atom. Default is 1.</p> <code>1</code> <code>radius_2</code> <code>float</code> <p>The radius of the second atom. Default is None.</p> <code>None</code> <code>eps_atom_2</code> <code>float</code> <p>The dielectric constant of the second atom. Default is None.</p> <code>None</code> <code>eps_bulk</code> <code>float</code> <p>The dielectric constant of the bulk. Default is 12.</p> <code>12</code> <code>height_supercell</code> <code>float</code> <p>The height of the supercell. Default is 4.</p> <code>4</code> <code>height_slab</code> <code>float</code> <p>The height of the slab. Default is 0.5.</p> <code>0.5</code> <code>eps_background</code> <code>float</code> <p>The dielectric constant of the background. Default is 1.</p> <code>1</code> <code>eps_substrate</code> <code>float</code> <p>The dielectric constant of the substrate. Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of geometric objects defining the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_geometry(radius_1=0.2,  \n                   eps_atom_1=1, \n                   radius_2=None, \n                   eps_atom_2=None,\n                   eps_bulk = 12,\n                   height_supercell=4, \n                   height_slab=0.5,\n                   eps_background=1,\n                   eps_substrate=None,\n                   )-&gt; list:\n    \"\"\"\n    Define the basic geometry for the photonic crystal.\n    Biatomic structures have not been tested. \n\n    Args:\n        radius_1 (float): The radius of the first atom. Default is 0.2.\n        eps_atom_1 (float): The dielectric constant of the first atom. Default is 1.\n        radius_2 (float, optional): The radius of the second atom. Default is None.\n        eps_atom_2 (float, optional): The dielectric constant of the second atom. Default is None.\n        eps_bulk (float): The dielectric constant of the bulk. Default is 12.\n        height_supercell (float): The height of the supercell. Default is 4.\n        height_slab (float): The height of the slab. Default is 0.5.\n        eps_background (float): The dielectric constant of the background. Default is 1.\n        eps_substrate (float, optional): The dielectric constant of the substrate. Default is None.\n\n    Returns:\n        list: A list of geometric objects defining the photonic crystal.\n    \"\"\"\n\n    geometry = []\n\n    #background\n    geometry.append(\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf, height_supercell),\n            material=mp.Medium(epsilon=eps_background)),\n\n    )\n\n    #substrate\n    if eps_substrate is not None:\n        geometry.append(mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf, height_supercell*0.5),\n            center = mp.Vector3(0, 0, -height_supercell*0.25),\n            material=mp.Medium(epsilon=eps_substrate)))\n\n\n    #slab\n    geometry.append(\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf, height_slab),\n            material=mp.Medium(epsilon=eps_bulk)),\n    )\n\n    #atoms    \n    if radius_2 is None:\n        geometry.append(mp.Cylinder(radius_1, \n                                    material=mp.Medium(epsilon=eps_atom_1),\n                                    height=height_slab))\n\n\n    else:\n        geometry.append(mp.Cylinder(radius_1, \n                                    material=mp.Medium(epsilon=eps_atom_1),\n                                    height=height_slab))\n        geometry.append(mp.Cylinder(radius_2, \n                                    material=mp.Medium(epsilon=eps_atom_2),\n                                    height=height_slab))\n\n    return geometry\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.basic_lattice","title":"<code>basic_lattice(lattice_type='square', height_supercell=4)</code>  <code>staticmethod</code>","text":"<p>Define the basic lattice structure for the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. Default is 'square'.</p> <code>'square'</code> <code>height_supercell</code> <code>int</code> <p>The height of the supercell. Default is 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Lattice, list[Vector3]]</code> <p>A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_lattice(lattice_type='square', height_supercell=4)-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n    \"\"\"\n    Define the basic lattice structure for the photonic crystal.\n\n    Args:\n        lattice_type (str): The type of lattice. Default is 'square'.\n        height_supercell (int): The height of the supercell. Default is 4.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n    \"\"\"\n\n    if lattice_type == 'square':\n        return CrystalSlab.square_lattice()\n    elif lattice_type == 'triangular':\n        return CrystalSlab.triangular_lattice()\n    else:\n        raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.ellipsoid_geometry","title":"<code>ellipsoid_geometry(e1=0.2, e2=0.3, eps_atom=1, height_supercell=4, height_slab=0.5, eps_background=1, eps_substrate=1, eps_diag=mp.Vector3(12, 12, 12), eps_offdiag=mp.Vector3(0, 0, 0), E_chi2_diag=mp.Vector3(0, 0, 0), E_chi3_diag=mp.Vector3(0, 0, 0))</code>","text":"<p>Define an ellipsoid geometry for the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>e1</code> <code>float</code> <p>The first radius of the ellipsoid. Default is 0.2.</p> <code>0.2</code> <code>e2</code> <code>float</code> <p>The second radius of the ellipsoid. Default is 0.3.</p> <code>0.3</code> <code>eps_atom</code> <code>float</code> <p>The dielectric constant of the atom. Default is 1.</p> <code>1</code> <code>height_supercell</code> <code>float</code> <p>The height of the supercell. Default is 4.</p> <code>4</code> <code>height_slab</code> <code>float</code> <p>The height of the slab. Default is 0.5.</p> <code>0.5</code> <code>eps_background</code> <code>float</code> <p>The dielectric constant of the background. Default is 1.</p> <code>1</code> <code>eps_substrate</code> <code>float</code> <p>The dielectric constant of the substrate. Default is 1.</p> <code>1</code> <code>eps_diag</code> <code>Vector3</code> <p>The diagonal components of the dielectric tensor. Default is (12, 12, 12).</p> <code>Vector3(12, 12, 12)</code> <code>eps_offdiag</code> <code>Vector3</code> <p>The off-diagonal components of the dielectric tensor. Default is (0, 0, 0).</p> <code>Vector3(0, 0, 0)</code> <code>E_chi2_diag</code> <code>Vector3</code> <p>The diagonal components of the second-order nonlinear susceptibility tensor. Default is (0, 0, 0).</p> <code>Vector3(0, 0, 0)</code> <code>E_chi3_diag</code> <code>Vector3</code> <p>The diagonal components of the third-order nonlinear susceptibility tensor. Default is (0, 0, 0).</p> <code>Vector3(0, 0, 0)</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of mpb geometric objects defining the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def ellipsoid_geometry(e1: float=0.2,\n                       e2: float = 0.3,\n                       eps_atom = 1,\n                       height_supercell=4,\n                       height_slab=0.5,\n                       eps_background=1,\n                       eps_substrate=1,\n                       eps_diag = mp.Vector3(12, 12, 12),\n                       eps_offdiag = mp.Vector3(0, 0, 0),\n                       E_chi2_diag = mp.Vector3(0,0,0),\n                       E_chi3_diag = mp.Vector3(0,0,0),\n                       )-&gt; list:       \n    \"\"\"\n    Define an ellipsoid geometry for the photonic crystal.\n\n    Args:\n        e1 (float): The first radius of the ellipsoid. Default is 0.2.\n        e2 (float): The second radius of the ellipsoid. Default is 0.3.\n        eps_atom (float): The dielectric constant of the atom. Default is 1.\n        height_supercell (float): The height of the supercell. Default is 4.\n        height_slab (float): The height of the slab. Default is 0.5.\n        eps_background (float): The dielectric constant of the background. Default is 1.\n        eps_substrate (float): The dielectric constant of the substrate. Default is 1.\n        eps_diag (mp.Vector3): The diagonal components of the dielectric tensor. Default is (12, 12, 12).\n        eps_offdiag (mp.Vector3): The off-diagonal components of the dielectric tensor. Default is (0, 0, 0).\n        E_chi2_diag (mp.Vector3): The diagonal components of the second-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n        E_chi3_diag (mp.Vector3): The diagonal components of the third-order nonlinear susceptibility tensor. Default is (0, 0, 0).\n\n    Returns:\n        list: A list of mpb geometric objects defining the photonic crystal.\n    \"\"\"\n\n    geometry = [\n        #background\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf, height_supercell),\n            material=mp.Medium(epsilon=eps_background)),\n        #substrate\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf, height_supercell*0.5),\n            center = mp.Vector3(0, 0, -height_supercell*0.25),\n            material=mp.Medium(epsilon=eps_substrate)),\n        #slab\n        mp.Block(\n            size = mp.Vector3(mp.inf, mp.inf, height_slab),\n            material=mp.Medium(epsilon_diag=eps_diag,\n                               epsilon_offdiag = eps_offdiag,\n                               E_chi2_diag = E_chi2_diag,\n                               E_chi3_diag = E_chi3_diag)),\n        #atom\n        mp.Ellipsoid(size=mp.Vector3(e1,e2, mp.inf),\n                     material=mp.Medium(epsilon=eps_atom),\n                     center=mp.Vector3(0,0,0))\n    ]\n    return geometry\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.plot_epsilon","title":"<code>plot_epsilon(fig=None, opacity=0.3, colorscale='PuBuGn', override_resolution_with=None, periods=1)</code>","text":"<p>Plot the epsilon values obtained from the simulation using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the epsilon plot to. Default is None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the plot. Default is 0.3.</p> <code>0.3</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the plot. Default is 'PuBuGn'.</p> <code>'PuBuGn'</code> <code>override_resolution_with</code> <code>int</code> <p>The resolution to use for plotting. You can change the resolution just for the plot, but the simulation will still use the value set in the init method. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to plot. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_epsilon(self,\n                fig=None, \n                opacity=0.3, \n                colorscale='PuBuGn', \n                override_resolution_with: None|int= None, \n                periods = 1,\n                )-&gt; go.Figure:\n    \"\"\"\n    Plot the epsilon values obtained from the simulation using Plotly.\n\n    Args:\n        fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n        opacity (float, optional): The opacity of the plot. Default is 0.3.\n        colorscale (str, optional): The colorscale for the plot. Default is 'PuBuGn'.\n        override_resolution_with (int, optional): The resolution to use for plotting. You can change the resolution just for the plot, but the simulation will still use the value set in the __init__ method. Default is None.\n        periods (int, optional): The number of periods to plot. Default is 1.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n\n    if self.epsilon is None:\n\n        if override_resolution_with is None:\n            resolution = self.resolution\n        else:\n            resolution = override_resolution_with\n        md = mpb.MPBData(rectify=True, periods=periods, resolution=resolution)\n\n\n        converted_eps = md.convert(self.ms.get_epsilon())\n    else:\n        converted_eps = self.epsilon\n    self.epsilon = converted_eps\n    if fig is None:\n        fig = go.Figure()\n\n    z_points = converted_eps.shape[2]//periods\n    z_mid = converted_eps.shape[2]//2\n    epsilon = converted_eps[..., z_mid-z_points//2:z_mid+z_points//2-1] \n    print(epsilon.shape)\n    epsilon = np.transpose(epsilon,(1,0,2)) \n\n    # Create indices for x, y, z axes (meshgrid)\n    x, y, z = np.meshgrid(np.arange(epsilon.shape[0]),\n                        np.arange(epsilon.shape[1]),\n                        np.arange(epsilon.shape[2]))\n\n    # Flatten the arrays for Plotly\n    x_flat = x.flatten()\n    y_flat = y.flatten()\n    z_flat = z.flatten()\n    epsilon_flat = epsilon.flatten()\n\n    # Get the minimum and maximum values from the epsilon array (ensure they are floats)\n    isomin_value = float(np.min(epsilon_flat))\n    isomax_value = float(np.max(epsilon_flat))\n\n    # Create the 3D volume plot using Plotly\n    fig = go.Figure(data=go.Volume(\n        x=x_flat, y=y_flat, z=z_flat,\n        value=epsilon_flat,  # Use the dielectric function values\n        isomin=isomin_value,\n        isomax=isomax_value,\n        opacity=opacity,  # Adjust opacity to visualize internal structure\n        surface_count=3,  # Number of surfaces to display\n        colorscale=colorscale,  # Color scale for the dielectric function\n        colorbar=dict(title='Dielectric Constant')\n    ))\n\n    # Add layout details\n    fig.update_layout(\n        title='3D Volume Plot of Dielectric Function',\n        scene=dict(\n        xaxis=dict(title='X', visible=True),\n        yaxis=dict(title='Y', visible=True),\n        zaxis=dict(title='Z', visible=True),\n        )\n    )\n\n    fig.update_layout(height=800, width=600)\n\n    return fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.plot_field","title":"<code>plot_field(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, component=2, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the field for a specific mode based on the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the target mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the target mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the target mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>component</code> <code>int</code> <p>The component of the field to plot (0 for x, 1 for y, 2 for z). Default is 2.</p> <code>2</code> <code>quantity</code> <code>str</code> <p>The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale to use for the plot. Default is 'RdBu'.</p> <code>'RdBu'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the electric field figure and the magnetic field figure.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field(self, \n        target_polarization, \n        target_k_point, \n        target_frequency, \n        frequency_tolerance = 0.01, \n        k_point_max_distance = None,\n        periods: int=1, \n        component: int = 2, \n        quantity: str = \"real\", \n        colorscale: str = 'RdBu',                  \n        ):\n    \"\"\"\n    Plot the field for a specific mode based on the given parameters.\n\n    Args:\n        target_polarization (str): The polarization of the target mode.\n        target_k_point (tuple): The k-point of the target mode.\n        target_frequency (float): The frequency of the target mode.\n        frequency_tolerance (float): The tolerance for frequency similarity.\n        periods (int): The number of periods to extract. Default is 1.\n        component (int): The component of the field to plot (0 for x, 1 for y, 2 for z). Default is 2.\n        quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n        colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n    Returns:\n        tuple: A tuple containing the electric field figure and the magnetic field figure.\n    \"\"\"\n    target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, freq_tolerance = frequency_tolerance, k_point_max_distance = k_point_max_distance)\n    print(len(target_modes))\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        eps = md.convert(self.ms.get_epsilon()) \n\n    z_points = eps.shape[2] // periods\n    z_mid = eps.shape[2] // 2\n\n    # Now take only epsilon in the center of the slab\n    eps = eps[..., z_mid]\n    # Calculate the midpoint between min and max of the permittivity (eps)\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n    dropdown_buttons_e = []\n    dropdown_buttons_h = []\n\n    num_plots = len(target_modes)\n\n    for i, mode in enumerate(target_modes):\n        # Initialize visibility status: False for all traces\n        visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n        visible_status_h = [False] * (2 * num_plots)\n\n        visible_status_e[2 * i] = True  # Set the contour plot visible\n        visible_status_h[2 * i] = True\n        visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n        visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n        k_point = mode[\"k_point\"]\n        freq    = mode[\"freq\"]\n        polarization = mode[\"polarization\"]\n\n        # Take the specified component of the fields in the center of the slab\n\n        e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n        h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n        e_field = e_field[..., z_points // 2, component]\n        h_field = h_field[..., z_points // 2, component]\n        with suppress_output():\n            e_field = md.convert(e_field) \n            h_field = md.convert(h_field)\n\n        if quantity == \"real\":\n            e_field = np.real(e_field)\n            h_field = np.real(h_field)\n        elif quantity == \"imag\":\n            e_field = np.imag(e_field)\n            h_field = np.imag(h_field)\n        elif quantity == \"abs\":\n            e_field = np.abs(e_field)\n            h_field = np.abs(h_field)\n        else:\n            raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n        # Add the contour plot for permittivity (eps) at the midpoint\n        contour_e = go.Contour(z=eps.T,\n                            contours=dict(\n                                start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                end=midpoint,\n                                size=0.1,  # A small size to keep it as a single contour\n                                coloring='none'  # No filling\n                            ),\n                            line=dict(color='black', width=2),\n                            showscale=False,\n                            opacity=0.7,\n                            visible=True if i ==  0  else False)  # Only the first mode is visible\n        contour_h = contour_e  # Same contour for H-field figure\n\n        # Add the contour trace\n        fig_e.add_trace(contour_e)\n        fig_h.add_trace(contour_h)\n\n        # Add the heatmap for the electric field\n        heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n        # Add the heatmap for the magnetic field\n        heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n\n        # Add the heatmap trace\n        fig_e.add_trace(heatmap_e)\n        fig_h.add_trace(heatmap_h)\n\n\n\n        data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n        if component == 0: \n            component_str = \"x-component\"\n        elif component == 1:\n            component_str = \"y-component\"\n        else:\n            component_str = \"z-component\"\n        subtitle_e = f\"E-field, {component_str}, {quantity}\"\n        subtitle_h = f\"H-field, {component_str}, {quantity}\"\n        # Create a button for each field dataset for the dropdown\n        dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                    ]))\n        dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                    ]))\n\n    print(len(target_modes))\n    k_point = target_modes[0][\"k_point\"]\n    freq    = target_modes[0][\"freq\"]\n    data_str = f\"Mode {0} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n    fig_e.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_e,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n\n    )\n\n    fig_h.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_h,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n    )\n\n    return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.plot_field_components","title":"<code>plot_field_components(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the target mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the target mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the target mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>quantity</code> <code>str</code> <p>The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale to use for the plot. Default is 'RdBu'.</p> <code>'RdBu'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the electric field figure and the magnetic field figure.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field_components(self,\n                        target_polarization,\n                        target_k_point,\n                        target_frequency,\n                        frequency_tolerance=0.01,\n                        k_point_max_distance=None,\n                        periods: int = 1,\n                        quantity: str = \"real\",\n                        colorscale: str = 'RdBu',\n                        )-&gt; tuple:\n    \"\"\"\n    Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n\n    Args:\n        target_polarization (str): The polarization of the target mode.\n        target_k_point (tuple): The k-point of the target mode.\n        target_frequency (float): The frequency of the target mode.\n        frequency_tolerance (float): The tolerance for frequency similarity.\n        periods (int): The number of periods to extract. Default is 1.\n        quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n        colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n    Returns:\n        tuple: A tuple containing the electric field figure and the magnetic field figure.\n    \"\"\"\n\n    target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                    freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n    print(f\"Number of target modes found: {len(target_modes)}\")\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        eps = md.convert(self.ms.get_epsilon())\n\n    z_points = eps.shape[2] // periods\n    z_mid = eps.shape[2] // 2\n\n    # Now take only epsilon in the center of the slab\n    eps = eps[..., z_mid]\n    # Calculate the midpoint between min and max of the permittivity (eps)\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n    fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n    fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n    dropdown_buttons_e = []\n    dropdown_buttons_h = []\n\n    # For each mode, calculate separate min and max values for Ex, Ey, Ez (and similarly Hx, Hy, Hz)\n    for i, mode in enumerate(target_modes):\n        # Get field arrays for this mode\n        e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n        h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n        # Extract field components in the center of the slab\n        e_field_x = e_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n        e_field_y = e_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n        e_field_z = e_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n        h_field_x = h_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n        h_field_y = h_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n        h_field_z = h_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n\n        with suppress_output():\n            e_field_x = md.convert(e_field_x)\n            e_field_y = md.convert(e_field_y)\n            e_field_z = md.convert(e_field_z)\n            h_field_x = md.convert(h_field_x)\n            h_field_y = md.convert(h_field_y)\n            h_field_z = md.convert(h_field_z)\n\n        e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n        h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)                                    \n\n        # Select quantity to display (real, imag, abs)\n        if quantity == \"real\":\n            e_field = np.real(e_field)\n            h_field = np.real(h_field)\n        elif quantity == \"imag\":\n            e_field = np.imag(e_field)\n            h_field = np.imag(h_field)\n        elif quantity == \"abs\":\n            e_field = np.abs(e_field)\n            h_field = np.abs(h_field)\n        else:\n            raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n        # Calculate the component-specific min/max for E and H fields of this mode\n        e_min = np.min(e_field)\n        e_max = np.max(e_field)\n        h_min = np.min(h_field)\n        h_max = np.max(h_field)\n\n        # Components of the E and H fields\n        Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n        Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n        # Define visibility settings per mode, including contours as always visible\n        visible_status_e = [False] * (len(target_modes) * 6)  # 3 components per mode, with contour for each\n        visible_status_h = [False] * (len(target_modes) * 6)\n        # Make the contour visible by default\n\n\n\n\n        # Make this mode's components and the corresponding contour visible in the initial layout \n        for j in range(6):\n            visible_status_e[6*i + j] = True\n            visible_status_h[6*i + j] = True\n\n\n        # Add contour traces for permittivity to each subplot of fig_e and fig_h for this mode\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n        # Add Ex, Ey, Ez with shared colorbar limits for the E field of this mode\n        fig_e.add_trace(go.Heatmap(z=Ex.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n        fig_e.add_trace(go.Heatmap(z=Ey.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n        fig_e.add_trace(go.Heatmap(z=Ez.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"E-field\", len=0.75, thickness=15), zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n        # Add Hx, Hy, Hz with shared colorbar limits for the H field of this mode\n        fig_h.add_trace(go.Heatmap(z=Hx.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n        fig_h.add_trace(go.Heatmap(z=Hy.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n        fig_h.add_trace(go.Heatmap(z=Hz.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"H-field\", len=0.75, thickness=15), zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n\n\n        # Dropdown data for E-field\n        k_point = mode[\"k_point\"]\n        freq = mode[\"freq\"]\n        polarization = mode[\"polarization\"]\n        mode_description = f\"Mode {i + 1}&lt;br&gt;k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n        dropdown_buttons_e.append(\n            dict(label=f\"Mode {i + 1}\",\n                method='update',\n                args=[{'visible': visible_status_e},\n                    {'title': f\"{mode_description}: {quantity} of E-field components\"}]))\n\n        dropdown_buttons_h.append(\n            dict(label=f\"Mode {i + 1}\",\n                method='update',\n                args=[{'visible': visible_status_h},\n                    {'title': f\"{mode_description}: {quantity} of H-field components\"}]))\n\n    # Layout and color settings\n    fig_e.update_layout(\n        title=f\"{mode_description}: {quantity} of E-field components\",\n        updatemenus=[dict(\n            active=len(target_modes) - 1,\n            buttons=dropdown_buttons_e)],\n        coloraxis=dict(colorbar=dict(len=0.75)),\n        width=1200, height=400,\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        hovermode=\"closest\"\n    )\n\n    fig_h.update_layout(\n        title=f\"{mode_description}: {quantity} of H-field components\",\n        updatemenus=[dict(\n            active=len(target_modes) - 1,\n            buttons=dropdown_buttons_h)],\n        coloraxis=dict(colorbar=dict(len=0.75)),\n        width=1200, height=400,\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        hovermode=\"closest\"\n    )\n\n    # Final adjustments\n    fig_e.update_xaxes(showticklabels=False)\n    fig_e.update_yaxes(showticklabels=False)\n    fig_h.update_xaxes(showticklabels=False)\n    fig_h.update_yaxes(showticklabels=False)\n\n    fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n    fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n    fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n    fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n    fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n    fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n    return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.square_lattice","title":"<code>square_lattice(height_supercell=4)</code>  <code>staticmethod</code>","text":"<p>Define the square lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Lattice, list[Vector3]]</code> <p>A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef square_lattice(height_supercell=4)-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n    \"\"\"\n    Define the square lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0, 1))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # M\n        mp.Vector3(0.5, 0.5),       # X\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.triangular_lattice","title":"<code>triangular_lattice(height_supercell=4)</code>  <code>staticmethod</code>","text":"<p>Define the triangular lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Lattice, list[Vector3]]</code> <p>A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef triangular_lattice(height_supercell=4)-&gt; tuple[mp.Lattice, list[mp.Vector3]]:\n    \"\"\"\n    Define the triangular lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # K\n        mp.Vector3(-1./3, 1./3),    # M\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal","title":"<code>PhotonicCrystal</code>","text":"<p>A class to represent a photonic crystal and perform simulations using MPB (MIT Photonic Bands).</p> <p>Attributes:</p> Name Type Description <code>lattice_type</code> <code>str</code> <p>The type of lattice (e.g., 'square', 'triangular').</p> <code>num_bands</code> <code>int</code> <p>The number of bands to calculate.</p> <code>resolution</code> <code>tuple[int, int] | int</code> <p>The resolution of the simulation.</p> <code>interp</code> <code>int</code> <p>The interpolation factor for k-points.</p> <code>periods</code> <code>int</code> <p>The number of periods for the simulation.</p> <code>k_points</code> <code>list</code> <p>The list of k-points for the simulation.</p> <code>use_XY</code> <code>bool</code> <p>Whether to use X and Y directions for the x-axis in plots.</p> <code>geometry_lattice</code> <code>Lattice</code> <p>The lattice geometry.</p> <code>k_points_interpolated</code> <code>list</code> <p>The interpolated k-points.</p> <code>basic_geometry</code> <code>list</code> <p>The basic geometry of the photonic crystal.</p> <code>ms</code> <code>ModeSolver</code> <p>The mode solver for the simulation.</p> <code>md</code> <code>MPBData</code> <p>The MPB data object.</p> <code>freqs</code> <code>dict</code> <p>The calculated frequencies for different polarizations.</p> <code>gaps</code> <code>dict</code> <p>The calculated band gaps for different polarizations.</p> <code>epsilon</code> <code>ndarray</code> <p>The dielectric constant distribution.</p> <code>modes</code> <code>list</code> <p>The list of calculated modes.</p> <code>has_been_run</code> <code>bool</code> <p>Whether the simulation has been run.</p> <p>Methods:</p> Name Description <code>__getstate__</code> <p>Get the state for pickling.</p> <code>__setstate__</code> <p>Set the state after unpickling.</p> <code>pickle_photonic_crystal</code> <p>Pickle the photonic crystal object.</p> <code>load_photonic_crystal</code> <p>Load a pickled photonic crystal object.</p> <code>set_solver</code> <p>Set the mode solver for the simulation.</p> <code>run_simulation</code> <p>Run the simulation to calculate the frequencies and gaps.</p> <code>run_dumb_simulation</code> <p>Run a dumb simulation to quickly extract some values.</p> <code>convert_mode_fields</code> <p>Convert the mode fields to arrays for visualization.</p> <code>extract_data</code> <p>Extract the data from the simulation.</p> <code>plot_epsilon</code> <p>Plot the epsilon of the photonic crystal interactively using Plotly.</p> <code>plot_bands</code> <p>Plot the bands of the photonic crystal using Plotly.</p> <code>get_XY_k_points_near_gamma</code> <p>Get the relevant k-points near the gamma point for the X and Y directions.</p> <code>get_high_symmetry_points</code> <p>Get the high symmetry points for the photonic crystal lattice.</p> <code>plot_field</code> <p>Plot the field visualization.</p> <code>look_for_mode</code> <p>Look for modes within the specified criteria.</p> <code>find_modes_symmetries</code> <p>Find the symmetries of the modes.</p> <code>plot_modes_vectorial_fields</code> <p>Plot the vectorial fields of the modes.</p> <code>plot_mode_fields_normal_to_k</code> <p>Plot the fields perpendicular to the wavevector k for the mode.</p> <code>plot_vectorial_fields</code> <p>Plot the vectorial fields of the modes.</p> <code>_field_to_cones</code> <p>Convert a field to cones for visualization.</p> <code>_fields_to_cones</code> <p>Convert a list of fields to cones for visualization.</p> <code>_calculate_field_norm_to_k</code> <p>Calculate the components of the field perpendicular to the wavevector k.</p> <code>_get_direction</code> <p>Determine the primary direction of the wavevector k.</p> <code>_calculate_effective_parameter</code> <p>Calculate the effective parameters of the mode.</p> <code>basic_geometry</code> <p>Define the basic geometry of the photonic crystal.</p> <code>basic_lattice</code> <p>Define the basic lattice of the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>class PhotonicCrystal:\n    \"\"\"\n    A class to represent a photonic crystal and perform simulations using MPB (MIT Photonic Bands).\n\n    Attributes:\n        lattice_type (str): The type of lattice (e.g., 'square', 'triangular').\n        num_bands (int): The number of bands to calculate.\n        resolution (tuple[int, int] | int): The resolution of the simulation.\n        interp (int): The interpolation factor for k-points.\n        periods (int): The number of periods for the simulation.\n        k_points (list): The list of k-points for the simulation.\n        use_XY (bool): Whether to use X and Y directions for the x-axis in plots.\n        geometry_lattice (mp.Lattice): The lattice geometry.\n        k_points_interpolated (list): The interpolated k-points.\n        basic_geometry (list): The basic geometry of the photonic crystal.\n        ms (mpb.ModeSolver): The mode solver for the simulation.\n        md (mpb.MPBData): The MPB data object.\n        freqs (dict): The calculated frequencies for different polarizations.\n        gaps (dict): The calculated band gaps for different polarizations.\n        epsilon (np.ndarray): The dielectric constant distribution.\n        modes (list): The list of calculated modes.\n        has_been_run (bool): Whether the simulation has been run.\n\n    Methods:\n        __getstate__(): Get the state for pickling.\n        __setstate__(state): Set the state after unpickling.\n        pickle_photonic_crystal(pickle_id): Pickle the photonic crystal object.\n        load_photonic_crystal(pickle_id): Load a pickled photonic crystal object.\n        set_solver(k_point): Set the mode solver for the simulation.\n        run_simulation(runner, polarization): Run the simulation to calculate the frequencies and gaps.\n        run_dumb_simulation(): Run a dumb simulation to quickly extract some values.\n        convert_mode_fields(mode, periods): Convert the mode fields to arrays for visualization.\n        extract_data(periods): Extract the data from the simulation.\n        plot_epsilon(fig, title): Plot the epsilon of the photonic crystal interactively using Plotly.\n        plot_bands(polarization, title, fig, color): Plot the bands of the photonic crystal using Plotly.\n        get_XY_k_points_near_gamma(distance): Get the relevant k-points near the gamma point for the X and Y directions.\n        get_high_symmetry_points(): Get the high symmetry points for the photonic crystal lattice.\n        plot_field(runner, k_point, frequency, periods, resolution, fig, title, colorscale): Plot the field visualization.\n        look_for_mode(polarization, k_point, freq, freq_tolerance, k_point_max_distance): Look for modes within the specified criteria.\n        find_modes_symmetries(): Find the symmetries of the modes.\n        plot_modes_vectorial_fields(modes, sizemode, names): Plot the vectorial fields of the modes.\n        plot_mode_fields_normal_to_k(mode, k): Plot the fields perpendicular to the wavevector k for the mode.\n        plot_vectorial_fields(fields, colorscales, names): Plot the vectorial fields of the modes.\n        _field_to_cones(field, colorscale, sizemode, sizeref, clim): Convert a field to cones for visualization.\n        _fields_to_cones(fields, colorscale, sizemode, sizeref, clim, colorscales): Convert a list of fields to cones for visualization.\n        _calculate_field_norm_to_k(fields, k): Calculate the components of the field perpendicular to the wavevector k.\n        _get_direction(k_vector): Determine the primary direction of the wavevector k.\n        _calculate_effective_parameter(mode): Calculate the effective parameters of the mode.\n        basic_geometry(): Define the basic geometry of the photonic crystal.\n        basic_lattice(): Define the basic lattice of the photonic crystal.\n    \"\"\"\n    def __init__(self,\n                lattice_type = None,\n                num_bands: int = 6,\n                resolution: tuple[int, int] | int = 32,\n                interp: int = 4,\n                periods: int = 3, \n                pickle_id = None, \n                k_points = None,\n                use_XY  = True\n                ):\n        \"\"\"\n        Initializes the PhotonicCrystal class with the given parameters.\n                Args:\n                    lattice_type (str, optional): Type of the lattice. Defaults to None.\n                    num_bands (int, optional): Number of bands. Defaults to 6.\n                    resolution (tuple[int, int] | int, optional): Resolution of the simulation. Defaults to 32.\n                    interp (int, optional): Interpolation factor for k-points. Defaults to 4.\n                    periods (int, optional): Number of periods. Defaults to 3.\n                    pickle_id (str, optional): Identifier for pickling. Defaults to None.\n                    k_points (list, optional): List of k-points. Defaults to None.\n                    use_XY (bool, optional): Flag to use XY plane. Defaults to True.\n                Attributes:\n                    lattice_type (str): Type of the lattice.\n                    num_bands (int): Number of bands.\n                    resolution (tuple[int, int] | int): Resolution of the simulation.\n                    interp (int): Interpolation factor for k-points.\n                    periods (int): Number of periods.\n                    pickle_id (str): Identifier for pickling.\n                    has_been_run (bool): Flag indicating if the simulation has been run.\n                    geometry_lattice (None): Geometry lattice, set with basic lattice method.\n                    k_points (list): List of k-points.\n                    k_points_interpolated (list): Interpolated k-points.\n                    basic_geometry (None): Basic geometry, set with basic geometry method.\n                    ms (None): Placeholder for ms attribute.\n                    md (None): Placeholder for md attribute.\n                    freqs (dict): Dictionary to store frequencies.\n                    gaps (dict): Dictionary to store gaps.\n                    epsilon (None): Placeholder for epsilon attribute.\n                    modes (list): List to store modes.\n                    use_XY (bool): Flag to use XY plane.\n        \"\"\"\n        self.lattice_type = lattice_type\n        self.num_bands = num_bands\n        self.resolution = resolution\n        self.interp = interp\n        self.periods = periods\n        self.pickle_id = pickle_id\n        self.has_been_run = False #update this manually\n\n        #this values are set with basic lattice method\n        self.geometry_lattice= None \n        self.k_points = k_points\n        if self.k_points is not None:\n            self.k_points_interpolated = mp.interpolate(self.interp, self.k_points)\n\n        #slef.geometry_lattice, self.k_points = self.basic_lattice()\n\n        #this values are set with basic geometry method\n        self.basic_geometry = None\n        #self.geometry = self.basic_geometry()\n\n\n        self.ms = None\n        self.md = None\n\n        self.freqs = {}\n        self.gaps = {}\n        self.epsilon = None\n        self.modes= []\n        self.use_XY = use_XY\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Exclude the non-picklable SWIG objects\n        state['ms'] = None\n        state['md'] = None\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # You may want to reinitialize 'ms' and 'md' if needed after loading.\n        self.ms = None\n        self.md = None\n\n    def pickle_photonic_crystal(self, pickle_id):\n        \"\"\"Pickle the photonic crystal object.\n\n        Args:\n            pickle_id (str): The identifier for the pickle file.\n        \"\"\"\n        with open(f\"{pickle_id}.pkl\", \"wb\") as f:\n            pickle.dump(self, f)\n\n    @staticmethod\n    def load_photonic_crystal(pickle_id) -&gt; 'PhotonicCrystal':\n        \"\"\"Load a pickled photonic crystal object.\n\n        Args:\n            pickle_id (str): The identifier for the pickle file.\n\n        Returns:\n            PhotonicCrystal: The loaded photonic crystal object.\n        \"\"\"\n        with open(f\"{pickle_id}.pkl\", \"rb\") as f:\n            return pickle.load(f)\n\n    def set_solver(self, k_point = None):\n        \"\"\"\n        Set the mode solver for the simulation. \n        For how MPB works, it is better to call this method each time you want to run a simulation.\n        This method initializes the mode solver (ms) with the geometry, geometry lattice, \n        k-points, resolution, and number of bands. If a specific k-point is provided, \n        the solver is set up for that k-point. Otherwise, it uses the interpolated k-points.\n\n        Args:\n            k_point (mp.Vector3, optional): The k-point for the simulation. Default is None.\n\n        \"\"\"\n\n        if k_point is not None:\n            self.ms = mpb.ModeSolver(geometry=self.geometry,\n                                  geometry_lattice=self.geometry_lattice,\n                                  k_points=[k_point],\n                                  resolution=self.resolution,\n                                  num_bands=self.num_bands)\n        else:\n            self.ms = mpb.ModeSolver(geometry=self.geometry,\n                                    geometry_lattice=self.geometry_lattice,\n                                    k_points=self.k_points_interpolated,\n                                    resolution=self.resolution,\n                                    num_bands=self.num_bands)\n\n    def run_simulation(self, runner=\"run_zeven\", polarization=None):\n        \"\"\"\n        Run the simulation to calculate the frequencies and gaps.\n\n        Args:\n            runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n            polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n\n        runner must correspond to an MPB runner. For example: \\n\n        -'run_zeven': Run the simulation for even parity modes in z-axis.\\n\n        -'run_zodd': Run the simulation for odd parity modes in z-axis.\\n\n        -'run_tm': Run the simulation for transverse magnetic modes.\\n\n        -'run_te': Run the simulation for transverse electric modes.\\n\n        -'run': Do not consider symmetry.\n        \"\"\"\n        if self.ms is None:\n            raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n        if polarization is not None:\n            polarization = polarization\n        else:\n            if runner.startswith(\"run_\"):\n                polarization = runner[4:]\n            else:\n                polarization = runner\n\n        # This is a custom mpb output function that stores the fields and frequencies\n        def get_mode_data(ms, band):\n            mode = {\n                \"h_field\": ms.get_hfield(band, bloch_phase=True),\n                \"e_field\": ms.get_efield(band, bloch_phase=True),\n                \"freq\": ms.freqs[band-1],\n                \"k_point\": ms.current_k,\n                \"polarization\": polarization\n            }\n            self.modes.append(mode)\n\n        print(self.k_points_interpolated)\n        with suppress_output():\n            getattr(self.ms, runner)(get_mode_data)\n            self.freqs[polarization] = self.ms.all_freqs\n            self.gaps[polarization] = self.ms.gap_list\n\n\n\n    def run_dumb_simulation(self) -&gt; mpb.ModeSolver:    \n        \"\"\"\n        Run a dumb simulation. \n        This is used to quickly extract some values from the simulation later. \n        \"\"\"\n\n        #run the simulation in the gamma point, find one mode\n        self.ms = mpb.ModeSolver(geometry=self.geometry,\n                                  geometry_lattice=self.geometry_lattice,\n                                  k_points=[mp.Vector3()],\n                                  resolution=self.resolution,\n                                  num_bands=1)\n\n        self.ms.run()\n        ms = self.ms\n        return ms\n\n    def convert_mode_fields(self, mode, periods=1)-&gt; tuple[mpb.MPBArray, mpb.MPBArray]:\n        \"\"\"\n        Convert the mode fields to arrays for visualization.\n        Apparently this is necessary to visualize the fields if crystal is restored from pickle.\n\n        Args:\n        - mode: The mode dictionary.\n        - periods: The number of periods to extract. Default is 1.\n\n        Returns:\n        - e_field_array: The electric field array for visualization.\n        - h_field_array: The magnetic field array for visualization.\n        \"\"\"\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n            e_field =  md.convert(e_field_array)\n            h_field =  md.convert(h_field_array)            \n            return e_field, h_field \n\n\n\n    def extract_data(self, periods: int | None = 5):\n        \"\"\"\n        Extract the data from the simulation.\n\n        Args:\n            periods (int, optional): The number of periods to extract. Default is 5.\n\n        Returns:\n            mpb.MPBData: The MPB data object.\n        \"\"\"\n\n        if self.ms is None:\n            raise ValueError(\"Solver is not set. Call set_solver() before extracting data.\")\n\n        self.md = mpb.MPBData(rectify=True, periods=periods, resolution=self.resolution)\n        return self.md\n\n\n    def plot_epsilon(self, fig=None, title='Epsilon'):\n        \"\"\"\n        Plot the epsilon of the photonic crystal interactively using Plotly.\n        Not implemented in the base class. Must be implemented in the derived class.\n\n        Args:\n            fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n            title (str, optional): The title of the plot. Default is 'Epsilon'.\n\n        Returns:\n            go.Figure: The Plotly figure object.(Not woroking yet, error is thrown)\n        \"\"\"\n        raise NotImplementedError\n\n    def plot_bands(self, polarization=\"te\", title='Bands', fig=None, color='blue')-&gt; go.Figure:\n        \"\"\"\n        Plot the bands of the photonic crystal using Plotly.\n        This method plots the bands for the specified polarization.\n        In Dash and Jupyther Notebook, the plot is interactive and data are shown on hover.        \n\n        Args:\n            polarization (str, optional): The polarization of the bands. Default is 'te'.\n            title (str, optional): The title of the plot. Default is 'Bands'.\n            fig (go.Figure, optional): The Plotly figure to add the bands plot to. Default is None.\n            color (str, optional): The color of the bands. Default is 'blue'.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n        if self.freqs[polarization] is None:\n            print(\"Simulation not run yet. Please run the simulation first.\")\n            return\n        freqs = self.freqs[polarization]\n        gaps = self.gaps[polarization]\n\n        xs = list(range(len(freqs)))\n\n        # Extract the interpolated k-points as vectors and format them for hover and click\n        k_points_interpolated = [kp for kp in self.k_points_interpolated]\n\n        if fig is None:\n            fig = go.Figure()\n\n        # Iterate through each frequency band and add them to the plot\n        for band_index, band in enumerate(zip(*freqs)):\n            # Generate hover text with the corresponding k-point and frequency\n            hover_texts = [\n                f\"k-point: ({kp.x:.4f}, {kp.y:.4f}, {kp.z:.4f})&lt;br&gt;frequency: {f:.4f}\"\n                for kp, f in zip(k_points_interpolated, band)\n            ]\n            # Add the line trace with hover info\n            fig.add_trace(go.Scatter(\n                x=xs, \n                y=band, \n                mode='lines', \n                line=dict(color=color),\n                text=hover_texts,  # Custom hover text\n                hoverinfo='text',  # Display only the custom hover text\n                customdata=[(kp.x, kp.y, kp.z, f) for kp, f in zip(k_points_interpolated, band)],  # Attach k-points and frequency as custom data\n                showlegend=False,  # Hide from legend (we\u2019ll add a separate legend entry)\n                legendgroup=polarization,  # Group traces by polarization for toggling visibility\n                visible=True,  # Initially visible\n                selectedpoints=[],  # Placeholder for selected points\n                selected=dict(marker=dict(color=\"red\", size=10)),  # Change color and size of selected points\n                unselected=dict(marker=dict(opacity=0.3))  # Make unselected points more transparent\n            ))\n\n        # Add bandgap shading (optional, grouped with the polarization for toggling visibility)\n        for gap in gaps:\n            if gap[0] &gt; 1:\n                fig.add_shape(\n                    type=\"rect\",\n                    x0=xs[0], \n                    x1=xs[-1],\n                    y0=gap[1], \n                    y1=gap[2],\n                    fillcolor=color, \n                    opacity=0.2, \n                    line_width=0,\n                    layer=\"below\",\n                    legendgroup=polarization,  # Group shading with the same polarization\n                    visible=True  # Initially visible\n                )\n\n        # Add a single legend entry for toggling visibility\n        fig.add_trace(go.Scatter(\n            x=[None], y=[None],\n            mode='lines',\n            line=dict(color=color),\n            name=f'{polarization.upper()}',  # Legend entry for the polarization\n            legendgroup=polarization,  # Group with the same polarization traces\n            showlegend=True,  # Show the legend entry\n            visible=True,  # Initially visible\n        ))\n\n        # Customize the x-axis \n        if self.use_XY is True:  # Use X and Y directions for the x-axis\n            relevant_k_points = self.get_XY_k_points_near_gamma()\n            fig.update_layout(\n                title=title,\n                xaxis=dict(\n                    tickmode='array',\n                    tickvals=[i * (len(freqs) - 3) / 2 + i for i in range(3)],\n                    ticktext=list(relevant_k_points.keys())  # Only three values, no repetition\n                ),\n                yaxis_title='frequency (c/a)',\n                showlegend=True,\n                dragmode='select',  # Enables rectangular selection\n                clickmode='event+select',  # Enable click events and selection events\n                legend=dict(  # This ensures that clicking the legend will toggle visibility\n                    itemclick=\"toggle\",  # Toggle visibility when clicked\n                    itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n                )\n            )\n        else:\n            relevant_k_points = self.get_high_symmetry_points() # Use high symmetry points for the x-axis \n                                                                # Gamma, X, M for square lattice and\n                                                                # Gamma, K, M for triangular lattice                                                   \n            fig.update_layout(\n                title=title,\n                xaxis=dict(\n                    tickmode='array',\n                    tickvals=[i * (len(freqs) - 4) / 3 + i for i in range(4)],\n                    ticktext=list(relevant_k_points.keys()) + [list(relevant_k_points.keys())[0]]  # Repeat the first element at the end\n                ),\n                yaxis_title='frequency (c/a)',\n                showlegend=True,\n                dragmode='select',  # Enables rectangular selection\n                clickmode='event+select',  # Enable click events and selection events\n                legend=dict(  # This ensures that clicking the legend will toggle visibility\n                    itemclick=\"toggle\",  # Toggle visibility when clicked\n                    itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n                )\n            )\n\n        return fig\n\n\n    def get_XY_k_points_near_gamma(self, distance = 0.1) -&gt; dict:\n        \"\"\"\n        Get the relevant k-points near the gamma point for the X and Y directions.\n        This is useful for plotting the bands with the X and Y directions on the x-axis.\n\n        Args:\n            distance (float): The distance from the gamma point. Default is 0.1.\n\n        Returns:\n            dict: A dictionary with the relevant k-points for the X and Y directions.\n            with the k-point names as keys and the k-point vectors as values.\n        \"\"\"\n\n        if distance &gt;= 0.5:\n            raise ValueError(\"Distance must be less than 0.5\")\n        relevant_k_points = {\n            'X': mp.Vector3(0.5, 0),\n            '\u0393': mp.Vector3(0, 0, 0),\n            'Y': mp.Vector3(0,0.5, 0)\n        }\n        return relevant_k_points\n\n    def get_high_symmetry_points(self) -&gt; dict:\n        \"\"\"\n        Get the high symmetry points for the photonic crystal lattice.\n        This is useful for plotting the bands with the high symmetry points on the x-axis.\n\n        Returns:\n            dict: A dictionary with the high symmetry points for the lattice.\n            with the k-point names as keys and the k-point vectors as values.\n        \"\"\"\n\n        k_high_sym = {}\n        if self.lattice_type == 'square':\n            k_high_sym = {\n                '\u0393': mp.Vector3(0, 0, 0),\n                'X': mp.Vector3(0.5, 0, 0),\n                'M': mp.Vector3(0.5, 0.5, 0)\n            }\n        elif self.lattice_type == 'triangular':\n            k_high_sym = {\n                '\u0393': mp.Vector3(0, 0, 0),\n                'K': mp.Vector3(1/3, 1/3, 0),\n                'M': mp.Vector3(0.5, 0, 0)\n            }\n        return k_high_sym\n\n\n    def plot_field(self, runner=\"run_tm\", k_point=mp.Vector3(1 / -3, 1 / 3), frequency=None, periods=5, resolution=32, fig=None, title=\"Field Visualization\", colorscale='RdBu'):\n        raise NotImplementedError\n\n\n    def look_for_mode(self, polarization, k_point, freq,  freq_tolerance=0.01, k_point_max_distance = None):\n        \"\"\"\n        Look for modes within the specified criteria.\n\n        Args:\n            polarization (str): The polarization of the mode.\n            k_point (tuple): The k-point of the mode.\n            freq (float): The frequency of the mode.\n            freq_tolerance (float): The tolerance for frequency similarity.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n\n        Returns:\n            list: A list of mode dictionaries that match the criteria.\n        \"\"\"\n\n        target_modes = []\n        if k_point_max_distance is None:\n            for mode in self.modes:\n                if mode[\"polarization\"] == polarization and mode[\"k_point\"] == k_point and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                    target_modes.append(mode)\n        else:\n            for mode in self.modes:\n                if mode[\"polarization\"] == polarization and np.linalg.norm(np.array(mode[\"k_point\"]) - np.array(k_point)) &lt;= k_point_max_distance and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                    target_modes.append(mode)\n        return target_modes\n\n\n\n    def find_modes_symmetries(self):\n        \"\"\"\n        Find the symmetries of the modes.\n        \"\"\"\n        raise NotImplementedError(\"find_modes_symmetries method not implemented yet.\")\n\n\n\n    def plot_modes_vectorial_fields(self, modes, sizemode=\"scaled\", names=[\"Electric Field\", \"Magnetic Field\"]):\n        \"\"\"\n        Plot the vectorial fields of the modes.\n        Has to be checked, Half working, not tested yet.\n\n        Args:\n        - modes: The list of modes to plot.\n        - sizemode: The sizemode for the cones. Default is 'scaled'.\n        - names: The names of the fields. Default is ['Electric Field', 'Magnetic Field'].\n\n        Returns:\n        - fig_e: The Plotly figure for the electric field.\n        - fig_h: The Plotly figure for the magnetic field.\n\n        \"\"\"\n\n        colorscales = [\"blues\", \"reds\", \"greens\", \"purples\", \"oranges\", \"ylorbr\"]\n\n        h_fields = [mode[\"h_field\"] for mode in modes]\n        e_fields = [mode[\"e_field\"] for mode in modes]\n\n        max_norm_h = PhotonicCrystal._calculate_fields_max_norms(h_fields)\n        max_norm_e = PhotonicCrystal._calculate_fields_max_norms(e_fields)\n\n        e_sizeref = max_norm_e\n        h_sizeref = max_norm_h\n\n        e_clim = (0, max_norm_e)\n        h_clim= (0, max_norm_h)\n\n\n        e_fig = go.Figure()\n        h_fig = go.Figure()\n\n        e_cones = PhotonicCrystal._fields_to_cones(e_fields, colorscale=colorscales[0], sizemode=sizemode, sizeref=e_sizeref, clim=e_clim, colorscales=colorscales)\n        h_cones = PhotonicCrystal._fields_to_cones(h_fields, colorscale=colorscales[1], sizemode=sizemode, sizeref=h_sizeref, clim=h_clim, colorscales=colorscales) \n\n\n        for e_cone in e_cones:  \n            e_fig.add_trace(e_cone)\n        for h_cone in h_cones:\n            h_fig.add_trace(h_cone)\n\n\n        e_fig.update_layout(\n            title=names[0],\n            scene=dict(\n            xaxis=dict(title='X'),\n            yaxis=dict(title='Y'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n\n        h_fig.update_layout(\n            title=names[1],\n            scene=dict(\n            xaxis=dict(title='X'),\n            yaxis=dict(title='Y'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n\n        return e_fig, h_fig\n\n\n\n\n\n    def plot_mode_fields_normal_to_k(self, mode, k):\n        \"\"\"\n        Plot the fields perpendicular to the wavevector k for the mode.\n        To be tested, not sure if works correctly.\n\n        Args:\n        - mode: The mode dictionary.\n        - k: The wavevector [kx, ky, kz].\n\n        Returns:\n        - fig_e: The Plotly figure for the electric field.\n        - fig_h: The Plotly figure for the magnetic field.\n        \"\"\"\n        fields = [mode[\"e_field\"], mode[\"h_field\"]]\n        fields_norm_to_k = self._calculate_field_norm_to_k(fields, k)\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n\n\n        fig_e.add_trace(self._field_to_cones(fields_norm_to_k[0], colorscale=\"blues\"))\n        fig_h.add_trace(self._field_to_cones(fields_norm_to_k[1], colorscale=\"reds\"))\n        return fig_e, fig_h \n\n    def plot_vectorial_fields(self, fields, colorscales=[\"Viridis\",\"Viridis\"], names=[\"Field 1\", \"Field 2\"]): \n        \"\"\"\n        Plot the vectorial fields of the modes.\n        Not sure if it is working properly. To be tested.\n\n        Args:\n        - fields: The list of fields to plot.\n        - colorscales: The colorscales for the cones. Default is [\"Viridis\", \"Viridis\"].\n        - names: The names of the fields. Default is [\"Field 1\", \"Field 2\"].\n\n        Returns:\n        - fig_e: The Plotly figure for the electric field.\n        - fig_h: The Plotly figure for the magnetic field.\n        \"\"\"\n\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n        fig_e.add_trace(self._field_to_cones(fields[0], colorscale=colorscales[0]))\n        fig_h.add_trace(self._field_to_cones(fields[1], colorscale=colorscales[1]))\n        fig_e.update_layout(\n            title=names[0],\n            scene=dict(\n            xaxis=dict(title='Y'),\n            yaxis=dict(title='X'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n\n        fig_h.update_layout(\n            title=names[1],\n            scene=dict(\n            xaxis=dict(title='Y'),\n            yaxis=dict(title='X'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n        return fig_e, fig_h\n\n\n\n\n    @staticmethod\n    def _field_to_cones(field, colorscale=\"Viridis\", sizemode='absolute', sizeref=1, clim=(0, 1))-&gt; go.Cone:\n        \"\"\"\n        Convert a field to cones for visualization.\n        Auxiliar method for plotting the fields.  \n\n        Args:\n        - field: The field to convert.\n        - colorscale: The colorscale for the cones. Default is 'Viridis'.\n        - sizemode: The sizemode for the cones. Default is 'absolute'.\n        - sizeref: The sizeref for the cones. Default is 1.\n        - clim: The color limits for the cones. Default is (0, 1). (Not used now)\n\n        \"\"\"\n        field_x = np.real(field[..., 0])\n        field_y = np.real(field[..., 1])\n        field_z = np.real(field[..., 2])\n\n        x, y, z = np.meshgrid(np.arange(field.shape[0]), np.arange(field.shape[1]), np.arange(field.shape[2]))\n\n\n        cone = go.Cone(\n            x=x.flatten(),\n            y=y.flatten(),\n            z=z.flatten(),\n            u=field_x.flatten(),\n            v=field_y.flatten(),\n            w=field_z.flatten(),\n            anchor='tail',\n            sizemode=sizemode,\n            sizeref=sizeref,\n            colorscale=colorscale,\n            #cmin = clim[0],\n            #cmax = clim[1],\n        )\n        return cone\n\n\n    @staticmethod\n    def _fields_to_cones(fields, colorscale=\"Viridis\", sizemode='absolute', sizeref=1, clim=(0, 1), colorscales=None)-&gt; list:\n        \"\"\"\n        Convert a list of fields to cones for visualization.\n        Auxiliar method for plotting the fields.\n\n        Args:\n        - fields: The list of fields to convert.\n        - colorscale: The colorscale for the cones. Default is 'Viridis'.\n        - sizemode: The sizemode for the cones. Default is 'absolute'.\n        - sizeref: The sizeref for the cones. Default is 1.\n        - clim: The color limits for the cones. Default is (0, 1).\n        - colorscales: The colorscales for the cones. Default is None.\n\n        Returns:\n        - cones: The list of cones for the fields.\n        \"\"\"\n\n\n        cones = []\n\n        if colorscales is None:\n            colorscales = [\"blues\", \"reds\", \"greens\", \"purples\", \"oranges\", \"ylorbr\"]\n\n        for i, field in enumerate( fields):\n            cone = PhotonicCrystal._field_to_cones(field, colorscale=colorscales[i], sizemode=sizemode, sizeref=sizeref, clim=clim)\n            cones.append(cone)\n        return cones\n\n\n    @staticmethod\n    def _calculate_field_norm_to_k(fields, k):\n        \"\"\"\n        Calculate the components of the field perpendicular to the wavevector k for each field in the list.\n\n        Args:\n        - fields: A list of numpy arrays, each of shape (Nx, Ny, Nz, 3), where the last dimension contains the x, y, z components of the field.\n        - k: A numpy array of shape (3,), representing the wavevector [kx, ky, kz].\n\n        Returns:\n        - fields_norm_to_k: A list of numpy arrays, each of shape (Nx, Ny, Nz, 3), representing the field perpendicular to k for each input field.\n        \"\"\"\n        fields_norm_to_k = []\n\n        for field in fields:\n            # Normalize the wavevector k\n            k_norm = k / np.linalg.norm(k)\n\n            # Compute the dot product of each field vector with the normalized k\n            dot_product = np.einsum('ijkl,l-&gt;ijk', field, k_norm)  # Efficiently computes the dot product\n\n            # Compute the parallel component of the field: (dot_product * k_norm)\n            field_parallel = np.outer(dot_product, k_norm).reshape(field.shape)\n\n            # Subtract the parallel component to get the perpendicular component\n            field_norm_to_k = field - field_parallel\n\n            fields_norm_to_k.append(field_norm_to_k)\n\n        return fields_norm_to_k\n\n\n\n\n\n    @staticmethod\n    def _get_direction(k_vector):\n        \"\"\"\n        Determine the primary direction of the wavevector k.\n\n        Args:\n        - k_vector: A numpy array or list of shape (3,), representing the wavevector [kx, ky, kz].\n\n        Returns:\n        - int: 0 for x-direction, 1 for y-direction, 2 for z-direction.\n        \"\"\"\n        if k_vector[0] != 0 and k_vector[1] == 0 and k_vector[2] == 0:\n            return 0  # x-direction\n        elif k_vector[0] == 0 and k_vector[1] != 0 and k_vector[2] == 0:\n            return 1  # y-direction\n        elif k_vector[0] == 0 and k_vector[1] == 0 and k_vector[2] != 0:\n            return 2  # z-direction\n        else:\n            raise ValueError(\"The wavevector k does not align with a primary axis.\")\n\n\n\n\n    @staticmethod\n    def _calculate_effective_parameter(mode):\n        \"\"\"\n        Calculate the effective parameters of the mode.\n\n        Args:\n        - mode: The mode dictionary.\n\n        Returns:\n        - dict: A dictionary with the effective parameters of the mode.\n        \"\"\"\n        raise NotImplementedError(\"calculate_effective_parameter method not implemented yet.\")  \n\n\n\n    @staticmethod\n    def basic_geometry():\n        \"\"\" \n        Define the basic geometry of the photonic crystal.\n        Must be implemented in the derived class.\n        \"\"\"\n\n        raise NotImplementedError\n\n    @staticmethod\n    def basic_lattice():\n        \"\"\"\n        Define the basic lattice of the photonic crystal.\n        Must be implemented in the derived class.\n        \"\"\"\n\n        raise NotImplementedError\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.__init__","title":"<code>__init__(lattice_type=None, num_bands=6, resolution=32, interp=4, periods=3, pickle_id=None, k_points=None, use_XY=True)</code>","text":"<p>Initializes the PhotonicCrystal class with the given parameters.         Args:             lattice_type (str, optional): Type of the lattice. Defaults to None.             num_bands (int, optional): Number of bands. Defaults to 6.             resolution (tuple[int, int] | int, optional): Resolution of the simulation. Defaults to 32.             interp (int, optional): Interpolation factor for k-points. Defaults to 4.             periods (int, optional): Number of periods. Defaults to 3.             pickle_id (str, optional): Identifier for pickling. Defaults to None.             k_points (list, optional): List of k-points. Defaults to None.             use_XY (bool, optional): Flag to use XY plane. Defaults to True.         Attributes:             lattice_type (str): Type of the lattice.             num_bands (int): Number of bands.             resolution (tuple[int, int] | int): Resolution of the simulation.             interp (int): Interpolation factor for k-points.             periods (int): Number of periods.             pickle_id (str): Identifier for pickling.             has_been_run (bool): Flag indicating if the simulation has been run.             geometry_lattice (None): Geometry lattice, set with basic lattice method.             k_points (list): List of k-points.             k_points_interpolated (list): Interpolated k-points.             basic_geometry (None): Basic geometry, set with basic geometry method.             ms (None): Placeholder for ms attribute.             md (None): Placeholder for md attribute.             freqs (dict): Dictionary to store frequencies.             gaps (dict): Dictionary to store gaps.             epsilon (None): Placeholder for epsilon attribute.             modes (list): List to store modes.             use_XY (bool): Flag to use XY plane.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def __init__(self,\n            lattice_type = None,\n            num_bands: int = 6,\n            resolution: tuple[int, int] | int = 32,\n            interp: int = 4,\n            periods: int = 3, \n            pickle_id = None, \n            k_points = None,\n            use_XY  = True\n            ):\n    \"\"\"\n    Initializes the PhotonicCrystal class with the given parameters.\n            Args:\n                lattice_type (str, optional): Type of the lattice. Defaults to None.\n                num_bands (int, optional): Number of bands. Defaults to 6.\n                resolution (tuple[int, int] | int, optional): Resolution of the simulation. Defaults to 32.\n                interp (int, optional): Interpolation factor for k-points. Defaults to 4.\n                periods (int, optional): Number of periods. Defaults to 3.\n                pickle_id (str, optional): Identifier for pickling. Defaults to None.\n                k_points (list, optional): List of k-points. Defaults to None.\n                use_XY (bool, optional): Flag to use XY plane. Defaults to True.\n            Attributes:\n                lattice_type (str): Type of the lattice.\n                num_bands (int): Number of bands.\n                resolution (tuple[int, int] | int): Resolution of the simulation.\n                interp (int): Interpolation factor for k-points.\n                periods (int): Number of periods.\n                pickle_id (str): Identifier for pickling.\n                has_been_run (bool): Flag indicating if the simulation has been run.\n                geometry_lattice (None): Geometry lattice, set with basic lattice method.\n                k_points (list): List of k-points.\n                k_points_interpolated (list): Interpolated k-points.\n                basic_geometry (None): Basic geometry, set with basic geometry method.\n                ms (None): Placeholder for ms attribute.\n                md (None): Placeholder for md attribute.\n                freqs (dict): Dictionary to store frequencies.\n                gaps (dict): Dictionary to store gaps.\n                epsilon (None): Placeholder for epsilon attribute.\n                modes (list): List to store modes.\n                use_XY (bool): Flag to use XY plane.\n    \"\"\"\n    self.lattice_type = lattice_type\n    self.num_bands = num_bands\n    self.resolution = resolution\n    self.interp = interp\n    self.periods = periods\n    self.pickle_id = pickle_id\n    self.has_been_run = False #update this manually\n\n    #this values are set with basic lattice method\n    self.geometry_lattice= None \n    self.k_points = k_points\n    if self.k_points is not None:\n        self.k_points_interpolated = mp.interpolate(self.interp, self.k_points)\n\n    #slef.geometry_lattice, self.k_points = self.basic_lattice()\n\n    #this values are set with basic geometry method\n    self.basic_geometry = None\n    #self.geometry = self.basic_geometry()\n\n\n    self.ms = None\n    self.md = None\n\n    self.freqs = {}\n    self.gaps = {}\n    self.epsilon = None\n    self.modes= []\n    self.use_XY = use_XY\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.basic_geometry","title":"<code>basic_geometry()</code>  <code>staticmethod</code>","text":"<p>Define the basic geometry of the photonic crystal. Must be implemented in the derived class.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_geometry():\n    \"\"\" \n    Define the basic geometry of the photonic crystal.\n    Must be implemented in the derived class.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.basic_lattice","title":"<code>basic_lattice()</code>  <code>staticmethod</code>","text":"<p>Define the basic lattice of the photonic crystal. Must be implemented in the derived class.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_lattice():\n    \"\"\"\n    Define the basic lattice of the photonic crystal.\n    Must be implemented in the derived class.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.convert_mode_fields","title":"<code>convert_mode_fields(mode, periods=1)</code>","text":"<p>Convert the mode fields to arrays for visualization. Apparently this is necessary to visualize the fields if crystal is restored from pickle.</p> <p>Args: - mode: The mode dictionary. - periods: The number of periods to extract. Default is 1.</p> <p>Returns: - e_field_array: The electric field array for visualization. - h_field_array: The magnetic field array for visualization.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def convert_mode_fields(self, mode, periods=1)-&gt; tuple[mpb.MPBArray, mpb.MPBArray]:\n    \"\"\"\n    Convert the mode fields to arrays for visualization.\n    Apparently this is necessary to visualize the fields if crystal is restored from pickle.\n\n    Args:\n    - mode: The mode dictionary.\n    - periods: The number of periods to extract. Default is 1.\n\n    Returns:\n    - e_field_array: The electric field array for visualization.\n    - h_field_array: The magnetic field array for visualization.\n    \"\"\"\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n        h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n        e_field =  md.convert(e_field_array)\n        h_field =  md.convert(h_field_array)            \n        return e_field, h_field \n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.extract_data","title":"<code>extract_data(periods=5)</code>","text":"<p>Extract the data from the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 5.</p> <code>5</code> <p>Returns:</p> Type Description <p>mpb.MPBData: The MPB data object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def extract_data(self, periods: int | None = 5):\n    \"\"\"\n    Extract the data from the simulation.\n\n    Args:\n        periods (int, optional): The number of periods to extract. Default is 5.\n\n    Returns:\n        mpb.MPBData: The MPB data object.\n    \"\"\"\n\n    if self.ms is None:\n        raise ValueError(\"Solver is not set. Call set_solver() before extracting data.\")\n\n    self.md = mpb.MPBData(rectify=True, periods=periods, resolution=self.resolution)\n    return self.md\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.find_modes_symmetries","title":"<code>find_modes_symmetries()</code>","text":"<p>Find the symmetries of the modes.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def find_modes_symmetries(self):\n    \"\"\"\n    Find the symmetries of the modes.\n    \"\"\"\n    raise NotImplementedError(\"find_modes_symmetries method not implemented yet.\")\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.get_XY_k_points_near_gamma","title":"<code>get_XY_k_points_near_gamma(distance=0.1)</code>","text":"<p>Get the relevant k-points near the gamma point for the X and Y directions. This is useful for plotting the bands with the X and Y directions on the x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance from the gamma point. Default is 0.1.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary with the relevant k-points for the X and Y directions.</p> <code>dict</code> <p>with the k-point names as keys and the k-point vectors as values.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def get_XY_k_points_near_gamma(self, distance = 0.1) -&gt; dict:\n    \"\"\"\n    Get the relevant k-points near the gamma point for the X and Y directions.\n    This is useful for plotting the bands with the X and Y directions on the x-axis.\n\n    Args:\n        distance (float): The distance from the gamma point. Default is 0.1.\n\n    Returns:\n        dict: A dictionary with the relevant k-points for the X and Y directions.\n        with the k-point names as keys and the k-point vectors as values.\n    \"\"\"\n\n    if distance &gt;= 0.5:\n        raise ValueError(\"Distance must be less than 0.5\")\n    relevant_k_points = {\n        'X': mp.Vector3(0.5, 0),\n        '\u0393': mp.Vector3(0, 0, 0),\n        'Y': mp.Vector3(0,0.5, 0)\n    }\n    return relevant_k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.get_high_symmetry_points","title":"<code>get_high_symmetry_points()</code>","text":"<p>Get the high symmetry points for the photonic crystal lattice. This is useful for plotting the bands with the high symmetry points on the x-axis.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary with the high symmetry points for the lattice.</p> <code>dict</code> <p>with the k-point names as keys and the k-point vectors as values.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def get_high_symmetry_points(self) -&gt; dict:\n    \"\"\"\n    Get the high symmetry points for the photonic crystal lattice.\n    This is useful for plotting the bands with the high symmetry points on the x-axis.\n\n    Returns:\n        dict: A dictionary with the high symmetry points for the lattice.\n        with the k-point names as keys and the k-point vectors as values.\n    \"\"\"\n\n    k_high_sym = {}\n    if self.lattice_type == 'square':\n        k_high_sym = {\n            '\u0393': mp.Vector3(0, 0, 0),\n            'X': mp.Vector3(0.5, 0, 0),\n            'M': mp.Vector3(0.5, 0.5, 0)\n        }\n    elif self.lattice_type == 'triangular':\n        k_high_sym = {\n            '\u0393': mp.Vector3(0, 0, 0),\n            'K': mp.Vector3(1/3, 1/3, 0),\n            'M': mp.Vector3(0.5, 0, 0)\n        }\n    return k_high_sym\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.load_photonic_crystal","title":"<code>load_photonic_crystal(pickle_id)</code>  <code>staticmethod</code>","text":"<p>Load a pickled photonic crystal object.</p> <p>Parameters:</p> Name Type Description Default <code>pickle_id</code> <code>str</code> <p>The identifier for the pickle file.</p> required <p>Returns:</p> Name Type Description <code>PhotonicCrystal</code> <code>PhotonicCrystal</code> <p>The loaded photonic crystal object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef load_photonic_crystal(pickle_id) -&gt; 'PhotonicCrystal':\n    \"\"\"Load a pickled photonic crystal object.\n\n    Args:\n        pickle_id (str): The identifier for the pickle file.\n\n    Returns:\n        PhotonicCrystal: The loaded photonic crystal object.\n    \"\"\"\n    with open(f\"{pickle_id}.pkl\", \"rb\") as f:\n        return pickle.load(f)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.look_for_mode","title":"<code>look_for_mode(polarization, k_point, freq, freq_tolerance=0.01, k_point_max_distance=None)</code>","text":"<p>Look for modes within the specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>str</code> <p>The polarization of the mode.</p> required <code>k_point</code> <code>tuple</code> <p>The k-point of the mode.</p> required <code>freq</code> <code>float</code> <p>The frequency of the mode.</p> required <code>freq_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of mode dictionaries that match the criteria.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def look_for_mode(self, polarization, k_point, freq,  freq_tolerance=0.01, k_point_max_distance = None):\n    \"\"\"\n    Look for modes within the specified criteria.\n\n    Args:\n        polarization (str): The polarization of the mode.\n        k_point (tuple): The k-point of the mode.\n        freq (float): The frequency of the mode.\n        freq_tolerance (float): The tolerance for frequency similarity.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n\n    Returns:\n        list: A list of mode dictionaries that match the criteria.\n    \"\"\"\n\n    target_modes = []\n    if k_point_max_distance is None:\n        for mode in self.modes:\n            if mode[\"polarization\"] == polarization and mode[\"k_point\"] == k_point and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                target_modes.append(mode)\n    else:\n        for mode in self.modes:\n            if mode[\"polarization\"] == polarization and np.linalg.norm(np.array(mode[\"k_point\"]) - np.array(k_point)) &lt;= k_point_max_distance and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                target_modes.append(mode)\n    return target_modes\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.pickle_photonic_crystal","title":"<code>pickle_photonic_crystal(pickle_id)</code>","text":"<p>Pickle the photonic crystal object.</p> <p>Parameters:</p> Name Type Description Default <code>pickle_id</code> <code>str</code> <p>The identifier for the pickle file.</p> required Source code in <code>src/photonic_crystal.py</code> <pre><code>def pickle_photonic_crystal(self, pickle_id):\n    \"\"\"Pickle the photonic crystal object.\n\n    Args:\n        pickle_id (str): The identifier for the pickle file.\n    \"\"\"\n    with open(f\"{pickle_id}.pkl\", \"wb\") as f:\n        pickle.dump(self, f)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_bands","title":"<code>plot_bands(polarization='te', title='Bands', fig=None, color='blue')</code>","text":"<p>Plot the bands of the photonic crystal using Plotly. This method plots the bands for the specified polarization. In Dash and Jupyther Notebook, the plot is interactive and data are shown on hover.        </p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>str</code> <p>The polarization of the bands. Default is 'te'.</p> <code>'te'</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Bands'.</p> <code>'Bands'</code> <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the bands plot to. Default is None.</p> <code>None</code> <code>color</code> <code>str</code> <p>The color of the bands. Default is 'blue'.</p> <code>'blue'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_bands(self, polarization=\"te\", title='Bands', fig=None, color='blue')-&gt; go.Figure:\n    \"\"\"\n    Plot the bands of the photonic crystal using Plotly.\n    This method plots the bands for the specified polarization.\n    In Dash and Jupyther Notebook, the plot is interactive and data are shown on hover.        \n\n    Args:\n        polarization (str, optional): The polarization of the bands. Default is 'te'.\n        title (str, optional): The title of the plot. Default is 'Bands'.\n        fig (go.Figure, optional): The Plotly figure to add the bands plot to. Default is None.\n        color (str, optional): The color of the bands. Default is 'blue'.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n    if self.freqs[polarization] is None:\n        print(\"Simulation not run yet. Please run the simulation first.\")\n        return\n    freqs = self.freqs[polarization]\n    gaps = self.gaps[polarization]\n\n    xs = list(range(len(freqs)))\n\n    # Extract the interpolated k-points as vectors and format them for hover and click\n    k_points_interpolated = [kp for kp in self.k_points_interpolated]\n\n    if fig is None:\n        fig = go.Figure()\n\n    # Iterate through each frequency band and add them to the plot\n    for band_index, band in enumerate(zip(*freqs)):\n        # Generate hover text with the corresponding k-point and frequency\n        hover_texts = [\n            f\"k-point: ({kp.x:.4f}, {kp.y:.4f}, {kp.z:.4f})&lt;br&gt;frequency: {f:.4f}\"\n            for kp, f in zip(k_points_interpolated, band)\n        ]\n        # Add the line trace with hover info\n        fig.add_trace(go.Scatter(\n            x=xs, \n            y=band, \n            mode='lines', \n            line=dict(color=color),\n            text=hover_texts,  # Custom hover text\n            hoverinfo='text',  # Display only the custom hover text\n            customdata=[(kp.x, kp.y, kp.z, f) for kp, f in zip(k_points_interpolated, band)],  # Attach k-points and frequency as custom data\n            showlegend=False,  # Hide from legend (we\u2019ll add a separate legend entry)\n            legendgroup=polarization,  # Group traces by polarization for toggling visibility\n            visible=True,  # Initially visible\n            selectedpoints=[],  # Placeholder for selected points\n            selected=dict(marker=dict(color=\"red\", size=10)),  # Change color and size of selected points\n            unselected=dict(marker=dict(opacity=0.3))  # Make unselected points more transparent\n        ))\n\n    # Add bandgap shading (optional, grouped with the polarization for toggling visibility)\n    for gap in gaps:\n        if gap[0] &gt; 1:\n            fig.add_shape(\n                type=\"rect\",\n                x0=xs[0], \n                x1=xs[-1],\n                y0=gap[1], \n                y1=gap[2],\n                fillcolor=color, \n                opacity=0.2, \n                line_width=0,\n                layer=\"below\",\n                legendgroup=polarization,  # Group shading with the same polarization\n                visible=True  # Initially visible\n            )\n\n    # Add a single legend entry for toggling visibility\n    fig.add_trace(go.Scatter(\n        x=[None], y=[None],\n        mode='lines',\n        line=dict(color=color),\n        name=f'{polarization.upper()}',  # Legend entry for the polarization\n        legendgroup=polarization,  # Group with the same polarization traces\n        showlegend=True,  # Show the legend entry\n        visible=True,  # Initially visible\n    ))\n\n    # Customize the x-axis \n    if self.use_XY is True:  # Use X and Y directions for the x-axis\n        relevant_k_points = self.get_XY_k_points_near_gamma()\n        fig.update_layout(\n            title=title,\n            xaxis=dict(\n                tickmode='array',\n                tickvals=[i * (len(freqs) - 3) / 2 + i for i in range(3)],\n                ticktext=list(relevant_k_points.keys())  # Only three values, no repetition\n            ),\n            yaxis_title='frequency (c/a)',\n            showlegend=True,\n            dragmode='select',  # Enables rectangular selection\n            clickmode='event+select',  # Enable click events and selection events\n            legend=dict(  # This ensures that clicking the legend will toggle visibility\n                itemclick=\"toggle\",  # Toggle visibility when clicked\n                itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n            )\n        )\n    else:\n        relevant_k_points = self.get_high_symmetry_points() # Use high symmetry points for the x-axis \n                                                            # Gamma, X, M for square lattice and\n                                                            # Gamma, K, M for triangular lattice                                                   \n        fig.update_layout(\n            title=title,\n            xaxis=dict(\n                tickmode='array',\n                tickvals=[i * (len(freqs) - 4) / 3 + i for i in range(4)],\n                ticktext=list(relevant_k_points.keys()) + [list(relevant_k_points.keys())[0]]  # Repeat the first element at the end\n            ),\n            yaxis_title='frequency (c/a)',\n            showlegend=True,\n            dragmode='select',  # Enables rectangular selection\n            clickmode='event+select',  # Enable click events and selection events\n            legend=dict(  # This ensures that clicking the legend will toggle visibility\n                itemclick=\"toggle\",  # Toggle visibility when clicked\n                itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n            )\n        )\n\n    return fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_epsilon","title":"<code>plot_epsilon(fig=None, title='Epsilon')</code>","text":"<p>Plot the epsilon of the photonic crystal interactively using Plotly. Not implemented in the base class. Must be implemented in the derived class.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the epsilon plot to. Default is None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Epsilon'.</p> <code>'Epsilon'</code> <p>Returns:</p> Type Description <p>go.Figure: The Plotly figure object.(Not woroking yet, error is thrown)</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_epsilon(self, fig=None, title='Epsilon'):\n    \"\"\"\n    Plot the epsilon of the photonic crystal interactively using Plotly.\n    Not implemented in the base class. Must be implemented in the derived class.\n\n    Args:\n        fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n        title (str, optional): The title of the plot. Default is 'Epsilon'.\n\n    Returns:\n        go.Figure: The Plotly figure object.(Not woroking yet, error is thrown)\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_mode_fields_normal_to_k","title":"<code>plot_mode_fields_normal_to_k(mode, k)</code>","text":"<p>Plot the fields perpendicular to the wavevector k for the mode. To be tested, not sure if works correctly.</p> <p>Args: - mode: The mode dictionary. - k: The wavevector [kx, ky, kz].</p> <p>Returns: - fig_e: The Plotly figure for the electric field. - fig_h: The Plotly figure for the magnetic field.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_mode_fields_normal_to_k(self, mode, k):\n    \"\"\"\n    Plot the fields perpendicular to the wavevector k for the mode.\n    To be tested, not sure if works correctly.\n\n    Args:\n    - mode: The mode dictionary.\n    - k: The wavevector [kx, ky, kz].\n\n    Returns:\n    - fig_e: The Plotly figure for the electric field.\n    - fig_h: The Plotly figure for the magnetic field.\n    \"\"\"\n    fields = [mode[\"e_field\"], mode[\"h_field\"]]\n    fields_norm_to_k = self._calculate_field_norm_to_k(fields, k)\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n\n\n    fig_e.add_trace(self._field_to_cones(fields_norm_to_k[0], colorscale=\"blues\"))\n    fig_h.add_trace(self._field_to_cones(fields_norm_to_k[1], colorscale=\"reds\"))\n    return fig_e, fig_h \n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_modes_vectorial_fields","title":"<code>plot_modes_vectorial_fields(modes, sizemode='scaled', names=['Electric Field', 'Magnetic Field'])</code>","text":"<p>Plot the vectorial fields of the modes. Has to be checked, Half working, not tested yet.</p> <p>Args: - modes: The list of modes to plot. - sizemode: The sizemode for the cones. Default is 'scaled'. - names: The names of the fields. Default is ['Electric Field', 'Magnetic Field'].</p> <p>Returns: - fig_e: The Plotly figure for the electric field. - fig_h: The Plotly figure for the magnetic field.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_modes_vectorial_fields(self, modes, sizemode=\"scaled\", names=[\"Electric Field\", \"Magnetic Field\"]):\n    \"\"\"\n    Plot the vectorial fields of the modes.\n    Has to be checked, Half working, not tested yet.\n\n    Args:\n    - modes: The list of modes to plot.\n    - sizemode: The sizemode for the cones. Default is 'scaled'.\n    - names: The names of the fields. Default is ['Electric Field', 'Magnetic Field'].\n\n    Returns:\n    - fig_e: The Plotly figure for the electric field.\n    - fig_h: The Plotly figure for the magnetic field.\n\n    \"\"\"\n\n    colorscales = [\"blues\", \"reds\", \"greens\", \"purples\", \"oranges\", \"ylorbr\"]\n\n    h_fields = [mode[\"h_field\"] for mode in modes]\n    e_fields = [mode[\"e_field\"] for mode in modes]\n\n    max_norm_h = PhotonicCrystal._calculate_fields_max_norms(h_fields)\n    max_norm_e = PhotonicCrystal._calculate_fields_max_norms(e_fields)\n\n    e_sizeref = max_norm_e\n    h_sizeref = max_norm_h\n\n    e_clim = (0, max_norm_e)\n    h_clim= (0, max_norm_h)\n\n\n    e_fig = go.Figure()\n    h_fig = go.Figure()\n\n    e_cones = PhotonicCrystal._fields_to_cones(e_fields, colorscale=colorscales[0], sizemode=sizemode, sizeref=e_sizeref, clim=e_clim, colorscales=colorscales)\n    h_cones = PhotonicCrystal._fields_to_cones(h_fields, colorscale=colorscales[1], sizemode=sizemode, sizeref=h_sizeref, clim=h_clim, colorscales=colorscales) \n\n\n    for e_cone in e_cones:  \n        e_fig.add_trace(e_cone)\n    for h_cone in h_cones:\n        h_fig.add_trace(h_cone)\n\n\n    e_fig.update_layout(\n        title=names[0],\n        scene=dict(\n        xaxis=dict(title='X'),\n        yaxis=dict(title='Y'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n\n    h_fig.update_layout(\n        title=names[1],\n        scene=dict(\n        xaxis=dict(title='X'),\n        yaxis=dict(title='Y'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n\n    return e_fig, h_fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_vectorial_fields","title":"<code>plot_vectorial_fields(fields, colorscales=['Viridis', 'Viridis'], names=['Field 1', 'Field 2'])</code>","text":"<p>Plot the vectorial fields of the modes. Not sure if it is working properly. To be tested.</p> <p>Args: - fields: The list of fields to plot. - colorscales: The colorscales for the cones. Default is [\"Viridis\", \"Viridis\"]. - names: The names of the fields. Default is [\"Field 1\", \"Field 2\"].</p> <p>Returns: - fig_e: The Plotly figure for the electric field. - fig_h: The Plotly figure for the magnetic field.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_vectorial_fields(self, fields, colorscales=[\"Viridis\",\"Viridis\"], names=[\"Field 1\", \"Field 2\"]): \n    \"\"\"\n    Plot the vectorial fields of the modes.\n    Not sure if it is working properly. To be tested.\n\n    Args:\n    - fields: The list of fields to plot.\n    - colorscales: The colorscales for the cones. Default is [\"Viridis\", \"Viridis\"].\n    - names: The names of the fields. Default is [\"Field 1\", \"Field 2\"].\n\n    Returns:\n    - fig_e: The Plotly figure for the electric field.\n    - fig_h: The Plotly figure for the magnetic field.\n    \"\"\"\n\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n    fig_e.add_trace(self._field_to_cones(fields[0], colorscale=colorscales[0]))\n    fig_h.add_trace(self._field_to_cones(fields[1], colorscale=colorscales[1]))\n    fig_e.update_layout(\n        title=names[0],\n        scene=dict(\n        xaxis=dict(title='Y'),\n        yaxis=dict(title='X'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n\n    fig_h.update_layout(\n        title=names[1],\n        scene=dict(\n        xaxis=dict(title='Y'),\n        yaxis=dict(title='X'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n    return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.run_dumb_simulation","title":"<code>run_dumb_simulation()</code>","text":"<p>Run a dumb simulation.  This is used to quickly extract some values from the simulation later.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def run_dumb_simulation(self) -&gt; mpb.ModeSolver:    \n    \"\"\"\n    Run a dumb simulation. \n    This is used to quickly extract some values from the simulation later. \n    \"\"\"\n\n    #run the simulation in the gamma point, find one mode\n    self.ms = mpb.ModeSolver(geometry=self.geometry,\n                              geometry_lattice=self.geometry_lattice,\n                              k_points=[mp.Vector3()],\n                              resolution=self.resolution,\n                              num_bands=1)\n\n    self.ms.run()\n    ms = self.ms\n    return ms\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.run_simulation","title":"<code>run_simulation(runner='run_zeven', polarization=None)</code>","text":"<p>Run the simulation to calculate the frequencies and gaps.</p> <p>Parameters:</p> Name Type Description Default <code>runner</code> <code>str</code> <p>The name of the function to run the simulation. Default is 'run_zeven'. </p> <code>'run_zeven'</code> <code>polarization</code> <code>str</code> <p>The polarization of the simulation. Default is None. If None, it uses the runner name.</p> <code>None</code> <p>runner must correspond to an MPB runner. For example: </p> <p>-'run_zeven': Run the simulation for even parity modes in z-axis.</p> <p>-'run_zodd': Run the simulation for odd parity modes in z-axis.</p> <p>-'run_tm': Run the simulation for transverse magnetic modes.</p> <p>-'run_te': Run the simulation for transverse electric modes.</p> <p>-'run': Do not consider symmetry.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def run_simulation(self, runner=\"run_zeven\", polarization=None):\n    \"\"\"\n    Run the simulation to calculate the frequencies and gaps.\n\n    Args:\n        runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n        polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n\n    runner must correspond to an MPB runner. For example: \\n\n    -'run_zeven': Run the simulation for even parity modes in z-axis.\\n\n    -'run_zodd': Run the simulation for odd parity modes in z-axis.\\n\n    -'run_tm': Run the simulation for transverse magnetic modes.\\n\n    -'run_te': Run the simulation for transverse electric modes.\\n\n    -'run': Do not consider symmetry.\n    \"\"\"\n    if self.ms is None:\n        raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n    if polarization is not None:\n        polarization = polarization\n    else:\n        if runner.startswith(\"run_\"):\n            polarization = runner[4:]\n        else:\n            polarization = runner\n\n    # This is a custom mpb output function that stores the fields and frequencies\n    def get_mode_data(ms, band):\n        mode = {\n            \"h_field\": ms.get_hfield(band, bloch_phase=True),\n            \"e_field\": ms.get_efield(band, bloch_phase=True),\n            \"freq\": ms.freqs[band-1],\n            \"k_point\": ms.current_k,\n            \"polarization\": polarization\n        }\n        self.modes.append(mode)\n\n    print(self.k_points_interpolated)\n    with suppress_output():\n        getattr(self.ms, runner)(get_mode_data)\n        self.freqs[polarization] = self.ms.all_freqs\n        self.gaps[polarization] = self.ms.gap_list\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.set_solver","title":"<code>set_solver(k_point=None)</code>","text":"<p>Set the mode solver for the simulation.  For how MPB works, it is better to call this method each time you want to run a simulation. This method initializes the mode solver (ms) with the geometry, geometry lattice,  k-points, resolution, and number of bands. If a specific k-point is provided,  the solver is set up for that k-point. Otherwise, it uses the interpolated k-points.</p> <p>Parameters:</p> Name Type Description Default <code>k_point</code> <code>Vector3</code> <p>The k-point for the simulation. Default is None.</p> <code>None</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def set_solver(self, k_point = None):\n    \"\"\"\n    Set the mode solver for the simulation. \n    For how MPB works, it is better to call this method each time you want to run a simulation.\n    This method initializes the mode solver (ms) with the geometry, geometry lattice, \n    k-points, resolution, and number of bands. If a specific k-point is provided, \n    the solver is set up for that k-point. Otherwise, it uses the interpolated k-points.\n\n    Args:\n        k_point (mp.Vector3, optional): The k-point for the simulation. Default is None.\n\n    \"\"\"\n\n    if k_point is not None:\n        self.ms = mpb.ModeSolver(geometry=self.geometry,\n                              geometry_lattice=self.geometry_lattice,\n                              k_points=[k_point],\n                              resolution=self.resolution,\n                              num_bands=self.num_bands)\n    else:\n        self.ms = mpb.ModeSolver(geometry=self.geometry,\n                                geometry_lattice=self.geometry_lattice,\n                                k_points=self.k_points_interpolated,\n                                resolution=self.resolution,\n                                num_bands=self.num_bands)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.suppress_output","title":"<code>suppress_output()</code>","text":"<p>Context manager to suppress stdout and stderr.</p> <p>This context manager redirects the standard output (stdout) and standard error (stderr) to os.devnull, effectively suppressing any output within its context.</p> <p>Yields:</p> Name Type Description <code>None</code> <p>This context manager does not return any value.</p> Example <p>with suppress_output(): ...     print(\"This will not be printed\") ...     raise ValueError(\"This error will not be shown\")</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@contextlib.contextmanager\ndef suppress_output():\n    \"\"\"\n    Context manager to suppress stdout and stderr.\n\n    This context manager redirects the standard output (stdout) and standard error (stderr)\n    to os.devnull, effectively suppressing any output within its context.\n\n    Yields:\n        None: This context manager does not return any value.\n\n    Example:\n        &gt;&gt;&gt; with suppress_output():\n        ...     print(\"This will not be printed\")\n        ...     raise ValueError(\"This error will not be shown\")\n    \"\"\"\n    with open(os.devnull, 'w') as devnull:\n        old_stdout = sys.stdout\n        old_stderr = sys.stderr\n        sys.stdout = devnull\n        sys.stderr = devnull\n        try:\n            yield\n        finally:\n            sys.stdout = old_stdout\n            sys.stderr = old_stderr\n</code></pre>"}]}