{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome in the NZI Material Finder!","text":"<p>This tool leverages the MPB Python Interface, which is part of the MEEP repository, to perform simulations of 2D photonic crystals and photonic crystal slabs. This tool has been developed to find NZI Material realized with of PhCs. </p> <p>It is possible to use the Dash application or directly write your code in Python using the API for further data analysis; for the latter I suggest using Jupyther Notebook. </p> <p>The basic process flow is: </p> <ol> <li>Choose the crystal type (2D or Slab)</li> <li>Choose the lattice type (triangular or square)</li> <li>Choose the materials of background, substrate,  bulk and atom</li> <li>Choose the geometry of the atom (circular, square, elliptical or rectangular)</li> <li>Set the MPB Solver</li> <li>Run the simulatiom </li> <li>Plot the bands</li> <li>Investigate the field at specific band points</li> <li>If you want, you can sweep some geometry parameters. </li> </ol>"},{"location":"for_me/","title":"Development","text":"<pre><code># First build the package \nconda build conda-recipe -c conda-forge\nconda build purge\n\n\n# Then anaconda login \nanaconda login\n\n# Then publish: \nls ~/miniconda3/conda-bld/linux-64/\n\nanaconda upload ~/miniconda3/conda-bld/linux-64/nzi-phc-finder-0.1.0-py311_0.tar.bz2\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#how_to_run_this_mpb_based_application","title":"How to run this MPB based application?","text":"<p>Warning</p> <p>Linux is required. I use WSL with Ubuntu. But this can also work with HPC. </p> <p>At its core this is a Python Dash application that use MPB to do the calculations. </p> <p>In its current version MPB's Python interface is part of MEEP's Python interface.  Hence, MEEP must be installed to make it work. </p> <p>MEEP is not available for ARM processors, so it cannot be installed on some Macbooks for example.  If you have this problem you might want to use DTU HPC based on Alma Linux. Otherwise you can just install it in your machine. </p>"},{"location":"installation/#how_to_connect_to_dtu_hpc","title":"How to connect to DTU HPC","text":"<p>To connect to DTU HPC follow the guide on the offical website and use ThinLinc Client to get access.</p> <p>When you are connected:</p> <ol> <li>Click on Application</li> <li>Click on Terminal Emulator. </li> <li>In the terminal write the command 'code'.  It should open Visual Studio Code </li> </ol>"},{"location":"installation/#set_up_visual_studio_code_vsc","title":"Set up Visual Studio Code (VSC)","text":"<ol> <li>(Skip to 3 if you are  already logged with your GitHub account)     On the bottom-left corner click on Accounts and then \"Backup and Sync Settings...\"</li> <li>You will be redirected to the GitHub login: follow the instructions. </li> <li>Fork my repo enricovallar/nzi-lithium-niobate into your account.</li> <li>Go back to VSC and in a new window on the left panel click on Source Control (git symbol) and click on \"Clone Repository\". Clone the repository from GitHub following the instructions.</li> </ol>"},{"location":"installation/#installing_miniconda","title":"Installing Miniconda","text":"<p>We need a virtual conda envirenment to install MEEP. </p> <p>Open a new 'Terminal'. Write the following lines:  <pre><code>wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nbash Miniconda3-latest-Linux-x86_64.sh\n\nsource ~/miniconda3/bin/activate\n\nconda init\n</code></pre></p>"},{"location":"installation/#activating_the_virtual_envirenment","title":"Activating the virtual envirenment","text":"<p>Now we install the most important dependences:</p> <ul> <li>meep</li> <li>dash</li> <li>mkdocs</li> </ul> <p><pre><code>conda create -n nzi-mp python=3.11 nzi-phc-finder -c enricovallar -c conda-forge -y\nconda activate nzi-mp\n</code></pre> Make sure to always use the python interpreter of this virtual envirenment</p>"},{"location":"installation/#reading_the_docs","title":"Reading the docs","text":"<pre><code>mkdocs serve\n</code></pre>"},{"location":"installation/#running_the_application","title":"Running the application","text":"<p>When the right interpreter is chosen you just need to run ./src/app.py</p>"},{"location":"api/crystal_analysis/","title":"crystal_analysis","text":"<p>options:   heading_level: 2   show_root_heading: true   show_root_full_path: true   group_by_category: true   show_category_heading: true</p>"},{"location":"api/crystal_analysis/#src.crystal_analysis","title":"<code>src.crystal_analysis</code>","text":""},{"location":"api/crystal_analysis/#src.crystal_analysis-functions","title":"Functions","text":""},{"location":"api/crystal_analysis/#src.crystal_analysis.plot_field_components","title":"<code>plot_field_components(field_component1, field_component2, name1, name2, cmap='rainbow', vmin=None, vmax=None, title='')</code>","text":"<p>Plot two components of the converted field as subplots. It considers the real part of the field components.</p> <p>Example</p> <pre><code>plot_field_components(Ez, Hy, 'Ez', 'Hy', cmap='rainbow', vmin=-1, vmax=1)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str</code> <p>The colormap to use for the plots. Defaults to \"rainbow\".</p> <code>'rainbow'</code> <code>vmin</code> <code>float</code> <p>The minimum value for the colormap. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value for the colormap. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>matplotlib.figure.Figure: The figure containing the plots.</p> Source code in <code>src/crystal_analysis.py</code> <pre><code>def plot_field_components(field_component1, field_component2, name1, name2, cmap=\"rainbow\", vmin=None, vmax=None, title=\"\"):\n    \"\"\"Plot two components of the converted field as subplots. It considers the real part of the field components.\n\n    !!! example\n    ```python\n    plot_field_components(Ez, Hy, 'Ez', 'Hy', cmap='rainbow', vmin=-1, vmax=1)\n    ```\n\n    Args:\n        cmap (str, optional): The colormap to use for the plots. Defaults to \"rainbow\".\n        vmin (float, optional): The minimum value for the colormap. Defaults to None.\n        vmax (float, optional): The maximum value for the colormap. Defaults to None.\n\n    Returns:\n        matplotlib.figure.Figure: The figure containing the plots.\n    \"\"\"\n\n    # Input validation\n    if not isinstance(field_component1, np.ndarray) or not isinstance(field_component2, np.ndarray):\n        raise TypeError(\"Field components must be numpy arrays\")\n    if field_component1.shape != field_component2.shape:\n        raise ValueError(\"Field components must have the same shape\")\n\n    # Create figure with specified size\n    fig = plt.figure(figsize=(12, 6))\n    plt.rcParams.update({'font.size': 14})  # Increase font size\n\n    # Common plotting parameters\n    plot_params = {\n        'cmap': cmap,\n        'origin': 'lower',\n        'vmin': vmin or np.real(np.minimum(field_component1.min(), field_component2.min())),\n        'vmax': vmax or np.real(np.maximum(field_component1.max(), field_component2.max())),\n        'aspect': 'equal'\n    }\n\n    # Plot the first field component\n    ax1 = plt.subplot(1, 2, 1)\n    im1 = ax1.imshow(np.real(field_component1).T, **plot_params)\n    cbar1 = plt.colorbar(im1, ax=ax1, label=f\"Re({name1})\")\n    cbar1.ax.tick_params(labelsize=10)\n    cbar1.ax.set_aspect(10)\n    ax1.set_title(f'{name1}', fontsize=16)\n    ax1.set_xlabel('x')\n    ax1.set_ylabel('y')\n\n    # Plot the second field component\n    ax2 = plt.subplot(1, 2, 2)\n    im2 = ax2.imshow(np.real(field_component2).T, **plot_params)\n    cbar2 = plt.colorbar(im2, ax=ax2, label=f\"Re({name2})\")\n    cbar2.ax.tick_params(labelsize=10)\n    cbar2.ax.set_aspect(10)\n    ax2.set_title(f'{name2}', fontsize=16)\n    ax2.set_xlabel('x')\n    ax2.set_ylabel('y')\n\n    plt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to make room for suptitle\n    fig.suptitle(title, fontsize=18)\n    return fig\n</code></pre>"},{"location":"api/crystal_analysis/#src.crystal_analysis.mask_field","title":"<code>mask_field(field, mask)</code>","text":"<p>Apply a mask to the field.</p> <p>Example</p> <pre><code>region_I_mask = (np.real(Hy) &gt; 0)\nregion_II_mask = (np.real(Hy) &lt; 0)\n\nEz_masked_I = mask_field(Ez, region_I_mask)\nHy_masked_I = mask_field(Hy, region_I_mask)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>ndarray</code> <p>The field to be masked. Shape (Nx, Ny).</p> required <code>mask</code> <code>ndarray</code> <p>The mask to apply.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: The masked field.</p> Source code in <code>src/crystal_analysis.py</code> <pre><code>def mask_field(field, mask):\n    \"\"\"\n    Apply a mask to the field.\n\n    !!! example\n\n        ```python\n        region_I_mask = (np.real(Hy) &gt; 0)\n        region_II_mask = (np.real(Hy) &lt; 0)\n\n        Ez_masked_I = mask_field(Ez, region_I_mask)\n        Hy_masked_I = mask_field(Hy, region_I_mask)\n        ```\n\n    Parameters:\n        field (numpy.ndarray): The field to be masked. Shape (Nx, Ny).\n        mask (numpy.ndarray): The mask to apply.\n\n\n    Returns:\n        numpy.ndarray: The masked field.\n    \"\"\"\n    masked_field = np.where(mask, field, 0)\n    return masked_field\n</code></pre>"},{"location":"api/crystal_analysis/#src.crystal_analysis.integrate_field","title":"<code>integrate_field(F, resolution, periods)</code>","text":"<p>Integrates a 2D field over a periodic domain using Simpson's rule.</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>ndarray</code> <p>2D array representing the field to be integrated.</p> required <code>resolution</code> <code>int</code> <p>Number of points in each dimension of the grid.</p> required <code>periods</code> <code>int</code> <p>Number of periods in the domain.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The integrated value of the field normalized by the number of periods squared.</p> <p>Note</p> <ul> <li>The domain is assumed to be square with unit size.</li> <li>Integration is performed using a simple summation with uniform grid spacing.</li> <li>The result is normalized by dividing by periods^2.</li> </ul> Source code in <code>src/crystal_analysis.py</code> <pre><code>def integrate_field(F, resolution, periods):\n    \"\"\"Integrates a 2D field over a periodic domain using Simpson's rule.\n\n    Args:\n        F (numpy.ndarray): 2D array representing the field to be integrated.\n        resolution (int): Number of points in each dimension of the grid.\n        periods (int): Number of periods in the domain.\n\n    Returns:\n        float: The integrated value of the field normalized by the number of periods squared.\n\n    !!! note\n\n        - The domain is assumed to be square with unit size.\n        - Integration is performed using a simple summation with uniform grid spacing.\n        - The result is normalized by dividing by periods^2.\n    \"\"\"\n\n    # Compute the integral of the fields using Simpson's rule\n    dx = dy = 1.0 / resolution\n    print(\"dx: \", dx, \"dy: \", dy)\n    F_integrated = np.sum(F)*dx*dy / periods**2\n\n    return F_integrated\n</code></pre>"},{"location":"api/crystal_analysis/#src.crystal_analysis.calculate_effective_parameters","title":"<code>calculate_effective_parameters(E_i_avg, H_j_avg, freq, k_l)</code>","text":"<p>Calculate effective permittivity (epsilon_eff) and permeability (mu_eff).    All quantities follow the MPB normalization convention.</p> <p>Parameters:</p> Name Type Description Default <code>E_i_avg</code> <code>float</code> <p>Averaged i-component of the electric field.</p> required <code>H_j_avg</code> <code>float</code> <p>Averaged j-component of the magnetic field.</p> required <code>freq</code> <code>float</code> <p>Frequency.</p> required <code>k_l</code> <code>float</code> <p>Wave vector l-component.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing:</p> <ul> <li>epsilon_eff (float): Effective permittivity</li> <li>mu_eff (float): Effective permeability</li> </ul> <p>Warning</p> <p>The imaginary part of the fields is neglected in this calculation.</p> Source code in <code>src/crystal_analysis.py</code> <pre><code>def calculate_effective_parameters(E_i_avg, H_j_avg, freq, k_l):\n    \"\"\"Calculate effective permittivity (epsilon_eff) and permeability (mu_eff).\n       All quantities follow the MPB normalization convention.\n\n    Args:\n        E_i_avg (float): Averaged i-component of the electric field.\n        H_j_avg (float): Averaged j-component of the magnetic field.\n        freq (float): Frequency.\n        k_l (float): Wave vector l-component.\n\n    Returns:\n        tuple: A tuple containing:\n\n            - epsilon_eff (float): Effective permittivity\n            - mu_eff (float): Effective permeability\n\n    !!! warning\n        The imaginary part of the fields is neglected in this calculation.\n    \"\"\"\n\n\n    epsilon_eff = (k_l / freq) * (np.real(H_j_avg) / np.real(E_i_avg))\n    mu_eff = (k_l / freq) * (np.real(E_i_avg) / np.real(H_j_avg))\n\n    return epsilon_eff, mu_eff\n</code></pre>"},{"location":"api/crystal_analysis/#src.crystal_analysis.example_analysis","title":"<code>example_analysis()</code>","text":"<p>This function is an example of how to analyze the results of a simulation.  It calculates the effective permittivity and permeability of the mode, and plots the field components.</p> <p>Example</p> <pre><code>import crystal_analysis as ca\n\n# These parameters are used to determine dx and dy to integrate the fields\nresolution  = mode[\"e_field_periodic\"].shape[0]\nperiods = 3\nprint(\"Resolution: \", resolution, \"Periods: \", periods, \"total points: \", resolution*periods)\nms = crystal_2d.run_dumb_simulation()\nmd = mpb.MPBData(lattice=ms.get_lattice(), rectify = True, periods=periods)\nwith suppress_output():\n    E= md.convert(mode[\"e_field_periodic\"], kpoint=mp.Vector3())\n    H= md.convert(mode[\"h_field_periodic\"], kpoint=mp.Vector3())\nprint(\"Shape of E after conversion: \", E.shape)\nprint(\"Shape of H after conversion: \", H.shape)\n\nEz = np.array(E[...,2])\nHy = np.array(H[...,1])\nprint(\"Shape of Ez: \", Ez.shape)    \nprint(\"Shape of Hy: \", Hy.shape)\n\n# We plot the real part of the fields in the same figure\nfig = ca.plot_field_components(Ez, Hy, '$E_z$', '$H_y$', title=\"Relevant components of the field\")\n\n# The calculation of the effective parameters is done by averaging the fields over the unit cell. \n# Since we don't want the average to be zero, we need to mask the fields and perform two integrations.\n\nregion_I_mask = (np.real(Hy) &gt; 0)\nregion_II_mask = (np.real(Hy) &lt; 0)\n\nEz_masked_I = ca.mask_field(Ez, region_I_mask)\nHy_masked_I = ca.mask_field(Hy, region_I_mask)\nca.plot_field_components(Ez_masked_I, Hy_masked_I, '$E_z$', '$H_y$', vmin=-1, vmax=1, title=\"Region I ($H_y$ &gt; 0)\")\n\nEz_masked_II = ca.mask_field(Ez, region_II_mask)\nHy_masked_II = ca.mask_field(Hy, region_II_mask)\nca.plot_field_components(Ez_masked_II, Hy_masked_II, '$E_z$', '$H_y$', vmin=-1, vmax=1, title=\"Region II ($H_y$ &lt; 0)\")\n\nprint(\"Shape of Ez_masked_I: \", Ez_masked_I.shape)\nprint(\"Shape of Hy_masked_I: \", Hy_masked_I.shape)\n# We calculate the effective parameters\nEz_avg_I = ca.integrate_field(Ez_masked_I, resolution, periods)\nHy_avg_I = ca.integrate_field(Hy_masked_I, resolution, periods)\n\nEz_avg_II = ca.integrate_field(Ez_masked_II, resolution, periods)\nHy_avg_II = ca.integrate_field(Hy_masked_II, resolution, periods)\n\nprint(\"Ez_avg_I: \", Ez_avg_I)\nprint(\"Hy_avg_I: \", Hy_avg_I)\nprint(\"Ez_avg_II: \", Ez_avg_II)\nprint(\"Hy_avg_II: \", Hy_avg_II)\n\n# Now we calculate the effective parameters, one value for each region\nepsilon_eff_I, mu_eff_I = ca.calculate_effective_parameters(Ez_avg_I, Hy_avg_I, mode[\"freq\"], mode[\"k_point\"][0])\nepsilon_eff_II, mu_eff_II = ca.calculate_effective_parameters(Ez_avg_II, Hy_avg_II, mode[\"freq\"], mode[\"k_point\"][0])\n\nprint(\"\\nEffective parameters in region I:\")\nprint(\" epsilon_eff: \", epsilon_eff_I)\nprint(\" mu_eff: \", mu_eff_I)\n\nprint(\"\\nEffective parameters in region II:\")\nprint(\"epsilon_eff: \", epsilon_eff_II)\nprint(\"mu_eff: \", mu_eff_II)\n\n# Now we calculate the effective parameters for the whole domain\nepsilon_eff = np.sqrt(epsilon_eff_I +0j)*np.sqrt(epsilon_eff_II+0j)\nmu_eff = np.sqrt(mu_eff_I +0j)*np.sqrt(mu_eff_II+0j)\n\nprint('\\nEffective parameters for the whole domain:')\nprint(' epsilon_eff: ', epsilon_eff)\nprint(' mu_eff: ', mu_eff)\n</code></pre> Source code in <code>src/crystal_analysis.py</code> <pre><code>def example_analysis(): \n    \"\"\"\n    This function is an example of how to analyze the results of a simulation. \n    It calculates the effective permittivity and permeability of the mode, and plots the field components.\n\n    !!! example\n        ```python\n        import crystal_analysis as ca\n\n        # These parameters are used to determine dx and dy to integrate the fields\n        resolution  = mode[\"e_field_periodic\"].shape[0]\n        periods = 3\n        print(\"Resolution: \", resolution, \"Periods: \", periods, \"total points: \", resolution*periods)\n        ms = crystal_2d.run_dumb_simulation()\n        md = mpb.MPBData(lattice=ms.get_lattice(), rectify = True, periods=periods)\n        with suppress_output():\n            E= md.convert(mode[\"e_field_periodic\"], kpoint=mp.Vector3())\n            H= md.convert(mode[\"h_field_periodic\"], kpoint=mp.Vector3())\n        print(\"Shape of E after conversion: \", E.shape)\n        print(\"Shape of H after conversion: \", H.shape)\n\n        Ez = np.array(E[...,2])\n        Hy = np.array(H[...,1])\n        print(\"Shape of Ez: \", Ez.shape)    \n        print(\"Shape of Hy: \", Hy.shape)\n\n        # We plot the real part of the fields in the same figure\n        fig = ca.plot_field_components(Ez, Hy, '$E_z$', '$H_y$', title=\"Relevant components of the field\")\n\n        # The calculation of the effective parameters is done by averaging the fields over the unit cell. \n        # Since we don't want the average to be zero, we need to mask the fields and perform two integrations.\n\n        region_I_mask = (np.real(Hy) &gt; 0)\n        region_II_mask = (np.real(Hy) &lt; 0)\n\n        Ez_masked_I = ca.mask_field(Ez, region_I_mask)\n        Hy_masked_I = ca.mask_field(Hy, region_I_mask)\n        ca.plot_field_components(Ez_masked_I, Hy_masked_I, '$E_z$', '$H_y$', vmin=-1, vmax=1, title=\"Region I ($H_y$ &gt; 0)\")\n\n        Ez_masked_II = ca.mask_field(Ez, region_II_mask)\n        Hy_masked_II = ca.mask_field(Hy, region_II_mask)\n        ca.plot_field_components(Ez_masked_II, Hy_masked_II, '$E_z$', '$H_y$', vmin=-1, vmax=1, title=\"Region II ($H_y$ &lt; 0)\")\n\n        print(\"Shape of Ez_masked_I: \", Ez_masked_I.shape)\n        print(\"Shape of Hy_masked_I: \", Hy_masked_I.shape)\n        # We calculate the effective parameters\n        Ez_avg_I = ca.integrate_field(Ez_masked_I, resolution, periods)\n        Hy_avg_I = ca.integrate_field(Hy_masked_I, resolution, periods)\n\n        Ez_avg_II = ca.integrate_field(Ez_masked_II, resolution, periods)\n        Hy_avg_II = ca.integrate_field(Hy_masked_II, resolution, periods)\n\n        print(\"Ez_avg_I: \", Ez_avg_I)\n        print(\"Hy_avg_I: \", Hy_avg_I)\n        print(\"Ez_avg_II: \", Ez_avg_II)\n        print(\"Hy_avg_II: \", Hy_avg_II)\n\n        # Now we calculate the effective parameters, one value for each region\n        epsilon_eff_I, mu_eff_I = ca.calculate_effective_parameters(Ez_avg_I, Hy_avg_I, mode[\"freq\"], mode[\"k_point\"][0])\n        epsilon_eff_II, mu_eff_II = ca.calculate_effective_parameters(Ez_avg_II, Hy_avg_II, mode[\"freq\"], mode[\"k_point\"][0])\n\n        print(\"\\\\nEffective parameters in region I:\")\n        print(\" epsilon_eff: \", epsilon_eff_I)\n        print(\" mu_eff: \", mu_eff_I)\n\n        print(\"\\\\nEffective parameters in region II:\")\n        print(\"epsilon_eff: \", epsilon_eff_II)\n        print(\"mu_eff: \", mu_eff_II)\n\n        # Now we calculate the effective parameters for the whole domain\n        epsilon_eff = np.sqrt(epsilon_eff_I +0j)*np.sqrt(epsilon_eff_II+0j)\n        mu_eff = np.sqrt(mu_eff_I +0j)*np.sqrt(mu_eff_II+0j)\n\n        print('\\\\nEffective parameters for the whole domain:')\n        print(' epsilon_eff: ', epsilon_eff)\n        print(' mu_eff: ', mu_eff)\n        ```\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/crystal_geometries/","title":"crystal_geometries","text":"<p>options:   heading_level: 2   show_root_heading: true   show_root_full_path: true   group_by_category: true   show_category_heading: true</p>"},{"location":"api/crystal_geometries/#src.crystal_geometries","title":"<code>src.crystal_geometries</code>","text":""},{"location":"api/crystal_geometries/#src.crystal_geometries-classes","title":"Classes","text":""},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry","title":"<code>Crystal_Geometry</code>","text":"<p>Represents a crystal geometry. This class was done to better handle geometry configuaration in the Dash app. </p> <p>Attributes:</p> Name Type Description <code>material</code> <code>Crystal_Materials</code> <p>The material of the crystal.</p> <code>geometry</code> <code>list</code> <p>List of Meep geometric objects representing the crystal geometry.</p> <code>base_geometry</code> <code>list</code> <p>List of Meep geometric objects representing the base crystal geometry. (bulk, substrate, background)</p> <code>geometry_type</code> <code>str</code> <p>Type of geometry ('circular', 'square', 'rectangular', 'elliptical').</p> <code>atomic_function</code> <code>function</code> <p>Function to add an atomic object to the geometry.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>class Crystal_Geometry:\n\n    \"\"\"\n    Represents a crystal geometry. This class was done to better handle geometry configuaration in the Dash app. \n\n    Attributes:\n        material (Crystal_Materials): The material of the crystal.\n        geometry (list): List of Meep geometric objects representing the crystal geometry.\n        base_geometry (list): List of Meep geometric objects representing the base crystal geometry. (bulk, substrate, background)\n        geometry_type (str): Type of geometry ('circular', 'square', 'rectangular', 'elliptical').\n        atomic_function (function): Function to add an atomic object to the geometry.\n    \"\"\"\n\n\n\n    GEOMETRY_TYPES = ['square', 'circular', 'rectangular', 'elliptical']\n\n\n    def __init__(self, \n                 material : Crystal_Materials,\n                 geometry_type: str = 'circular'\n                 ):\n        self.required_arguments = {\n            \"material\": material,\n            \"geometry_type\": geometry_type,\n        }\n        self.kwargs = {}\n        self.arguments = {**self.required_arguments, **self.kwargs}\n        self.material = material\n        self.geometry =[]\n        self.base_geometry = self.geometry\n        self.geometry_type = geometry_type\n\n        self.atomic_function = None\n\n\n\n    def square_atom(self, l):\n        '''\n        Adds a square atom to the geometry.\n\n        Args:\n            a (float): Length of each side of the square atom.\n\n        Raises:\n            NotImplementedError: If the method is not yet implemented.\n        '''\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n\n    def circular_atom(self, r):\n        '''\n        Adds a circular atom to the geometry.\n\n        Args:\n            r (float): Radius of the circular atom.\n\n        Raises:\n            NotImplementedError: If the method is not yet implemented.\n        '''\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n    def rectangular_atom(self, a, b):\n        '''\n        Adds a rectangular atom to the geometry.\n\n        Args:\n            a (float): Width of the rectangular atom.\n            b (float): Height of the rectangular atom.\n\n        Raises:\n            NotImplementedError: If the method is not yet implemented.\n        '''\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n    def elliptical_atom(self, a, b):\n        '''\n        Adds an elliptical atom to the geometry.\n\n        Args:\n            a (float): Length of the major axis.\n            b (float): Length of the minor axis.\n\n        Raises: \n            NotImplementedError: If the method is not yet implemented.\n        '''\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n    def build_geometry(self):\n        \"\"\"\n        Builds the crystal geometry based on the geometry type and additional keyword arguments.\n\n        Raises:\n            NotImplementedError: If the method is not yet implemented.\n        \"\"\"\n\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n    def geometry_function(self, atomic_function,  **kwargs):\n        \"\"\"\n        Adds an atomic object to the geometry.\n\n        Args:\n            atomic_function (function): Function to add an atomic object to the geometry.\n            **kwargs: Additional keyword arguments specific to the atomic object.\n        \"\"\"\n\n        geometry = self.base_geometry.copy()\n        geometry.append(atomic_function(**kwargs))\n        return geometry \n\n    def to_list(self):\n        \"\"\"\n        Returns the crystal geometry as a list of Meep geometric objects.\n\n        Returns:\n            list: List of Meep geometric objects representing the crystal geometry.\n        \"\"\" \n        return self.geometry.copy()\n\n    def to_partial(self, exclude_key): \n        \"\"\"\n        Returns a partial function with the specified key excluded from the arguments.\n        This is useful for sweeps.\n\n        Args:\n            exclude_key (str): Key to exclude from the arguments.\n\n        Returns:\n            partial: Partial function with the specified key excluded from the arguments.\n        \"\"\" \n        arguments = self.arguments.copy()\n        arguments.pop(exclude_key)\n        return partial(self.__class__, **self.arguments)\n</code></pre>"},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry-functions","title":"Functions","text":""},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry.square_atom","title":"<code>square_atom(l)</code>","text":"<p>Adds a square atom to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Length of each side of the square atom.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def square_atom(self, l):\n    '''\n    Adds a square atom to the geometry.\n\n    Args:\n        a (float): Length of each side of the square atom.\n\n    Raises:\n        NotImplementedError: If the method is not yet implemented.\n    '''\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry.circular_atom","title":"<code>circular_atom(r)</code>","text":"<p>Adds a circular atom to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float</code> <p>Radius of the circular atom.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def circular_atom(self, r):\n    '''\n    Adds a circular atom to the geometry.\n\n    Args:\n        r (float): Radius of the circular atom.\n\n    Raises:\n        NotImplementedError: If the method is not yet implemented.\n    '''\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry.rectangular_atom","title":"<code>rectangular_atom(a, b)</code>","text":"<p>Adds a rectangular atom to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Width of the rectangular atom.</p> required <code>b</code> <code>float</code> <p>Height of the rectangular atom.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def rectangular_atom(self, a, b):\n    '''\n    Adds a rectangular atom to the geometry.\n\n    Args:\n        a (float): Width of the rectangular atom.\n        b (float): Height of the rectangular atom.\n\n    Raises:\n        NotImplementedError: If the method is not yet implemented.\n    '''\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry.elliptical_atom","title":"<code>elliptical_atom(a, b)</code>","text":"<p>Adds an elliptical atom to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Length of the major axis.</p> required <code>b</code> <code>float</code> <p>Length of the minor axis.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def elliptical_atom(self, a, b):\n    '''\n    Adds an elliptical atom to the geometry.\n\n    Args:\n        a (float): Length of the major axis.\n        b (float): Length of the minor axis.\n\n    Raises: \n        NotImplementedError: If the method is not yet implemented.\n    '''\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry.build_geometry","title":"<code>build_geometry()</code>","text":"<p>Builds the crystal geometry based on the geometry type and additional keyword arguments.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def build_geometry(self):\n    \"\"\"\n    Builds the crystal geometry based on the geometry type and additional keyword arguments.\n\n    Raises:\n        NotImplementedError: If the method is not yet implemented.\n    \"\"\"\n\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry.geometry_function","title":"<code>geometry_function(atomic_function, **kwargs)</code>","text":"<p>Adds an atomic object to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_function</code> <code>function</code> <p>Function to add an atomic object to the geometry.</p> required <code>**kwargs</code> <p>Additional keyword arguments specific to the atomic object.</p> <code>{}</code> Source code in <code>src/crystal_geometries.py</code> <pre><code>def geometry_function(self, atomic_function,  **kwargs):\n    \"\"\"\n    Adds an atomic object to the geometry.\n\n    Args:\n        atomic_function (function): Function to add an atomic object to the geometry.\n        **kwargs: Additional keyword arguments specific to the atomic object.\n    \"\"\"\n\n    geometry = self.base_geometry.copy()\n    geometry.append(atomic_function(**kwargs))\n    return geometry \n</code></pre>"},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry.to_list","title":"<code>to_list()</code>","text":"<p>Returns the crystal geometry as a list of Meep geometric objects.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of Meep geometric objects representing the crystal geometry.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def to_list(self):\n    \"\"\"\n    Returns the crystal geometry as a list of Meep geometric objects.\n\n    Returns:\n        list: List of Meep geometric objects representing the crystal geometry.\n    \"\"\" \n    return self.geometry.copy()\n</code></pre>"},{"location":"api/crystal_geometries/#src.crystal_geometries.Crystal_Geometry.to_partial","title":"<code>to_partial(exclude_key)</code>","text":"<p>Returns a partial function with the specified key excluded from the arguments. This is useful for sweeps.</p> <p>Parameters:</p> Name Type Description Default <code>exclude_key</code> <code>str</code> <p>Key to exclude from the arguments.</p> required <p>Returns:</p> Name Type Description <code>partial</code> <p>Partial function with the specified key excluded from the arguments.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def to_partial(self, exclude_key): \n    \"\"\"\n    Returns a partial function with the specified key excluded from the arguments.\n    This is useful for sweeps.\n\n    Args:\n        exclude_key (str): Key to exclude from the arguments.\n\n    Returns:\n        partial: Partial function with the specified key excluded from the arguments.\n    \"\"\" \n    arguments = self.arguments.copy()\n    arguments.pop(exclude_key)\n    return partial(self.__class__, **self.arguments)\n</code></pre>"},{"location":"api/crystal_materials/","title":"crystal_materials","text":"<p>options:   heading_level: 2   show_root_heading: true   show_root_full_path: true   group_by_category: true   show_category_heading: true</p>"},{"location":"api/crystal_materials/#src.crystal_materials","title":"<code>src.crystal_materials</code>","text":""},{"location":"api/crystal_materials/#src.crystal_materials-classes","title":"Classes","text":""},{"location":"api/crystal_materials/#src.crystal_materials.Crystal_Materials","title":"<code>Crystal_Materials</code>","text":"<p>Crystal_Materials class for defining crystal material properties.</p> <p>This class manages the material properties of different components in a crystal structure, including background, bulk, atom, and substrate materials. Each material is defined by its dielectric properties and nonlinear susceptibility tensors.</p> <p>Usage:</p> <pre><code>Use a dictionary to set the material properties for each component. The dictionary should\ncontain the valid configuration keys for material properties. The material properties can\nbe set using the background, bulk, atom, and substrate properties.\n</code></pre> Example <pre><code>materials = Crystal_Materials()\nmaterials.background = {\n    'epsilon': 1.0,\n}\nmaterials.bulk = {\n    'epsilon_diag': mp.Vector3(3.5, 4.0, 4.0),\n    'epsilon_offdiag': mp.Vector3(0.0, 0.0, 0.0),\n    'E_chi2_diag': mp.Vector3(0.0, 0.0, 0.0),\n}\n\nmaterials.atom = {\n    'epsilon' : 1.0,\n}\n\nmaterials.substrate = {\n    'epsilon' : 1\n}\n</code></pre> <p>Valid configuration parameters for materials:</p> <pre><code>epsilon (float): Dielectric constant of the material.\nepsilon_diag (mp.Vector3): Diagonal elements of the dielectric tensor.\nepsilon_offdiag (mp.Vector3): Off-diagonal elements of the dielectric tensor.\nE_chi2_diag (mp.Vector3): Diagonal elements of the second-order nonlinear susceptibility tensor.\nE_chi3_diag (mp.Vector3): Diagonal elements of the third-order nonlinear susceptibility tensor.\n</code></pre> <p>Attributes:</p> Name Type Description <code>VALID_KEYS</code> <code>list</code> <p>List of valid configuration keys for material properties.</p> <code>_background</code> <code>Medium</code> <p>Background material properties.</p> <code>_bulk</code> <code>Medium</code> <p>Bulk material properties.</p> <code>_atom</code> <code>Medium</code> <p>Atom material properties.</p> <code>_substrate</code> <code>Medium</code> <p>Substrate material properties.</p> <code>background</code> <p>Gets/sets the background material properties.</p> <code>bulk</code> <p>Gets/sets the bulk material properties.</p> <code>atom</code> <p>Gets/sets the atom material properties.</p> <code>substrate</code> <p>Gets/sets the substrate material properties.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If invalid configuration keys are provided when setting material properties.</p> Source code in <code>src/crystal_materials.py</code> <pre><code>class Crystal_Materials(): \n        \"\"\"Crystal_Materials class for defining crystal material properties.\n\n        This class manages the material properties of different components in a crystal structure,\n        including background, bulk, atom, and substrate materials. Each material is defined by its\n        dielectric properties and nonlinear susceptibility tensors.\n\n        Usage:\n\n            Use a dictionary to set the material properties for each component. The dictionary should\n            contain the valid configuration keys for material properties. The material properties can\n            be set using the background, bulk, atom, and substrate properties.\n\n        Example:\n            ```python\n            materials = Crystal_Materials()\n            materials.background = {\n                'epsilon': 1.0,\n            }\n            materials.bulk = {\n                'epsilon_diag': mp.Vector3(3.5, 4.0, 4.0),\n                'epsilon_offdiag': mp.Vector3(0.0, 0.0, 0.0),\n                'E_chi2_diag': mp.Vector3(0.0, 0.0, 0.0),\n            }\n\n            materials.atom = {\n                'epsilon' : 1.0,\n            }\n\n            materials.substrate = {\n                'epsilon' : 1\n            }\n            ```\n\n\n\n\n\n        Valid configuration parameters for materials:\n\n            epsilon (float): Dielectric constant of the material.\n            epsilon_diag (mp.Vector3): Diagonal elements of the dielectric tensor.\n            epsilon_offdiag (mp.Vector3): Off-diagonal elements of the dielectric tensor.\n            E_chi2_diag (mp.Vector3): Diagonal elements of the second-order nonlinear susceptibility tensor.\n            E_chi3_diag (mp.Vector3): Diagonal elements of the third-order nonlinear susceptibility tensor.\n\n        Attributes:\n            VALID_KEYS (list): List of valid configuration keys for material properties.\n            _background (mp.Medium): Background material properties.\n            _bulk (mp.Medium): Bulk material properties.\n            _atom (mp.Medium): Atom material properties.\n            _substrate (mp.Medium): Substrate material properties.\n            background: Gets/sets the background material properties.\n            bulk: Gets/sets the bulk material properties.\n            atom: Gets/sets the atom material properties.\n            substrate: Gets/sets the substrate material properties.\n\n\n\n        Raises:\n            ValueError: If invalid configuration keys are provided when setting material properties.\n        \"\"\"\n        VALID_KEYS = ['epsilon', 'epsilon_diag', 'epsilon_offdiag', 'E_chi2_diag', 'E_chi3_diag']\n\n        def __init__(self):\n            \"\"\"\n            Initializes the Crystal_Materials class.\n\n            \"\"\"\n            self._background = None\n            self._bulk = None\n            self._atom = None\n            self._substrate = None\n\n\n\n        @property\n        def background(self):\n            return self._background\n\n        @property\n        def bulk(self):\n            return self._bulk\n\n        @property   \n        def atom(self):\n            return self._atom\n\n        @property\n        def substrate(self):\n            return self._substrate\n\n        @background.setter\n        def background(self, configuration: dict):\n            if not all(key in self.VALID_KEYS for key in configuration.keys()):\n                raise ValueError(\"Invalid configuration keys\")\n            self._background = mp.Medium(**configuration)\n\n        @bulk.setter\n        def bulk(self, configuration: dict): \n            if not all(key in self.VALID_KEYS for key in configuration.keys()):\n                raise ValueError(\"Invalid configuration keys\")\n            self._bulk = mp.Medium(**configuration)\n\n\n        @atom.setter\n        def atom(self, configuration: dict): \n            if not all(key in self.VALID_KEYS for key in configuration.keys()):\n                raise ValueError(\"Invalid configuration keys\")\n            self._atom = mp.Medium(**configuration)\n\n        @substrate.setter  \n        def substrate(self, configuration: dict):\n            if not all(key in self.VALID_KEYS for key in configuration.keys()):\n                raise ValueError(\"Invalid configuration keys\")\n            self._substrate = mp.Medium(**configuration)\n</code></pre>"},{"location":"api/crystal_materials/#src.crystal_materials.Crystal_Materials-functions","title":"Functions","text":""},{"location":"api/crystal_materials/#src.crystal_materials.Crystal_Materials.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Crystal_Materials class.</p> Source code in <code>src/crystal_materials.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the Crystal_Materials class.\n\n    \"\"\"\n    self._background = None\n    self._bulk = None\n    self._atom = None\n    self._substrate = None\n</code></pre>"},{"location":"api/photonic_crystal/","title":"photonic_crystal","text":"<p>options:   heading_level: 2   show_root_heading: true   show_root_full_path: true   group_by_category: true   show_category_heading: true</p>"},{"location":"api/photonic_crystal/#src.photonic_crystal","title":"<code>src.photonic_crystal</code>","text":""},{"location":"api/photonic_crystal/#src.photonic_crystal-classes","title":"Classes","text":""},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal","title":"<code>PhotonicCrystal</code>","text":"<p>A class to represent a photonic crystal and perform simulations using MPB (MIT Photonic Bands).</p> <p>Attributes:</p> Name Type Description <code>lattice_type</code> <code>str</code> <p>Type of the lattice.</p> <code>num_bands</code> <code>int</code> <p>Number of bands.</p> <code>resolution</code> <code>tuple[int, int] | int</code> <p>Resolution of the simulation.</p> <code>interp</code> <code>int</code> <p>Interpolation factor for k-points.</p> <code>periods</code> <code>int</code> <p>Number of periods.</p> <code>pickle_id</code> <code>str</code> <p>Identifier for pickling.</p> <code>has_been_run</code> <code>bool</code> <p>Flag indicating if the simulation has been run.</p> <code>geometry_lattice</code> <code>None</code> <p>Geometry lattice, set with basic lattice method.</p> <code>k_points</code> <code>list</code> <p>List of k-points.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points.</p> <code>material</code> <code>Crystal_Materials</code> <p>Material of the photonic crystal.</p> <code>geometry</code> <code>Crystal_Geometry</code> <p>Geometry of the photonic crystal.</p> <code>ms</code> <code>None</code> <p>Placeholder for ms attribute.</p> <code>md</code> <code>None</code> <p>Placeholder for md attribute.</p> <code>freqs</code> <code>dict</code> <p>Dictionary to store frequencies.</p> <code>gaps</code> <code>dict</code> <p>Dictionary to store gaps.</p> <code>epsilon</code> <code>None</code> <p>Placeholder for epsilon attribute.</p> <code>modes</code> <code>list</code> <p>List to store modes.</p> <code>use_XY</code> <code>bool</code> <p>Flag to use XY plane.</p> <p>Methods:</p> Name Description <code>__getstate__</code> <p>Get the state for pickling.</p> <code>__setstate__</code> <p>Set the state after unpickling.</p> <code>pickle_photonic_crystal</code> <p>Pickle the photonic crystal object.</p> <code>load_photonic_crystal</code> <p>Load a pickled photonic crystal object.</p> <code>set_solver</code> <p>Set the mode solver for the simulation.</p> <code>run_simulation</code> <p>Run the simulation to calculate the frequencies and gaps.</p> <code>run_simulation_with_output</code> <p>Run the simulation and get mode data.</p> <code>run_dumb_simulation</code> <p>Run a dumb simulation to quickly extract some values.</p> <code>convert_mode_fields</code> <p>Convert the mode fields to arrays for visualization.</p> <code>extract_data</code> <p>Extract the data from the simulation.</p> <code>plot_epsilon</code> <p>Plot the epsilon of the photonic crystal interactively using Plotly.</p> <code>plot_bands</code> <p>Plot the bands of the photonic crystal using Plotly.</p> <code>get_XY_k_points_near_gamma</code> <p>Get the relevant k-points near the gamma point for the X and Y directions.</p> <code>get_high_symmetry_points</code> <p>Get the high symmetry points for the photonic crystal lattice.</p> <code>plot_field</code> <p>Plot the field visualization.</p> <code>plot_field_components</code> <p>Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> <code>look_for_mode</code> <p>Look for modes within the specified criteria.</p> <code>find_modes_symmetries</code> <p>Find the symmetries of the modes.</p> <code>plot_modes_vectorial_fields</code> <p>Plot the vectorial fields of the modes.</p> <code>plot_mode_fields_normal_to_k</code> <p>Plot the fields perpendicular to the wavevector k for the mode.</p> <code>plot_vectorial_fields</code> <p>Plot the vectorial fields of the modes.</p> <code>_field_to_cones</code> <p>Convert a field to cones for visualization.</p> <code>_fields_to_cones</code> <p>Convert a list of fields to cones for visualization.</p> <code>_calculate_field_norm_to_k</code> <p>Calculate the components of the field perpendicular to the wavevector k.</p> <code>_get_direction</code> <p>Determine the primary direction of the wavevector k.</p> <code>_calculate_effective_parameter</code> <p>Calculate the effective parameters of the mode.</p> <code>basic_geometry</code> <p>Define the basic geometry of the photonic crystal.</p> <code>basic_lattice</code> <p>Define the basic lattice of the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>class PhotonicCrystal:\n    \"\"\"\n    A class to represent a photonic crystal and perform simulations using MPB (MIT Photonic Bands).\n\n    Attributes:\n        lattice_type (str): Type of the lattice.\n        num_bands (int): Number of bands.\n        resolution (tuple[int, int] | int): Resolution of the simulation.\n        interp (int): Interpolation factor for k-points.\n        periods (int): Number of periods.\n        pickle_id (str): Identifier for pickling.\n        has_been_run (bool): Flag indicating if the simulation has been run.\n        geometry_lattice (None): Geometry lattice, set with basic lattice method.\n        k_points (list): List of k-points.\n        k_points_interpolated (list): Interpolated k-points.\n        material (Crystal_Materials): Material of the photonic crystal.\n        geometry (Crystal_Geometry): Geometry of the photonic crystal.\n        ms (None): Placeholder for ms attribute.\n        md (None): Placeholder for md attribute.\n        freqs (dict): Dictionary to store frequencies.\n        gaps (dict): Dictionary to store gaps.\n        epsilon (None): Placeholder for epsilon attribute.\n        modes (list): List to store modes.\n        use_XY (bool): Flag to use XY plane.\n\n    Methods:\n        __getstate__(): Get the state for pickling.\n        __setstate__(state): Set the state after unpickling.\n        pickle_photonic_crystal(pickle_id): Pickle the photonic crystal object.\n        load_photonic_crystal(pickle_id): Load a pickled photonic crystal object.\n        set_solver(k_point): Set the mode solver for the simulation.\n        run_simulation(runner, polarization): Run the simulation to calculate the frequencies and gaps.\n        run_simulation_with_output(runner, polarization): Run the simulation and get mode data.\n        run_dumb_simulation(): Run a dumb simulation to quickly extract some values.\n        convert_mode_fields(mode, periods): Convert the mode fields to arrays for visualization.\n        extract_data(periods): Extract the data from the simulation.\n        plot_epsilon(fig, title): Plot the epsilon of the photonic crystal interactively using Plotly.\n        plot_bands(polarization, title, fig, color): Plot the bands of the photonic crystal using Plotly.\n        get_XY_k_points_near_gamma(distance): Get the relevant k-points near the gamma point for the X and Y directions.\n        get_high_symmetry_points(): Get the high symmetry points for the photonic crystal lattice.\n        plot_field(target_polarization, target_k_point, target_frequency, frequency_tolerance, k_point_max_distance, periods, component, quantity, colorscale): Plot the field visualization.\n        plot_field_components(target_polarization, target_k_point, target_frequency, frequency_tolerance, k_point_max_distance, periods, quantity, colorscale): Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n        look_for_mode(polarization, k_point, freq, freq_tolerance, k_point_max_distance): Look for modes within the specified criteria.\n        find_modes_symmetries(): Find the symmetries of the modes.\n        plot_modes_vectorial_fields(modes, sizemode, names): Plot the vectorial fields of the modes.\n        plot_mode_fields_normal_to_k(mode, k): Plot the fields perpendicular to the wavevector k for the mode.\n        plot_vectorial_fields(fields, colorscales, names): Plot the vectorial fields of the modes.\n        _field_to_cones(field, colorscale, sizemode, sizeref, clim): Convert a field to cones for visualization.\n        _fields_to_cones(fields, colorscale, sizemode, sizeref, clim, colorscales): Convert a list of fields to cones for visualization.\n        _calculate_field_norm_to_k(fields, k): Calculate the components of the field perpendicular to the wavevector k.\n        _get_direction(k_vector): Determine the primary direction of the wavevector k.\n        _calculate_effective_parameter(mode): Calculate the effective parameters of the mode.\n        basic_geometry(): Define the basic geometry of the photonic crystal.\n        basic_lattice(): Define the basic lattice of the photonic crystal.\n    \"\"\"\n    def __init__(self,\n                lattice_type = None,\n                material: Crystal_Materials = None,\n                geometry: Crystal_Geometry = None, \n                num_bands: int = 6,\n                resolution = 32,\n                interp: int = 4,\n                periods: int = 3, \n                pickle_id = None, \n                k_points = None,\n                use_XY  = True\n                ):\n        \"\"\"\n        Initializes the PhotonicCrystal class with the given parameters.\n\n        Args:\n            lattice_type (str, optional): Type of the lattice. Defaults to None.\n            material (Crystal_Materials, optional): The material object. Defaults to None.\n            geometry (Crystal_Geometry, optional): The geometry object. Defaults to None.\n            num_bands (int, optional): Number of bands. Defaults to 6.\n            resolution (tuple[int, int] | int, optional): Resolution of the simulation. Defaults to 32.\n            interp (int, optional): Interpolation factor for k-points. Defaults to 4.\n            periods (int, optional): Number of periods. Defaults to 3.\n            pickle_id (str, optional): Identifier for pickling. Defaults to None.\n            k_points (list, optional): List of k-points. Defaults to None.\n            use_XY (bool, optional): Flag to use XY plane. Defaults to True.\n\n        Attributes:\n            lattice_type (str): Type of the lattice.\n            num_bands (int): Number of bands.\n            resolution (tuple[int, int] | int): Resolution of the simulation.\n            interp (int): Interpolation factor for k-points.\n            periods (int): Number of periods.\n            pickle_id (str): Identifier for pickling.\n            has_been_run (bool): Flag indicating if the simulation has been run.\n            geometry_lattice (None): Geometry lattice, set with basic lattice method.\n            k_points (list): List of k-points.\n            k_points_interpolated (list): Interpolated k-points.\n            material (Crystal_Materials): Material of the photonic crystal.\n            geometry (Crystal_Geometry): Geometry of the photonic crystal.\n            ms (None): Placeholder for ms attribute.\n            md (None): Placeholder for md attribute.\n            freqs (dict): Dictionary to store frequencies.\n            gaps (dict): Dictionary to store gaps.\n            epsilon (None): Placeholder for epsilon attribute.\n            modes (list): List to store modes.\n            use_XY (bool): Flag to use XY plane.\n        \"\"\"\n        self.lattice_type = lattice_type\n        self.num_bands = num_bands\n        self.resolution = resolution\n        self.interp = interp\n        self.periods = periods\n        self.pickle_id = pickle_id\n        self.has_been_run = False #update this manually\n\n        #this values are set with basic lattice method\n        self.geometry_lattice= None \n        self.k_points = k_points\n        if self.k_points is not None:\n            self.k_points_interpolated = mp.interpolate(self.interp, self.k_points)\n\n\n        #material\n        self.material = material if material is not None else PhotonicCrystal.basic_material()\n\n        #geometry\n        self.geometry = geometry if geometry is not None else PhotonicCrystal.basic_geometry(material = self.material)\n\n        self.ms = None\n        self.md = None\n\n        self.freqs = {}\n        self.gaps = {}\n        self.epsilon = None\n        self.modes= []\n        self.use_XY = use_XY\n\n\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Exclude the non-picklable SWIG objects\n        state['ms'] = None\n        state['md'] = None\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # You may want to reinitialize 'ms' and 'md' if needed after loading.\n        self.ms = None\n        self.md = None\n\n    def pickle_photonic_crystal(self, pickle_id):\n        \"\"\"Pickle the photonic crystal object.\n\n        Args:\n            pickle_id (str): The identifier for the pickle file.\n        \"\"\"\n        with open(f\"{pickle_id}.pkl\", \"wb\") as f:\n            pickle.dump(self, f)\n\n    @staticmethod\n    def load_photonic_crystal(pickle_id) -&gt; 'PhotonicCrystal':\n        \"\"\"Load a pickled photonic crystal object.\n\n        Args:\n            pickle_id (str): The identifier for the pickle file.\n\n        Returns:\n            PhotonicCrystal: The loaded photonic crystal object.\n        \"\"\"\n        with open(f\"{pickle_id}.pkl\", \"rb\") as f:\n            return pickle.load(f)\n\n    def set_solver(self, k_point = None):\n        \"\"\"\n        Set the mode solver for the simulation. \n        For how MPB works, it is better to call this method each time you want to run a simulation.\n        This method initializes the mode solver (ms) with the geometry, geometry lattice, \n        k-points, resolution, and number of bands. If a specific k-point is provided, \n        the solver is set up for that k-point. Otherwise, it uses the interpolated k-points.\n\n        Args:\n            k_point (mp.Vector3, optional): The k-point for the simulation. Default is None.\n\n        \"\"\"\n\n        if k_point is not None:\n            self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                                  geometry_lattice=self.geometry_lattice,\n                                  k_points=[k_point],\n                                  resolution=self.resolution,\n                                  num_bands=self.num_bands)\n        else:\n            self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                                    geometry_lattice=self.geometry_lattice,\n                                    k_points=self.k_points_interpolated,\n                                    resolution=self.resolution,\n                                    num_bands=self.num_bands)\n\n    def run_simulation(self, runner=\"run_zeven\", polarization=None):\n        \"\"\"\n        Run the simulation to calculate the frequencies and gaps.\n\n        Args:\n            runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n                runner must correspond to an MPB runner. For example:\n\n                - 'run_zeven': Run the simulation for even parity modes in z-axis.\n                - 'run_zodd': Run the simulation for odd parity modes in z-axis.\n                - 'run_tm': Run the simulation for transverse magnetic modes.\n                - 'run_te': Run the simulation for transverse electric modes.\n                - 'run': Do not consider symmetry.\n            polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n                This will be stored in the mode data.\n\n        \"\"\"\n        if self.ms is None:\n            raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n        if polarization is not None:\n            polarization = polarization\n        else:\n            if runner.startswith(\"run_\"):\n                polarization = runner[4:]\n            else:\n                polarization = runner\n\n        # This is a custom mpb output function that stores the fields and frequencies\n        def get_mode_data(ms: mpb.ModeSolver, band):\n            mode = {\n                \"h_field\": ms.get_hfield(band, bloch_phase=True),\n                \"e_field\": ms.get_efield(band, bloch_phase=True),\n                \"e_field_periodic\": ms.get_efield(band, bloch_phase=False),\n                \"h_field_periodic\": ms.get_hfield(band, bloch_phase=False),\n                \"freq\": ms.freqs[band-1],\n                \"k_point\": ms.current_k,\n                \"polarization\": polarization,\n            }\n            self.modes.append(mode)\n\n        print(self.k_points_interpolated)\n        with suppress_output():\n            getattr(self.ms, runner)(get_mode_data)\n            self.freqs[polarization] = self.ms.all_freqs\n            self.gaps[polarization] = self.ms.gap_list\n\n    def run_simulation_with_output(self, runner=\"run_zeven\", polarization=None):\n        \"\"\"\n        Run the simulation and get mode data. Mode data are not stored in the crystal object, \n        but are returned as a list of dictionaries.\n\n        Args:\n            runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n                runner must correspond to an MPB runner. For example: \n\n                - 'run_zeven': Run the simulation for even parity modes in z-axis.\n                - 'run_zodd': Run the simulation for odd parity modes in z-axis.\n                - 'run_tm': Run the simulation for transverse magnetic modes.\n                - 'run_te': Run the simulation for transverse electric modes.\n                - 'run': Do not consider symmetry.   \n\n            polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n\n        \"\"\"\n        if self.ms is None:\n            raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n        if polarization is not None:\n            polarization = polarization\n        else:\n            if runner.startswith(\"run_\"):\n                polarization = runner[4:]\n            else:\n                polarization = runner\n        modes=[]\n        # This is a custom mpb output function that stores the fields and frequencies\n        def get_mode_data(ms, band):\n            mode = {\n                \"h_field\": ms.get_hfield(band, bloch_phase=True),\n                \"e_field\": ms.get_efield(band, bloch_phase=True),\n                \"h_field_periodic\": ms.get_hfield(band, bloch_phase=False),\n                \"e_field_periodic\": ms.get_efield(band, bloch_phase=False),\n                \"freq\": ms.freqs[band-1],\n                \"k_point\": ms.current_k,\n                \"polarization\": polarization\n            }\n            modes.append(mode)\n        with suppress_output():\n            getattr(self.ms, runner)(get_mode_data, mpb.fix_efield_phase, mpb.fix_hfield_phase)\n        return modes\n\n\n\n\n    def run_dumb_simulation(self) -&gt; mpb.ModeSolver:    \n        \"\"\"\n        Run a dumb simulation.  It is the first band of the gamma point.\n        This is used to quickly extract some values from the simulation later. \n        For example it can be used to extract epsilon values.\n        \"\"\"\n\n        #run the simulation in the gamma point, find one mode\n        self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                                  geometry_lattice=self.geometry_lattice,\n                                  k_points=[mp.Vector3()],\n                                  resolution=self.resolution,\n                                  num_bands=1)\n        with suppress_output():\n            self.ms.run()\n        ms = self.ms\n        return ms\n\n    def convert_mode_fields(self, mode, periods=1)-&gt; tuple:\n        \"\"\"\n        Convert the mode fields to mpb.MPBArray for visualization.\n        Apparently this is necessary to visualize the fields if crystal is restored from pickle.\n\n        Args:\n            mode (dict): The mode dictionary.\n            periods (int): The number of periods to extract. Default is 1.\n\n        Returns:\n            tuple: A tuple containing the electric field array and the magnetic field array for visualization.\n        \"\"\"\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n            e_field =  md.convert(e_field_array)\n            h_field =  md.convert(h_field_array)            \n            return e_field, h_field \n\n\n\n    def extract_data(self, periods = 5):\n        \"\"\"\n        Extract the data from the simulation. Basically it creates a MPBData object.\n\n        Args:\n            periods (int, optional): The number of periods to extract. Default is 5.\n\n        Returns:\n            mpb.MPBData: The MPB data object.\n        \"\"\"\n\n        if self.ms is None:\n            raise ValueError(\"Solver is not set. Call set_solver() before extracting data.\")\n\n        self.md = mpb.MPBData(rectify=True, periods=periods, resolution=self.resolution)\n        return self.md\n\n\n    def plot_epsilon(self, fig=None, title='Epsilon') :\n        \"\"\"\n        Plot the epsilon of the photonic crystal interactively using Plotly.\n        Not implemented in the base class. Must be implemented in the derived class.\n\n        Args:\n            fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n            title (str, optional): The title of the plot. Default is 'Epsilon'.\n\n        Returns:\n            go.Figure: The Plotly figure object.(Not woroking yet, error is thrown)\n        \"\"\"\n        raise NotImplementedError\n\n    def plot_bands(self, polarization=\"te\", title='Bands', fig=None, color='blue')-&gt; go.Figure:\n        \"\"\"\n        Plot the bands of the photonic crystal using Plotly.\n\n        This method plots the bands for the specified polarization.\n        In Dash and Jupyter Notebook, the plot is interactive and data are shown on hover.\n\n        Args:\n            polarization (str, optional): The polarization of the bands. Default is 'te'.\n            title (str, optional): The title of the plot. Default is 'Bands'.\n            fig (go.Figure, optional): The Plotly figure to add the bands plot to. Default is None.\n            color (str, optional): The color of the bands. Default is 'blue'.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n        if self.freqs[polarization] is None:\n            print(\"Simulation not run yet. Please run the simulation first.\")\n            return\n        freqs = self.freqs[polarization]\n        gaps = self.gaps[polarization]\n\n        xs = list(range(len(freqs)))\n\n        # Extract the interpolated k-points as vectors and format them for hover and click\n        k_points_interpolated = [kp for kp in self.k_points_interpolated]\n\n        if fig is None:\n            fig = go.Figure()\n\n        # Iterate through each frequency band and add them to the plot\n        for band_index, band in enumerate(zip(*freqs)):\n            # Generate hover text with the corresponding k-point and frequency\n            hover_texts = [\n                f\"k-point: ({kp.x:.4f}, {kp.y:.4f}, {kp.z:.4f})&lt;br&gt;frequency: {f:.4f}\"\n                for kp, f in zip(k_points_interpolated, band)\n            ]\n\n\n\n            modes =[]\n            for i, kp in enumerate(k_points_interpolated):\n                mode = self.look_for_mode(polarization, kp, band[i], freq_tolerance=1e-12)\n                modes.append(mode[0])\n\n\n\n            # Add the line trace with hover info\n            fig.add_trace(go.Scatter(\n                x=xs, \n                y=band, \n                mode='lines', \n                line=dict(color=color),\n                text=hover_texts,  # Custom hover text\n                hoverinfo='text',  # Display only the custom hover text\n                customdata=[(kp.x, kp.y, kp.z, f, polarization) for kp, f in zip(k_points_interpolated, band)],  # Attach k-points and frequency as custom data\n                showlegend=False,  # Hide from legend (we\u2019ll add a separate legend entry)\n                legendgroup=polarization,  # Group traces by polarization for toggling visibility\n                visible=True,  # Initially visible\n                selectedpoints=[],  # Placeholder for selected points\n                selected=dict(marker=dict(color=\"red\", size=10)),  # Change color and size of selected points\n                unselected=dict(marker=dict(opacity=0.3))  # Make unselected points more transparent\n            ))\n\n        # Add bandgap shading (optional, grouped with the polarization for toggling visibility)\n        for gap in gaps:\n            if gap[0] &gt; 1:\n                fig.add_shape(\n                    type=\"rect\",\n                    x0=xs[0], \n                    x1=xs[-1],\n                    y0=gap[1], \n                    y1=gap[2],\n                    fillcolor=color, \n                    opacity=0.2, \n                    line_width=0,\n                    layer=\"below\",\n                    legendgroup=polarization,  # Group shading with the same polarization\n                    visible=True  # Initially visible\n                )\n\n        # Add a single legend entry for toggling visibility\n        fig.add_trace(go.Scatter(\n            x=[None], y=[None],\n            mode='lines',\n            line=dict(color=color),\n            name=f'{polarization.upper()}',  # Legend entry for the polarization\n            legendgroup=polarization,  # Group with the same polarization traces\n            showlegend=True,  # Show the legend entry\n            visible=True,  # Initially visible\n        ))\n\n        # Customize the x-axis \n        if self.use_XY is True:  # Use X and Y directions for the x-axis\n            relevant_k_points = self.get_XY_k_points_near_gamma()\n            fig.update_layout(\n                title=title,\n                xaxis=dict(\n                    tickmode='array',\n                    tickvals=[i * (len(freqs) - 3) / 2 + i for i in range(3)],\n                    ticktext=list(relevant_k_points.keys())  # Only three values, no repetition\n                ),\n                yaxis_title='frequency (c/a)',\n                showlegend=True,\n                dragmode='select',  # Enables rectangular selection\n                clickmode='event+select',  # Enable click events and selection events\n                legend=dict(  # This ensures that clicking the legend will toggle visibility\n                    itemclick=\"toggle\",  # Toggle visibility when clicked\n                    itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n                )\n            )\n        else:\n            relevant_k_points = self.get_high_symmetry_points() # Use high symmetry points for the x-axis \n                                                                # Gamma, X, M for square lattice and\n                                                                # Gamma, K, M for triangular lattice                                                   \n            fig.update_layout(\n                title=title,\n                xaxis=dict(\n                    tickmode='array',\n                    tickvals=[i * (len(freqs) - 4) / 3 + i for i in range(4)],\n                    ticktext=list(relevant_k_points.keys()) + [list(relevant_k_points.keys())[0]]  # Repeat the first element at the end\n                ),\n                yaxis_title='frequency (c/a)',\n                showlegend=True,\n                dragmode='select',  # Enables rectangular selection\n                clickmode='event+select',  # Enable click events and selection events\n                legend=dict(  # This ensures that clicking the legend will toggle visibility\n                    itemclick=\"toggle\",  # Toggle visibility when clicked\n                    itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n                )\n            )\n\n        return fig\n\n\n    def get_XY_k_points_near_gamma(self, distance = 0.1) -&gt; dict:\n        \"\"\"\n        Get the relevant k-points near the gamma point for the X and Y directions.\n        This is useful for plotting the bands with the X and Y directions on the x-axis.\n\n        Args:\n            distance (float): The distance from the gamma point. Default is 0.1.\n\n        Returns:\n            dict: A dictionary with the relevant k-points for the X and Y directions.\n            with the k-point names as keys and the k-point vectors as values.\n        \"\"\"\n\n        if distance &gt;= 0.5:\n            raise ValueError(\"Distance must be less than 0.5\")\n        relevant_k_points = {\n            'X': mp.Vector3(0.5, 0),\n            '\u0393': mp.Vector3(0, 0, 0),\n            'Y': mp.Vector3(0,0.5, 0)\n        }\n        return relevant_k_points\n\n    def get_high_symmetry_points(self) -&gt; dict:\n        \"\"\"\n        Get the high symmetry points for the photonic crystal lattice.\n        This is useful for plotting the bands with the high symmetry points on the x-axis.\n\n        Returns:\n            dict: A dictionary with the high symmetry points for the lattice.\n            with the k-point names as keys and the k-point vectors as values.\n        \"\"\"\n\n        k_high_sym = {}\n        if self.lattice_type == 'square':\n            k_high_sym = {\n                '\u0393': mp.Vector3(0, 0, 0),\n                'X': mp.Vector3(0.5, 0, 0),\n                'M': mp.Vector3(0.5, 0.5, 0)\n            }\n        elif self.lattice_type == 'triangular':\n            k_high_sym = {\n                '\u0393': mp.Vector3(0, 0, 0),\n                'K': mp.Vector3(1/3, 1/3, 0),\n                'M': mp.Vector3(0.5, 0, 0)\n            }\n        return k_high_sym\n\n\n    def plot_field(\n        self, \n        target_polarization,\n        target_k_point,\n        target_frequency,\n        frequency_tolerance=0.01,\n        k_point_max_distance=None,\n        periods=5,\n        component: int = 2,\n        quantity: str = \"real\",\n        bloch_phase: bool = True,\n        colorscale: str = \"RdBu\",\n        **kwargs\n    ): \n        \"\"\"\n        Plot the field visualization.\n        Not implemented in the base class. Must be implemented in the derived class.\n\n        Args:\n            target_polarization (str): The polarization of the mode.\n            target_k_point (tuple): The k-point of the mode.\n            target_frequency (float): The frequency of the mode.\n            frequency_tolerance (float): The tolerance for frequency similarity. Default is 0.01.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 5.\n            component (int): The component of the field to plot. Default is 2.\n            quantity (str): The quantity of the field to plot. Default is \"real\".\n            bloch_phase (bool): Whether to include the Bloch phase. Default is True.\n            colorscale (str): The colorscale for the plot. Default is \"RdBu\".\n            kwargs: Additional keyword arguments for the plot.\n\n        Returns:\n            tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.           \n\n        \"\"\"\n        raise NotImplementedError(\"plot_field method not implemented yet.\")\n\n\n    def plot_field_components(\n            self,\n            target_polarization,\n            target_k_point,\n            target_frequency,\n            frequency_tolerance=0.01,\n            k_point_max_distance=None,\n            periods: int = 1,\n            quantity: str = \"real\",\n            colorscale: str = 'RdBu',\n            ):\n\n        \"\"\"\n        Plot the field visualization.\n        Not implemented in the base class. Must be implemented in the derived class.\n\n        Args:\n            target_polarization (str): The polarization of the mode.\n            target_k_point (tuple): The k-point of the mode.\n            target_frequency (float): The frequency of the mode.\n            frequency_tolerance (float): The tolerance for frequency similarity. Default is 0.01.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 1.\n            quantity (str): The quantity of the field to plot. Default is \"real\".\n            colorscale (str): The colorscale for the plot. Default is \"RdBu\".\n\n        Returns:\n            tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.           \n        \"\"\"\n\n        raise NotImplementedError(\"plot_field_components method not implemented yet.\")\n\n\n\n\n    def look_for_mode(self, polarization, k_point, freq,  freq_tolerance=0.01, k_point_max_distance = None):\n        \"\"\"\n        Look for modes within the specified criteria.\n\n        Args:\n            polarization (str): The polarization of the mode.\n            k_point (tuple): The k-point of the mode.\n            freq (float): The frequency of the mode.\n            freq_tolerance (float): The tolerance for frequency similarity.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n\n        Returns:\n            list: A list of mode dictionaries that match the criteria.\n        \"\"\"\n\n        target_modes = []\n        if k_point_max_distance is None:\n            for mode in self.modes:\n                if mode[\"polarization\"] == polarization and mode[\"k_point\"] == k_point and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                    target_modes.append(mode)\n        else:\n            for mode in self.modes:\n                if mode[\"polarization\"] == polarization and np.linalg.norm(np.array(mode[\"k_point\"]) - np.array(k_point)) &lt;= k_point_max_distance and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                    target_modes.append(mode)\n        return target_modes\n\n\n\n    def find_modes_symmetries(self):\n        \"\"\"\n        Find the symmetries of the modes.\n        Not implemented yet. TODO\n        \"\"\"\n        raise NotImplementedError(\"find_modes_symmetries method not implemented yet.\")\n\n\n\n    def plot_modes_vectorial_fields(self, modes, sizemode=\"scaled\", names=[\"Electric Field\", \"Magnetic Field\"]):\n        \"\"\"\n        Plot the vectorial fields of the modes.\n\n        Args:\n            modes (list): The list of modes to plot.\n            sizemode (str): The sizemode for the cones. Default is 'scaled'.\n            names (list): The names of the fields. Default is ['Electric Field', 'Magnetic Field'].\n\n        Returns:\n            tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n        \"\"\"\n\n        colorscales = [\"blues\", \"reds\", \"greens\", \"purples\", \"oranges\", \"ylorbr\"]\n\n        h_fields = [mode[\"h_field\"] for mode in modes]\n        e_fields = [mode[\"e_field\"] for mode in modes]\n\n        max_norm_h = PhotonicCrystal._calculate_fields_max_norms(h_fields)\n        max_norm_e = PhotonicCrystal._calculate_fields_max_norms(e_fields)\n\n        e_sizeref = max_norm_e\n        h_sizeref = max_norm_h\n\n        e_clim = (0, max_norm_e)\n        h_clim= (0, max_norm_h)\n\n\n        e_fig = go.Figure()\n        h_fig = go.Figure()\n\n        e_cones = PhotonicCrystal._fields_to_cones(e_fields, colorscale=colorscales[0], sizemode=sizemode, sizeref=e_sizeref, clim=e_clim, colorscales=colorscales)\n        h_cones = PhotonicCrystal._fields_to_cones(h_fields, colorscale=colorscales[1], sizemode=sizemode, sizeref=h_sizeref, clim=h_clim, colorscales=colorscales) \n\n\n        for e_cone in e_cones:  \n            e_fig.add_trace(e_cone)\n        for h_cone in h_cones:\n            h_fig.add_trace(h_cone)\n\n\n        e_fig.update_layout(\n            title=names[0],\n            scene=dict(\n            xaxis=dict(title='X'),\n            yaxis=dict(title='Y'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n\n        h_fig.update_layout(\n            title=names[1],\n            scene=dict(\n            xaxis=dict(title='X'),\n            yaxis=dict(title='Y'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n\n        return e_fig, h_fig\n\n\n\n\n\n    def plot_mode_fields_normal_to_k(self, mode, k):\n        \"\"\"\n        Plot the fields perpendicular to the wavevector k for the mode.\n        To be tested, not sure if works correctly.\n\n        Args:\n            mode (dict): The mode dictionary.\n            k (numpy.ndarray): The wavevector [kx, ky, kz].\n\n        Returns:\n            tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n        \"\"\"\n        fields = [mode[\"e_field\"], mode[\"h_field\"]]\n        fields_norm_to_k = self._calculate_field_norm_to_k(fields, k)\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n\n\n        fig_e.add_trace(self._field_to_cones(fields_norm_to_k[0], colorscale=\"blues\"))\n        fig_h.add_trace(self._field_to_cones(fields_norm_to_k[1], colorscale=\"reds\"))\n        return fig_e, fig_h \n\n    def plot_vectorial_fields(self, fields, colorscales=[\"Viridis\",\"Viridis\"], names=[\"Field 1\", \"Field 2\"]): \n        \"\"\"\n        Plot the vectorial fields of the modes.\n\n        Args:\n            fields (list): The list of fields to plot.\n            colorscales (list, optional): The colorscales for the cones. Default is [\"Viridis\", \"Viridis\"].\n            names (list, optional): The names of the fields. Default is [\"Field 1\", \"Field 2\"].\n\n        Returns:\n            tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n        \"\"\"\n\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n        fig_e.add_trace(self._field_to_cones(fields[0], colorscale=colorscales[0]))\n        fig_h.add_trace(self._field_to_cones(fields[1], colorscale=colorscales[1]))\n        fig_e.update_layout(\n            title=names[0],\n            scene=dict(\n            xaxis=dict(title='Y'),\n            yaxis=dict(title='X'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n\n        fig_h.update_layout(\n            title=names[1],\n            scene=dict(\n            xaxis=dict(title='Y'),\n            yaxis=dict(title='X'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n        return fig_e, fig_h\n\n\n\n\n    @staticmethod\n    def _field_to_cones(field, colorscale=\"Viridis\", sizemode='absolute', sizeref=1, clim=(0, 1))-&gt; go.Cone:\n        \"\"\"\n        Convert a field to cones for visualization.\n        Auxiliar method for plotting the fields.\n\n        Args:\n            field (np.ndarray): The field to convert.\n            colorscale (str): The colorscale for the cones. Default is 'Viridis'.\n            sizemode (str): The sizemode for the cones. Default is 'absolute'.\n            sizeref (float): The sizeref for the cones. Default is 1.\n            clim (tuple): The color limits for the cones. Default is (0, 1). (Not used now)\n\n        Returns:\n            go.Cone: The Plotly cone object for visualization.\n        \"\"\"\n        field_x = np.real(field[..., 0])\n        field_y = np.real(field[..., 1])\n        field_z = np.real(field[..., 2])\n\n        x, y, z = np.meshgrid(np.arange(field.shape[0]), np.arange(field.shape[1]), np.arange(field.shape[2]))\n\n\n        cone = go.Cone(\n            x=x.flatten(),\n            y=y.flatten(),\n            z=z.flatten(),\n            u=field_x.flatten(),\n            v=field_y.flatten(),\n            w=field_z.flatten(),\n            anchor='tail',\n            sizemode=sizemode,\n            sizeref=sizeref,\n            colorscale=colorscale,\n            #cmin = clim[0],\n            #cmax = clim[1],\n        )\n        return cone\n\n\n    @staticmethod\n    def _fields_to_cones(fields, colorscale=\"Viridis\", sizemode='absolute', sizeref=1, clim=(0, 1), colorscales=None)-&gt; list:\n        \"\"\"\n        Convert a list of fields to cones for visualization.\n        Auxiliar method for plotting the fields.\n\n        Args:\n            fields (list): The list of fields to convert.\n            colorscale (str): The colorscale for the cones. Default is 'Viridis'.\n            sizemode (str): The sizemode for the\n        - sizeref: The sizeref for the cones. Default is 1.\n        - clim: The color limits for the cones. Default is (0, 1).\n        - colorscales: The colorscales for the cones. Default is None.\n\n        Returns:\n        - cones: The list of cones for the fields.\n        \"\"\"\n\n\n        cones = []\n\n        if colorscales is None:\n            colorscales = [\"blues\", \"reds\", \"greens\", \"purples\", \"oranges\", \"ylorbr\"]\n\n        for i, field in enumerate( fields):\n            cone = PhotonicCrystal._field_to_cones(field, colorscale=colorscales[i], sizemode=sizemode, sizeref=sizeref, clim=clim)\n            cones.append(cone)\n        return cones\n\n\n    @staticmethod\n    def _calculate_field_norm_to_k(fields, k):\n        \"\"\"\n        Calculate the components of the field perpendicular to the wavevector k for each field in the list.\n\n        Args:\n            fields (list): A list of numpy arrays, each of shape (Nx, Ny, Nz, 3), where the last dimension contains the x, y, z components of the field.\n            k (numpy.ndarray): A numpy array of shape (3,), representing the wavevector [kx, ky, kz].\n\n        Returns:\n            list: A list of numpy arrays, each of shape (Nx, Ny, Nz, 3), representing the field perpendicular to k for each input field.\n        \"\"\"\n        fields_norm_to_k = []\n\n        for field in fields:\n            # Normalize the wavevector k\n            k_norm = k / np.linalg.norm(k)\n\n            # Compute the dot product of each field vector with the normalized k\n            dot_product = np.einsum('ijkl,l-&gt;ijk', field, k_norm)  # Efficiently computes the dot product\n\n            # Compute the parallel component of the field: (dot_product * k_norm)\n            field_parallel = np.outer(dot_product, k_norm).reshape(field.shape)\n\n            # Subtract the parallel component to get the perpendicular component\n            field_norm_to_k = field - field_parallel\n\n            fields_norm_to_k.append(field_norm_to_k)\n\n        return fields_norm_to_k\n\n\n\n\n\n    @staticmethod\n    def _get_direction(k_vector):\n        \"\"\"\n        Determine the primary direction of the wavevector k.\n\n        Args:\n            k_vector: A numpy array or list of shape (3,), representing the wavevector [kx, ky, kz].\n\n        Returns:\n            int: 0 for x-direction, 1 for y-direction, 2 for z-direction.\n        \"\"\"\n        if k_vector[0] != 0 and k_vector[1] == 0 and k_vector[2] == 0:\n            return 0  # x-direction\n        elif k_vector[0] == 0 and k_vector[1] != 0 and k_vector[2] == 0:\n            return 1  # y-direction\n        elif k_vector[0] == 0 and k_vector[1] == 0 and k_vector[2] != 0:\n            return 2  # z-direction\n        else:\n            raise ValueError(\"The wavevector k does not align with a primary axis.\")\n\n\n\n\n    @staticmethod\n    def _calculate_effective_parameter(mode):\n        \"\"\"\n        Calculate the effective parameters of the mode.\n\n        Args:\n            mode (dict): The mode dictionary.\n\n        Returns:\n            dict: A dictionary with the effective parameters of the mode.\n        \"\"\"\n        raise NotImplementedError(\"calculate_effective_parameter method not implemented yet.\")  \n\n    def sweep_geometry_parameter(self, param_to_sweep: str, sweep_values: list, num_bands: int =4)-&gt; list:\n\n        \"\"\"\n        Sweep a parameter of the geometry and run simulations for each value.\n\n        Args:\n            param_to_sweep (str): The parameter to sweep.\n            sweep_values (list): The values to sweep.\n            num_bands (int, optional): The number of bands to calculate. Defaults to 4.\n\n        Returns:\n            list: A list of dictionaries with the simulation data.\n\n        \"\"\"\n        data = []\n        old_geom  = self.geometry\n        old_num_bands = self.num_bands\n\n        partial_geom = self.geometry.to_partial(exclude_key=param_to_sweep)\n        for value in sweep_values:\n            kwargs = {param_to_sweep: value}\n            self.geometry = partial_geom(**kwargs)\n            self.num_bands = num_bands\n            self.set_solver(k_point=mp.Vector3())\n            modes_zeven = self.run_simulation_with_output(runner=\"run_zeven\", polarization=\"zeven\")\n            modes_zodd  = self.run_simulation_with_output(runner=\"run_zodd\", polarization=\"zodd\")\n            data.append({\n                'parameter_value': value,\n                'modes_zeven': modes_zeven,\n                'modes_zodd': modes_zodd,\n                'parameter_name': param_to_sweep,\n            })\n        self.geometry = old_geom\n        self.num_bands = old_num_bands\n        return data\n\n\n\n    def plot_sweep_result(self, data, fig=None) -&gt; go.Figure:\n        \"\"\"\n        Plot the sweep result using Plotly.\n\n        Args:\n            data (list): The data from the sweep.\n            fig (go.Figure): The Plotly figure to add the plot to.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n\n        if fig is None:\n            fig = go.Figure()\n\n        # For each data parameter value in the x axis, add all the modes frequencies (mode[\"freq\"])in the y axis\n        num_bands = len(data[0]['modes_zeven'])\n        for i in range(num_bands):\n            modes_zeven = [d['modes_zeven'][i] for d in data]\n            modes_zodd = [d['modes_zodd'][i] for d in data]\n            param_values = [d['parameter_value'] for d in data]   \n            fig.add_trace(go.Scatter(x=param_values, y=[m[\"freq\"] for m in modes_zeven], mode='lines+markers', name=f'Band {i} TE', line=dict(color='red'), marker=dict(symbol=i, size=10)))\n            fig.add_trace(go.Scatter(x=param_values, y=[m[\"freq\"] for m in modes_zodd], mode='lines+markers', name=f'Band {i} TM', line=dict(color='blue'), marker=dict(symbol=i, size=10)))\n        fig.update_layout(\n            autosize=False,\n            width=700,\n            height=700,\n        )   \n\n        fig.update_layout(\n            xaxis_title='Parameter Value',\n            yaxis_title='Frequency (c/a)',\n            title=f\"Sweep of {data[0]['parameter_name']}\",\n            showlegend=True\n        )\n\n        return fig\n\n\n\n    @staticmethod\n    def basic_geometry(**kwargs):\n        \"\"\" \n        Define the basic geometry of the photonic crystal.\n        Must be implemented in the derived class.\n        \"\"\"\n        raise NotImplementedError\n\n\n    def basic_lattice(self, **kwargs):\n        \"\"\"\n        Define the basic lattice of the photonic crystal.\n        Must be implemented in the derived class.\n        \"\"\"\n\n        raise NotImplementedError\n\n    @staticmethod\n    def basic_material():\n        \"\"\"\n        Define the basic material of the photonic crystal.\n\n        Returns:\n            material (Crystal_Materials): Silicon Membrane. \n        \"\"\"\n\n        material = Crystal_Materials()\n        material.atom = {\"epsilon\": 1}\n        material.background = {\"epsilon\": 1}\n        material.substrate = {\"epsilon\": 1}\n        material.bulk = {\"epsilon\": 11.8}\n        return material\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal-functions","title":"Functions","text":""},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.__init__","title":"<code>__init__(lattice_type=None, material=None, geometry=None, num_bands=6, resolution=32, interp=4, periods=3, pickle_id=None, k_points=None, use_XY=True)</code>","text":"<p>Initializes the PhotonicCrystal class with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>Type of the lattice. Defaults to None.</p> <code>None</code> <code>material</code> <code>Crystal_Materials</code> <p>The material object. Defaults to None.</p> <code>None</code> <code>geometry</code> <code>Crystal_Geometry</code> <p>The geometry object. Defaults to None.</p> <code>None</code> <code>num_bands</code> <code>int</code> <p>Number of bands. Defaults to 6.</p> <code>6</code> <code>resolution</code> <code>tuple[int, int] | int</code> <p>Resolution of the simulation. Defaults to 32.</p> <code>32</code> <code>interp</code> <code>int</code> <p>Interpolation factor for k-points. Defaults to 4.</p> <code>4</code> <code>periods</code> <code>int</code> <p>Number of periods. Defaults to 3.</p> <code>3</code> <code>pickle_id</code> <code>str</code> <p>Identifier for pickling. Defaults to None.</p> <code>None</code> <code>k_points</code> <code>list</code> <p>List of k-points. Defaults to None.</p> <code>None</code> <code>use_XY</code> <code>bool</code> <p>Flag to use XY plane. Defaults to True.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>lattice_type</code> <code>str</code> <p>Type of the lattice.</p> <code>num_bands</code> <code>int</code> <p>Number of bands.</p> <code>resolution</code> <code>tuple[int, int] | int</code> <p>Resolution of the simulation.</p> <code>interp</code> <code>int</code> <p>Interpolation factor for k-points.</p> <code>periods</code> <code>int</code> <p>Number of periods.</p> <code>pickle_id</code> <code>str</code> <p>Identifier for pickling.</p> <code>has_been_run</code> <code>bool</code> <p>Flag indicating if the simulation has been run.</p> <code>geometry_lattice</code> <code>None</code> <p>Geometry lattice, set with basic lattice method.</p> <code>k_points</code> <code>list</code> <p>List of k-points.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points.</p> <code>material</code> <code>Crystal_Materials</code> <p>Material of the photonic crystal.</p> <code>geometry</code> <code>Crystal_Geometry</code> <p>Geometry of the photonic crystal.</p> <code>ms</code> <code>None</code> <p>Placeholder for ms attribute.</p> <code>md</code> <code>None</code> <p>Placeholder for md attribute.</p> <code>freqs</code> <code>dict</code> <p>Dictionary to store frequencies.</p> <code>gaps</code> <code>dict</code> <p>Dictionary to store gaps.</p> <code>epsilon</code> <code>None</code> <p>Placeholder for epsilon attribute.</p> <code>modes</code> <code>list</code> <p>List to store modes.</p> <code>use_XY</code> <code>bool</code> <p>Flag to use XY plane.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def __init__(self,\n            lattice_type = None,\n            material: Crystal_Materials = None,\n            geometry: Crystal_Geometry = None, \n            num_bands: int = 6,\n            resolution = 32,\n            interp: int = 4,\n            periods: int = 3, \n            pickle_id = None, \n            k_points = None,\n            use_XY  = True\n            ):\n    \"\"\"\n    Initializes the PhotonicCrystal class with the given parameters.\n\n    Args:\n        lattice_type (str, optional): Type of the lattice. Defaults to None.\n        material (Crystal_Materials, optional): The material object. Defaults to None.\n        geometry (Crystal_Geometry, optional): The geometry object. Defaults to None.\n        num_bands (int, optional): Number of bands. Defaults to 6.\n        resolution (tuple[int, int] | int, optional): Resolution of the simulation. Defaults to 32.\n        interp (int, optional): Interpolation factor for k-points. Defaults to 4.\n        periods (int, optional): Number of periods. Defaults to 3.\n        pickle_id (str, optional): Identifier for pickling. Defaults to None.\n        k_points (list, optional): List of k-points. Defaults to None.\n        use_XY (bool, optional): Flag to use XY plane. Defaults to True.\n\n    Attributes:\n        lattice_type (str): Type of the lattice.\n        num_bands (int): Number of bands.\n        resolution (tuple[int, int] | int): Resolution of the simulation.\n        interp (int): Interpolation factor for k-points.\n        periods (int): Number of periods.\n        pickle_id (str): Identifier for pickling.\n        has_been_run (bool): Flag indicating if the simulation has been run.\n        geometry_lattice (None): Geometry lattice, set with basic lattice method.\n        k_points (list): List of k-points.\n        k_points_interpolated (list): Interpolated k-points.\n        material (Crystal_Materials): Material of the photonic crystal.\n        geometry (Crystal_Geometry): Geometry of the photonic crystal.\n        ms (None): Placeholder for ms attribute.\n        md (None): Placeholder for md attribute.\n        freqs (dict): Dictionary to store frequencies.\n        gaps (dict): Dictionary to store gaps.\n        epsilon (None): Placeholder for epsilon attribute.\n        modes (list): List to store modes.\n        use_XY (bool): Flag to use XY plane.\n    \"\"\"\n    self.lattice_type = lattice_type\n    self.num_bands = num_bands\n    self.resolution = resolution\n    self.interp = interp\n    self.periods = periods\n    self.pickle_id = pickle_id\n    self.has_been_run = False #update this manually\n\n    #this values are set with basic lattice method\n    self.geometry_lattice= None \n    self.k_points = k_points\n    if self.k_points is not None:\n        self.k_points_interpolated = mp.interpolate(self.interp, self.k_points)\n\n\n    #material\n    self.material = material if material is not None else PhotonicCrystal.basic_material()\n\n    #geometry\n    self.geometry = geometry if geometry is not None else PhotonicCrystal.basic_geometry(material = self.material)\n\n    self.ms = None\n    self.md = None\n\n    self.freqs = {}\n    self.gaps = {}\n    self.epsilon = None\n    self.modes= []\n    self.use_XY = use_XY\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.pickle_photonic_crystal","title":"<code>pickle_photonic_crystal(pickle_id)</code>","text":"<p>Pickle the photonic crystal object.</p> <p>Parameters:</p> Name Type Description Default <code>pickle_id</code> <code>str</code> <p>The identifier for the pickle file.</p> required Source code in <code>src/photonic_crystal.py</code> <pre><code>def pickle_photonic_crystal(self, pickle_id):\n    \"\"\"Pickle the photonic crystal object.\n\n    Args:\n        pickle_id (str): The identifier for the pickle file.\n    \"\"\"\n    with open(f\"{pickle_id}.pkl\", \"wb\") as f:\n        pickle.dump(self, f)\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.load_photonic_crystal","title":"<code>load_photonic_crystal(pickle_id)</code>  <code>staticmethod</code>","text":"<p>Load a pickled photonic crystal object.</p> <p>Parameters:</p> Name Type Description Default <code>pickle_id</code> <code>str</code> <p>The identifier for the pickle file.</p> required <p>Returns:</p> Name Type Description <code>PhotonicCrystal</code> <code>PhotonicCrystal</code> <p>The loaded photonic crystal object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef load_photonic_crystal(pickle_id) -&gt; 'PhotonicCrystal':\n    \"\"\"Load a pickled photonic crystal object.\n\n    Args:\n        pickle_id (str): The identifier for the pickle file.\n\n    Returns:\n        PhotonicCrystal: The loaded photonic crystal object.\n    \"\"\"\n    with open(f\"{pickle_id}.pkl\", \"rb\") as f:\n        return pickle.load(f)\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.set_solver","title":"<code>set_solver(k_point=None)</code>","text":"<p>Set the mode solver for the simulation.  For how MPB works, it is better to call this method each time you want to run a simulation. This method initializes the mode solver (ms) with the geometry, geometry lattice,  k-points, resolution, and number of bands. If a specific k-point is provided,  the solver is set up for that k-point. Otherwise, it uses the interpolated k-points.</p> <p>Parameters:</p> Name Type Description Default <code>k_point</code> <code>Vector3</code> <p>The k-point for the simulation. Default is None.</p> <code>None</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def set_solver(self, k_point = None):\n    \"\"\"\n    Set the mode solver for the simulation. \n    For how MPB works, it is better to call this method each time you want to run a simulation.\n    This method initializes the mode solver (ms) with the geometry, geometry lattice, \n    k-points, resolution, and number of bands. If a specific k-point is provided, \n    the solver is set up for that k-point. Otherwise, it uses the interpolated k-points.\n\n    Args:\n        k_point (mp.Vector3, optional): The k-point for the simulation. Default is None.\n\n    \"\"\"\n\n    if k_point is not None:\n        self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                              geometry_lattice=self.geometry_lattice,\n                              k_points=[k_point],\n                              resolution=self.resolution,\n                              num_bands=self.num_bands)\n    else:\n        self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                                geometry_lattice=self.geometry_lattice,\n                                k_points=self.k_points_interpolated,\n                                resolution=self.resolution,\n                                num_bands=self.num_bands)\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.run_simulation","title":"<code>run_simulation(runner='run_zeven', polarization=None)</code>","text":"<p>Run the simulation to calculate the frequencies and gaps.</p> <p>Parameters:</p> Name Type Description Default <code>runner</code> <code>str</code> <p>The name of the function to run the simulation. Default is 'run_zeven'.  runner must correspond to an MPB runner. For example:</p> <ul> <li>'run_zeven': Run the simulation for even parity modes in z-axis.</li> <li>'run_zodd': Run the simulation for odd parity modes in z-axis.</li> <li>'run_tm': Run the simulation for transverse magnetic modes.</li> <li>'run_te': Run the simulation for transverse electric modes.</li> <li>'run': Do not consider symmetry.</li> </ul> <code>'run_zeven'</code> <code>polarization</code> <code>str</code> <p>The polarization of the simulation. Default is None. If None, it uses the runner name. This will be stored in the mode data.</p> <code>None</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def run_simulation(self, runner=\"run_zeven\", polarization=None):\n    \"\"\"\n    Run the simulation to calculate the frequencies and gaps.\n\n    Args:\n        runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n            runner must correspond to an MPB runner. For example:\n\n            - 'run_zeven': Run the simulation for even parity modes in z-axis.\n            - 'run_zodd': Run the simulation for odd parity modes in z-axis.\n            - 'run_tm': Run the simulation for transverse magnetic modes.\n            - 'run_te': Run the simulation for transverse electric modes.\n            - 'run': Do not consider symmetry.\n        polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n            This will be stored in the mode data.\n\n    \"\"\"\n    if self.ms is None:\n        raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n    if polarization is not None:\n        polarization = polarization\n    else:\n        if runner.startswith(\"run_\"):\n            polarization = runner[4:]\n        else:\n            polarization = runner\n\n    # This is a custom mpb output function that stores the fields and frequencies\n    def get_mode_data(ms: mpb.ModeSolver, band):\n        mode = {\n            \"h_field\": ms.get_hfield(band, bloch_phase=True),\n            \"e_field\": ms.get_efield(band, bloch_phase=True),\n            \"e_field_periodic\": ms.get_efield(band, bloch_phase=False),\n            \"h_field_periodic\": ms.get_hfield(band, bloch_phase=False),\n            \"freq\": ms.freqs[band-1],\n            \"k_point\": ms.current_k,\n            \"polarization\": polarization,\n        }\n        self.modes.append(mode)\n\n    print(self.k_points_interpolated)\n    with suppress_output():\n        getattr(self.ms, runner)(get_mode_data)\n        self.freqs[polarization] = self.ms.all_freqs\n        self.gaps[polarization] = self.ms.gap_list\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.run_simulation_with_output","title":"<code>run_simulation_with_output(runner='run_zeven', polarization=None)</code>","text":"<p>Run the simulation and get mode data. Mode data are not stored in the crystal object,  but are returned as a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>runner</code> <code>str</code> <p>The name of the function to run the simulation. Default is 'run_zeven'.  runner must correspond to an MPB runner. For example: </p> <ul> <li>'run_zeven': Run the simulation for even parity modes in z-axis.</li> <li>'run_zodd': Run the simulation for odd parity modes in z-axis.</li> <li>'run_tm': Run the simulation for transverse magnetic modes.</li> <li>'run_te': Run the simulation for transverse electric modes.</li> <li>'run': Do not consider symmetry.   </li> </ul> <code>'run_zeven'</code> <code>polarization</code> <code>str</code> <p>The polarization of the simulation. Default is None. If None, it uses the runner name.</p> <code>None</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def run_simulation_with_output(self, runner=\"run_zeven\", polarization=None):\n    \"\"\"\n    Run the simulation and get mode data. Mode data are not stored in the crystal object, \n    but are returned as a list of dictionaries.\n\n    Args:\n        runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n            runner must correspond to an MPB runner. For example: \n\n            - 'run_zeven': Run the simulation for even parity modes in z-axis.\n            - 'run_zodd': Run the simulation for odd parity modes in z-axis.\n            - 'run_tm': Run the simulation for transverse magnetic modes.\n            - 'run_te': Run the simulation for transverse electric modes.\n            - 'run': Do not consider symmetry.   \n\n        polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n\n    \"\"\"\n    if self.ms is None:\n        raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n    if polarization is not None:\n        polarization = polarization\n    else:\n        if runner.startswith(\"run_\"):\n            polarization = runner[4:]\n        else:\n            polarization = runner\n    modes=[]\n    # This is a custom mpb output function that stores the fields and frequencies\n    def get_mode_data(ms, band):\n        mode = {\n            \"h_field\": ms.get_hfield(band, bloch_phase=True),\n            \"e_field\": ms.get_efield(band, bloch_phase=True),\n            \"h_field_periodic\": ms.get_hfield(band, bloch_phase=False),\n            \"e_field_periodic\": ms.get_efield(band, bloch_phase=False),\n            \"freq\": ms.freqs[band-1],\n            \"k_point\": ms.current_k,\n            \"polarization\": polarization\n        }\n        modes.append(mode)\n    with suppress_output():\n        getattr(self.ms, runner)(get_mode_data, mpb.fix_efield_phase, mpb.fix_hfield_phase)\n    return modes\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.run_dumb_simulation","title":"<code>run_dumb_simulation()</code>","text":"<p>Run a dumb simulation.  It is the first band of the gamma point. This is used to quickly extract some values from the simulation later.  For example it can be used to extract epsilon values.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def run_dumb_simulation(self) -&gt; mpb.ModeSolver:    \n    \"\"\"\n    Run a dumb simulation.  It is the first band of the gamma point.\n    This is used to quickly extract some values from the simulation later. \n    For example it can be used to extract epsilon values.\n    \"\"\"\n\n    #run the simulation in the gamma point, find one mode\n    self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                              geometry_lattice=self.geometry_lattice,\n                              k_points=[mp.Vector3()],\n                              resolution=self.resolution,\n                              num_bands=1)\n    with suppress_output():\n        self.ms.run()\n    ms = self.ms\n    return ms\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.convert_mode_fields","title":"<code>convert_mode_fields(mode, periods=1)</code>","text":"<p>Convert the mode fields to mpb.MPBArray for visualization. Apparently this is necessary to visualize the fields if crystal is restored from pickle.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>dict</code> <p>The mode dictionary.</p> required <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the electric field array and the magnetic field array for visualization.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def convert_mode_fields(self, mode, periods=1)-&gt; tuple:\n    \"\"\"\n    Convert the mode fields to mpb.MPBArray for visualization.\n    Apparently this is necessary to visualize the fields if crystal is restored from pickle.\n\n    Args:\n        mode (dict): The mode dictionary.\n        periods (int): The number of periods to extract. Default is 1.\n\n    Returns:\n        tuple: A tuple containing the electric field array and the magnetic field array for visualization.\n    \"\"\"\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n        h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n        e_field =  md.convert(e_field_array)\n        h_field =  md.convert(h_field_array)            \n        return e_field, h_field \n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.extract_data","title":"<code>extract_data(periods=5)</code>","text":"<p>Extract the data from the simulation. Basically it creates a MPBData object.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 5.</p> <code>5</code> <p>Returns:</p> Type Description <p>mpb.MPBData: The MPB data object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def extract_data(self, periods = 5):\n    \"\"\"\n    Extract the data from the simulation. Basically it creates a MPBData object.\n\n    Args:\n        periods (int, optional): The number of periods to extract. Default is 5.\n\n    Returns:\n        mpb.MPBData: The MPB data object.\n    \"\"\"\n\n    if self.ms is None:\n        raise ValueError(\"Solver is not set. Call set_solver() before extracting data.\")\n\n    self.md = mpb.MPBData(rectify=True, periods=periods, resolution=self.resolution)\n    return self.md\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_epsilon","title":"<code>plot_epsilon(fig=None, title='Epsilon')</code>","text":"<p>Plot the epsilon of the photonic crystal interactively using Plotly. Not implemented in the base class. Must be implemented in the derived class.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the epsilon plot to. Default is None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Epsilon'.</p> <code>'Epsilon'</code> <p>Returns:</p> Type Description <p>go.Figure: The Plotly figure object.(Not woroking yet, error is thrown)</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_epsilon(self, fig=None, title='Epsilon') :\n    \"\"\"\n    Plot the epsilon of the photonic crystal interactively using Plotly.\n    Not implemented in the base class. Must be implemented in the derived class.\n\n    Args:\n        fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n        title (str, optional): The title of the plot. Default is 'Epsilon'.\n\n    Returns:\n        go.Figure: The Plotly figure object.(Not woroking yet, error is thrown)\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_bands","title":"<code>plot_bands(polarization='te', title='Bands', fig=None, color='blue')</code>","text":"<p>Plot the bands of the photonic crystal using Plotly.</p> <p>This method plots the bands for the specified polarization. In Dash and Jupyter Notebook, the plot is interactive and data are shown on hover.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>str</code> <p>The polarization of the bands. Default is 'te'.</p> <code>'te'</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Bands'.</p> <code>'Bands'</code> <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the bands plot to. Default is None.</p> <code>None</code> <code>color</code> <code>str</code> <p>The color of the bands. Default is 'blue'.</p> <code>'blue'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_bands(self, polarization=\"te\", title='Bands', fig=None, color='blue')-&gt; go.Figure:\n    \"\"\"\n    Plot the bands of the photonic crystal using Plotly.\n\n    This method plots the bands for the specified polarization.\n    In Dash and Jupyter Notebook, the plot is interactive and data are shown on hover.\n\n    Args:\n        polarization (str, optional): The polarization of the bands. Default is 'te'.\n        title (str, optional): The title of the plot. Default is 'Bands'.\n        fig (go.Figure, optional): The Plotly figure to add the bands plot to. Default is None.\n        color (str, optional): The color of the bands. Default is 'blue'.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n    if self.freqs[polarization] is None:\n        print(\"Simulation not run yet. Please run the simulation first.\")\n        return\n    freqs = self.freqs[polarization]\n    gaps = self.gaps[polarization]\n\n    xs = list(range(len(freqs)))\n\n    # Extract the interpolated k-points as vectors and format them for hover and click\n    k_points_interpolated = [kp for kp in self.k_points_interpolated]\n\n    if fig is None:\n        fig = go.Figure()\n\n    # Iterate through each frequency band and add them to the plot\n    for band_index, band in enumerate(zip(*freqs)):\n        # Generate hover text with the corresponding k-point and frequency\n        hover_texts = [\n            f\"k-point: ({kp.x:.4f}, {kp.y:.4f}, {kp.z:.4f})&lt;br&gt;frequency: {f:.4f}\"\n            for kp, f in zip(k_points_interpolated, band)\n        ]\n\n\n\n        modes =[]\n        for i, kp in enumerate(k_points_interpolated):\n            mode = self.look_for_mode(polarization, kp, band[i], freq_tolerance=1e-12)\n            modes.append(mode[0])\n\n\n\n        # Add the line trace with hover info\n        fig.add_trace(go.Scatter(\n            x=xs, \n            y=band, \n            mode='lines', \n            line=dict(color=color),\n            text=hover_texts,  # Custom hover text\n            hoverinfo='text',  # Display only the custom hover text\n            customdata=[(kp.x, kp.y, kp.z, f, polarization) for kp, f in zip(k_points_interpolated, band)],  # Attach k-points and frequency as custom data\n            showlegend=False,  # Hide from legend (we\u2019ll add a separate legend entry)\n            legendgroup=polarization,  # Group traces by polarization for toggling visibility\n            visible=True,  # Initially visible\n            selectedpoints=[],  # Placeholder for selected points\n            selected=dict(marker=dict(color=\"red\", size=10)),  # Change color and size of selected points\n            unselected=dict(marker=dict(opacity=0.3))  # Make unselected points more transparent\n        ))\n\n    # Add bandgap shading (optional, grouped with the polarization for toggling visibility)\n    for gap in gaps:\n        if gap[0] &gt; 1:\n            fig.add_shape(\n                type=\"rect\",\n                x0=xs[0], \n                x1=xs[-1],\n                y0=gap[1], \n                y1=gap[2],\n                fillcolor=color, \n                opacity=0.2, \n                line_width=0,\n                layer=\"below\",\n                legendgroup=polarization,  # Group shading with the same polarization\n                visible=True  # Initially visible\n            )\n\n    # Add a single legend entry for toggling visibility\n    fig.add_trace(go.Scatter(\n        x=[None], y=[None],\n        mode='lines',\n        line=dict(color=color),\n        name=f'{polarization.upper()}',  # Legend entry for the polarization\n        legendgroup=polarization,  # Group with the same polarization traces\n        showlegend=True,  # Show the legend entry\n        visible=True,  # Initially visible\n    ))\n\n    # Customize the x-axis \n    if self.use_XY is True:  # Use X and Y directions for the x-axis\n        relevant_k_points = self.get_XY_k_points_near_gamma()\n        fig.update_layout(\n            title=title,\n            xaxis=dict(\n                tickmode='array',\n                tickvals=[i * (len(freqs) - 3) / 2 + i for i in range(3)],\n                ticktext=list(relevant_k_points.keys())  # Only three values, no repetition\n            ),\n            yaxis_title='frequency (c/a)',\n            showlegend=True,\n            dragmode='select',  # Enables rectangular selection\n            clickmode='event+select',  # Enable click events and selection events\n            legend=dict(  # This ensures that clicking the legend will toggle visibility\n                itemclick=\"toggle\",  # Toggle visibility when clicked\n                itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n            )\n        )\n    else:\n        relevant_k_points = self.get_high_symmetry_points() # Use high symmetry points for the x-axis \n                                                            # Gamma, X, M for square lattice and\n                                                            # Gamma, K, M for triangular lattice                                                   \n        fig.update_layout(\n            title=title,\n            xaxis=dict(\n                tickmode='array',\n                tickvals=[i * (len(freqs) - 4) / 3 + i for i in range(4)],\n                ticktext=list(relevant_k_points.keys()) + [list(relevant_k_points.keys())[0]]  # Repeat the first element at the end\n            ),\n            yaxis_title='frequency (c/a)',\n            showlegend=True,\n            dragmode='select',  # Enables rectangular selection\n            clickmode='event+select',  # Enable click events and selection events\n            legend=dict(  # This ensures that clicking the legend will toggle visibility\n                itemclick=\"toggle\",  # Toggle visibility when clicked\n                itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n            )\n        )\n\n    return fig\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.get_XY_k_points_near_gamma","title":"<code>get_XY_k_points_near_gamma(distance=0.1)</code>","text":"<p>Get the relevant k-points near the gamma point for the X and Y directions. This is useful for plotting the bands with the X and Y directions on the x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance from the gamma point. Default is 0.1.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary with the relevant k-points for the X and Y directions.</p> <code>dict</code> <p>with the k-point names as keys and the k-point vectors as values.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def get_XY_k_points_near_gamma(self, distance = 0.1) -&gt; dict:\n    \"\"\"\n    Get the relevant k-points near the gamma point for the X and Y directions.\n    This is useful for plotting the bands with the X and Y directions on the x-axis.\n\n    Args:\n        distance (float): The distance from the gamma point. Default is 0.1.\n\n    Returns:\n        dict: A dictionary with the relevant k-points for the X and Y directions.\n        with the k-point names as keys and the k-point vectors as values.\n    \"\"\"\n\n    if distance &gt;= 0.5:\n        raise ValueError(\"Distance must be less than 0.5\")\n    relevant_k_points = {\n        'X': mp.Vector3(0.5, 0),\n        '\u0393': mp.Vector3(0, 0, 0),\n        'Y': mp.Vector3(0,0.5, 0)\n    }\n    return relevant_k_points\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.get_high_symmetry_points","title":"<code>get_high_symmetry_points()</code>","text":"<p>Get the high symmetry points for the photonic crystal lattice. This is useful for plotting the bands with the high symmetry points on the x-axis.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary with the high symmetry points for the lattice.</p> <code>dict</code> <p>with the k-point names as keys and the k-point vectors as values.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def get_high_symmetry_points(self) -&gt; dict:\n    \"\"\"\n    Get the high symmetry points for the photonic crystal lattice.\n    This is useful for plotting the bands with the high symmetry points on the x-axis.\n\n    Returns:\n        dict: A dictionary with the high symmetry points for the lattice.\n        with the k-point names as keys and the k-point vectors as values.\n    \"\"\"\n\n    k_high_sym = {}\n    if self.lattice_type == 'square':\n        k_high_sym = {\n            '\u0393': mp.Vector3(0, 0, 0),\n            'X': mp.Vector3(0.5, 0, 0),\n            'M': mp.Vector3(0.5, 0.5, 0)\n        }\n    elif self.lattice_type == 'triangular':\n        k_high_sym = {\n            '\u0393': mp.Vector3(0, 0, 0),\n            'K': mp.Vector3(1/3, 1/3, 0),\n            'M': mp.Vector3(0.5, 0, 0)\n        }\n    return k_high_sym\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_field","title":"<code>plot_field(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=5, component=2, quantity='real', bloch_phase=True, colorscale='RdBu', **kwargs)</code>","text":"<p>Plot the field visualization. Not implemented in the base class. Must be implemented in the derived class.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity. Default is 0.01.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 5.</p> <code>5</code> <code>component</code> <code>int</code> <p>The component of the field to plot. Default is 2.</p> <code>2</code> <code>quantity</code> <code>str</code> <p>The quantity of the field to plot. Default is \"real\".</p> <code>'real'</code> <code>bloch_phase</code> <code>bool</code> <p>Whether to include the Bloch phase. Default is True.</p> <code>True</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the plot. Default is \"RdBu\".</p> <code>'RdBu'</code> <code>kwargs</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> <p>Returns:</p> Type Description <p>tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field(\n    self, \n    target_polarization,\n    target_k_point,\n    target_frequency,\n    frequency_tolerance=0.01,\n    k_point_max_distance=None,\n    periods=5,\n    component: int = 2,\n    quantity: str = \"real\",\n    bloch_phase: bool = True,\n    colorscale: str = \"RdBu\",\n    **kwargs\n): \n    \"\"\"\n    Plot the field visualization.\n    Not implemented in the base class. Must be implemented in the derived class.\n\n    Args:\n        target_polarization (str): The polarization of the mode.\n        target_k_point (tuple): The k-point of the mode.\n        target_frequency (float): The frequency of the mode.\n        frequency_tolerance (float): The tolerance for frequency similarity. Default is 0.01.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n        periods (int): The number of periods to extract. Default is 5.\n        component (int): The component of the field to plot. Default is 2.\n        quantity (str): The quantity of the field to plot. Default is \"real\".\n        bloch_phase (bool): Whether to include the Bloch phase. Default is True.\n        colorscale (str): The colorscale for the plot. Default is \"RdBu\".\n        kwargs: Additional keyword arguments for the plot.\n\n    Returns:\n        tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.           \n\n    \"\"\"\n    raise NotImplementedError(\"plot_field method not implemented yet.\")\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_field_components","title":"<code>plot_field_components(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the field visualization. Not implemented in the base class. Must be implemented in the derived class.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity. Default is 0.01.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>quantity</code> <code>str</code> <p>The quantity of the field to plot. Default is \"real\".</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the plot. Default is \"RdBu\".</p> <code>'RdBu'</code> <p>Returns:</p> Type Description <p>tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field_components(\n        self,\n        target_polarization,\n        target_k_point,\n        target_frequency,\n        frequency_tolerance=0.01,\n        k_point_max_distance=None,\n        periods: int = 1,\n        quantity: str = \"real\",\n        colorscale: str = 'RdBu',\n        ):\n\n    \"\"\"\n    Plot the field visualization.\n    Not implemented in the base class. Must be implemented in the derived class.\n\n    Args:\n        target_polarization (str): The polarization of the mode.\n        target_k_point (tuple): The k-point of the mode.\n        target_frequency (float): The frequency of the mode.\n        frequency_tolerance (float): The tolerance for frequency similarity. Default is 0.01.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n        periods (int): The number of periods to extract. Default is 1.\n        quantity (str): The quantity of the field to plot. Default is \"real\".\n        colorscale (str): The colorscale for the plot. Default is \"RdBu\".\n\n    Returns:\n        tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.           \n    \"\"\"\n\n    raise NotImplementedError(\"plot_field_components method not implemented yet.\")\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.look_for_mode","title":"<code>look_for_mode(polarization, k_point, freq, freq_tolerance=0.01, k_point_max_distance=None)</code>","text":"<p>Look for modes within the specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>str</code> <p>The polarization of the mode.</p> required <code>k_point</code> <code>tuple</code> <p>The k-point of the mode.</p> required <code>freq</code> <code>float</code> <p>The frequency of the mode.</p> required <code>freq_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of mode dictionaries that match the criteria.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def look_for_mode(self, polarization, k_point, freq,  freq_tolerance=0.01, k_point_max_distance = None):\n    \"\"\"\n    Look for modes within the specified criteria.\n\n    Args:\n        polarization (str): The polarization of the mode.\n        k_point (tuple): The k-point of the mode.\n        freq (float): The frequency of the mode.\n        freq_tolerance (float): The tolerance for frequency similarity.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n\n    Returns:\n        list: A list of mode dictionaries that match the criteria.\n    \"\"\"\n\n    target_modes = []\n    if k_point_max_distance is None:\n        for mode in self.modes:\n            if mode[\"polarization\"] == polarization and mode[\"k_point\"] == k_point and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                target_modes.append(mode)\n    else:\n        for mode in self.modes:\n            if mode[\"polarization\"] == polarization and np.linalg.norm(np.array(mode[\"k_point\"]) - np.array(k_point)) &lt;= k_point_max_distance and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                target_modes.append(mode)\n    return target_modes\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.find_modes_symmetries","title":"<code>find_modes_symmetries()</code>","text":"<p>Find the symmetries of the modes. Not implemented yet. TODO</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def find_modes_symmetries(self):\n    \"\"\"\n    Find the symmetries of the modes.\n    Not implemented yet. TODO\n    \"\"\"\n    raise NotImplementedError(\"find_modes_symmetries method not implemented yet.\")\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_modes_vectorial_fields","title":"<code>plot_modes_vectorial_fields(modes, sizemode='scaled', names=['Electric Field', 'Magnetic Field'])</code>","text":"<p>Plot the vectorial fields of the modes.</p> <p>Parameters:</p> Name Type Description Default <code>modes</code> <code>list</code> <p>The list of modes to plot.</p> required <code>sizemode</code> <code>str</code> <p>The sizemode for the cones. Default is 'scaled'.</p> <code>'scaled'</code> <code>names</code> <code>list</code> <p>The names of the fields. Default is ['Electric Field', 'Magnetic Field'].</p> <code>['Electric Field', 'Magnetic Field']</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_modes_vectorial_fields(self, modes, sizemode=\"scaled\", names=[\"Electric Field\", \"Magnetic Field\"]):\n    \"\"\"\n    Plot the vectorial fields of the modes.\n\n    Args:\n        modes (list): The list of modes to plot.\n        sizemode (str): The sizemode for the cones. Default is 'scaled'.\n        names (list): The names of the fields. Default is ['Electric Field', 'Magnetic Field'].\n\n    Returns:\n        tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n    \"\"\"\n\n    colorscales = [\"blues\", \"reds\", \"greens\", \"purples\", \"oranges\", \"ylorbr\"]\n\n    h_fields = [mode[\"h_field\"] for mode in modes]\n    e_fields = [mode[\"e_field\"] for mode in modes]\n\n    max_norm_h = PhotonicCrystal._calculate_fields_max_norms(h_fields)\n    max_norm_e = PhotonicCrystal._calculate_fields_max_norms(e_fields)\n\n    e_sizeref = max_norm_e\n    h_sizeref = max_norm_h\n\n    e_clim = (0, max_norm_e)\n    h_clim= (0, max_norm_h)\n\n\n    e_fig = go.Figure()\n    h_fig = go.Figure()\n\n    e_cones = PhotonicCrystal._fields_to_cones(e_fields, colorscale=colorscales[0], sizemode=sizemode, sizeref=e_sizeref, clim=e_clim, colorscales=colorscales)\n    h_cones = PhotonicCrystal._fields_to_cones(h_fields, colorscale=colorscales[1], sizemode=sizemode, sizeref=h_sizeref, clim=h_clim, colorscales=colorscales) \n\n\n    for e_cone in e_cones:  \n        e_fig.add_trace(e_cone)\n    for h_cone in h_cones:\n        h_fig.add_trace(h_cone)\n\n\n    e_fig.update_layout(\n        title=names[0],\n        scene=dict(\n        xaxis=dict(title='X'),\n        yaxis=dict(title='Y'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n\n    h_fig.update_layout(\n        title=names[1],\n        scene=dict(\n        xaxis=dict(title='X'),\n        yaxis=dict(title='Y'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n\n    return e_fig, h_fig\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_mode_fields_normal_to_k","title":"<code>plot_mode_fields_normal_to_k(mode, k)</code>","text":"<p>Plot the fields perpendicular to the wavevector k for the mode. To be tested, not sure if works correctly.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>dict</code> <p>The mode dictionary.</p> required <code>k</code> <code>ndarray</code> <p>The wavevector [kx, ky, kz].</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_mode_fields_normal_to_k(self, mode, k):\n    \"\"\"\n    Plot the fields perpendicular to the wavevector k for the mode.\n    To be tested, not sure if works correctly.\n\n    Args:\n        mode (dict): The mode dictionary.\n        k (numpy.ndarray): The wavevector [kx, ky, kz].\n\n    Returns:\n        tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n    \"\"\"\n    fields = [mode[\"e_field\"], mode[\"h_field\"]]\n    fields_norm_to_k = self._calculate_field_norm_to_k(fields, k)\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n\n\n    fig_e.add_trace(self._field_to_cones(fields_norm_to_k[0], colorscale=\"blues\"))\n    fig_h.add_trace(self._field_to_cones(fields_norm_to_k[1], colorscale=\"reds\"))\n    return fig_e, fig_h \n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_vectorial_fields","title":"<code>plot_vectorial_fields(fields, colorscales=['Viridis', 'Viridis'], names=['Field 1', 'Field 2'])</code>","text":"<p>Plot the vectorial fields of the modes.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>list</code> <p>The list of fields to plot.</p> required <code>colorscales</code> <code>list</code> <p>The colorscales for the cones. Default is [\"Viridis\", \"Viridis\"].</p> <code>['Viridis', 'Viridis']</code> <code>names</code> <code>list</code> <p>The names of the fields. Default is [\"Field 1\", \"Field 2\"].</p> <code>['Field 1', 'Field 2']</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_vectorial_fields(self, fields, colorscales=[\"Viridis\",\"Viridis\"], names=[\"Field 1\", \"Field 2\"]): \n    \"\"\"\n    Plot the vectorial fields of the modes.\n\n    Args:\n        fields (list): The list of fields to plot.\n        colorscales (list, optional): The colorscales for the cones. Default is [\"Viridis\", \"Viridis\"].\n        names (list, optional): The names of the fields. Default is [\"Field 1\", \"Field 2\"].\n\n    Returns:\n        tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n    \"\"\"\n\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n    fig_e.add_trace(self._field_to_cones(fields[0], colorscale=colorscales[0]))\n    fig_h.add_trace(self._field_to_cones(fields[1], colorscale=colorscales[1]))\n    fig_e.update_layout(\n        title=names[0],\n        scene=dict(\n        xaxis=dict(title='Y'),\n        yaxis=dict(title='X'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n\n    fig_h.update_layout(\n        title=names[1],\n        scene=dict(\n        xaxis=dict(title='Y'),\n        yaxis=dict(title='X'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n    return fig_e, fig_h\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.sweep_geometry_parameter","title":"<code>sweep_geometry_parameter(param_to_sweep, sweep_values, num_bands=4)</code>","text":"<p>Sweep a parameter of the geometry and run simulations for each value.</p> <p>Parameters:</p> Name Type Description Default <code>param_to_sweep</code> <code>str</code> <p>The parameter to sweep.</p> required <code>sweep_values</code> <code>list</code> <p>The values to sweep.</p> required <code>num_bands</code> <code>int</code> <p>The number of bands to calculate. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of dictionaries with the simulation data.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def sweep_geometry_parameter(self, param_to_sweep: str, sweep_values: list, num_bands: int =4)-&gt; list:\n\n    \"\"\"\n    Sweep a parameter of the geometry and run simulations for each value.\n\n    Args:\n        param_to_sweep (str): The parameter to sweep.\n        sweep_values (list): The values to sweep.\n        num_bands (int, optional): The number of bands to calculate. Defaults to 4.\n\n    Returns:\n        list: A list of dictionaries with the simulation data.\n\n    \"\"\"\n    data = []\n    old_geom  = self.geometry\n    old_num_bands = self.num_bands\n\n    partial_geom = self.geometry.to_partial(exclude_key=param_to_sweep)\n    for value in sweep_values:\n        kwargs = {param_to_sweep: value}\n        self.geometry = partial_geom(**kwargs)\n        self.num_bands = num_bands\n        self.set_solver(k_point=mp.Vector3())\n        modes_zeven = self.run_simulation_with_output(runner=\"run_zeven\", polarization=\"zeven\")\n        modes_zodd  = self.run_simulation_with_output(runner=\"run_zodd\", polarization=\"zodd\")\n        data.append({\n            'parameter_value': value,\n            'modes_zeven': modes_zeven,\n            'modes_zodd': modes_zodd,\n            'parameter_name': param_to_sweep,\n        })\n    self.geometry = old_geom\n    self.num_bands = old_num_bands\n    return data\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_sweep_result","title":"<code>plot_sweep_result(data, fig=None)</code>","text":"<p>Plot the sweep result using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list</code> <p>The data from the sweep.</p> required <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the plot to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_sweep_result(self, data, fig=None) -&gt; go.Figure:\n    \"\"\"\n    Plot the sweep result using Plotly.\n\n    Args:\n        data (list): The data from the sweep.\n        fig (go.Figure): The Plotly figure to add the plot to.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n\n    if fig is None:\n        fig = go.Figure()\n\n    # For each data parameter value in the x axis, add all the modes frequencies (mode[\"freq\"])in the y axis\n    num_bands = len(data[0]['modes_zeven'])\n    for i in range(num_bands):\n        modes_zeven = [d['modes_zeven'][i] for d in data]\n        modes_zodd = [d['modes_zodd'][i] for d in data]\n        param_values = [d['parameter_value'] for d in data]   \n        fig.add_trace(go.Scatter(x=param_values, y=[m[\"freq\"] for m in modes_zeven], mode='lines+markers', name=f'Band {i} TE', line=dict(color='red'), marker=dict(symbol=i, size=10)))\n        fig.add_trace(go.Scatter(x=param_values, y=[m[\"freq\"] for m in modes_zodd], mode='lines+markers', name=f'Band {i} TM', line=dict(color='blue'), marker=dict(symbol=i, size=10)))\n    fig.update_layout(\n        autosize=False,\n        width=700,\n        height=700,\n    )   \n\n    fig.update_layout(\n        xaxis_title='Parameter Value',\n        yaxis_title='Frequency (c/a)',\n        title=f\"Sweep of {data[0]['parameter_name']}\",\n        showlegend=True\n    )\n\n    return fig\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.basic_geometry","title":"<code>basic_geometry(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Define the basic geometry of the photonic crystal. Must be implemented in the derived class.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_geometry(**kwargs):\n    \"\"\" \n    Define the basic geometry of the photonic crystal.\n    Must be implemented in the derived class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.basic_lattice","title":"<code>basic_lattice(**kwargs)</code>","text":"<p>Define the basic lattice of the photonic crystal. Must be implemented in the derived class.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def basic_lattice(self, **kwargs):\n    \"\"\"\n    Define the basic lattice of the photonic crystal.\n    Must be implemented in the derived class.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.PhotonicCrystal.basic_material","title":"<code>basic_material()</code>  <code>staticmethod</code>","text":"<p>Define the basic material of the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>material</code> <code>Crystal_Materials</code> <p>Silicon Membrane.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_material():\n    \"\"\"\n    Define the basic material of the photonic crystal.\n\n    Returns:\n        material (Crystal_Materials): Silicon Membrane. \n    \"\"\"\n\n    material = Crystal_Materials()\n    material.atom = {\"epsilon\": 1}\n    material.background = {\"epsilon\": 1}\n    material.substrate = {\"epsilon\": 1}\n    material.bulk = {\"epsilon\": 11.8}\n    return material\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.Crystal2D","title":"<code>Crystal2D</code>","text":"<p>               Bases: <code>PhotonicCrystal</code></p> <p>This class provides methods to define and simulate 2D photonic crystals with various lattice types and geometries.  It allows for the calculation and visualization of dielectric distributions and electromagnetic fields within the crystal.</p> <p>Attributes:</p> Name Type Description <code>geometry_lattice</code> <code>Lattice</code> <p>The lattice structure of the photonic crystal.</p> <code>k_points</code> <code>list</code> <p>List of k-points for the simulation.</p> <code>geometry</code> <code>list</code> <p>List of geometric objects defining the photonic crystal.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points for the simulation.</p> <code>epsilon</code> <code>ndarray</code> <p>Dielectric distribution of the photonic crystal.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the Crystal2D object with the specified parameters.</p> <code>plot_epsilon</code> <p>Plots the dielectric distribution interactively using Plotly.</p> <code>plot_field</code> <p>Plots the electromagnetic field distribution interactively using Plotly.</p> <code>plot_field_components</code> <p>Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> <code>basic_geometry</code> <p>Defines a basic geometry for the photonic crystal.</p> <code>ellipsoid_geometry</code> <p>Defines an ellipsoid geometry for the photonic crystal.</p> <code>advanced_material_geometry</code> <p>Defines an advanced material geometry for the photonic crystal.</p> <code>basic_lattice</code> <p>Defines the basic lattice structure for the photonic crystal.</p> <code>square_lattice</code> <p>Defines a square lattice for the photonic crystal.</p> <code>triangular_lattice</code> <p>Defines a triangular lattice for the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>class Crystal2D(PhotonicCrystal):\n    \"\"\"\n    This class provides methods to define and simulate 2D photonic crystals with various lattice types and geometries. \n    It allows for the calculation and visualization of dielectric distributions and electromagnetic fields within the crystal.\n\n    Attributes:\n        geometry_lattice (mp.Lattice): The lattice structure of the photonic crystal.\n        k_points (list): List of k-points for the simulation.\n        geometry (list): List of geometric objects defining the photonic crystal.\n        k_points_interpolated (list): Interpolated k-points for the simulation.\n        epsilon (ndarray): Dielectric distribution of the photonic crystal.\n\n    Methods:\n        __init__(self, lattice_type=None, num_bands=6, resolution=(32, 32), interp=4, periods=3, pickle_id=None, geometry=None, use_XY=True, k_point_max=0.2):\n            Initializes the Crystal2D object with the specified parameters.\n        plot_epsilon(self, fig=None, title='Epsilon', **kwargs):\n            Plots the dielectric distribution interactively using Plotly.\n        plot_field(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=5, component=2, quantity=\"real\", colorscale='RdBu'):\n            Plots the electromagnetic field distribution interactively using Plotly.\n        plot_field_components(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity=\"real\", colorscale='RdBu'):\n            Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n        basic_geometry(radius_1=0.2, eps_atom_1=1, radius_2=None, eps_atom_2=None, eps_bulk=12):\n            Defines a basic geometry for the photonic crystal.\n        ellipsoid_geometry(e1=0.2, e2=0.3, eps_atom=1, eps_bulk=12):\n            Defines an ellipsoid geometry for the photonic crystal.\n        advanced_material_geometry(radius_1=0.2, epsilon_diag=mp.Vector3(12, 12, 12), epsilon_offdiag=mp.Vector3(0, 0, 0), chi2_diag=mp.Vector3(0, 0, 0), chi3_diag=mp.Vector3(0, 0, 0), eps_atom_1=1):\n            Defines an advanced material geometry for the photonic crystal.\n        basic_lattice(lattice_type='square'):\n            Defines the basic lattice structure for the photonic crystal.\n        square_lattice():\n            Defines a square lattice for the photonic crystal.\n        triangular_lattice():\n            Defines a triangular lattice for the photonic crystal.\n    \"\"\"\n\n\n\n    def __init__(self,\n                lattice_type = \"square\",\n                material: Crystal_Materials = None,\n                geometry: Crystal2D_Geometry = None,\n                num_bands: int = 6,\n                resolution = 32,\n                interp: int = 4,\n                periods: int = 3, \n                pickle_id = None,\n                use_XY = True,\n                k_point_max = 0.2):\n\n        \"\"\"\n        Initializes the Crystal2D object with the specified parameters.\n\n        Args:\n            lattice_type (str): The type of lattice. Default is 'square' other option is 'triangular'. It determines the k-points if use_XY is False.\n            material (Crystal_Materials): The material of the photonic crystal. Default is None.\n            geometry (Crystal2D_Geometry): The geometry of the photonic crystal. Default is None.\n            num_bands (int): The number of bands to calculate. Default is 6.\n            resolution (tuple[int, int] | int): The resolution of the simulation. Default is (32, 32).\n            interp (int): The interpolation factor for k-points. Default is 4.\n            periods (int): The number of periods to simulate. Default is 3.\n            pickle_id (str): The ID for pickling the simulation. Default is None.\n            use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n            k_point_max (float): The maximum k-point value. Default is 0.2.\n        \"\"\"\n\n        super().__init__(lattice_type, material, geometry, num_bands, resolution, interp, periods, pickle_id, use_XY=use_XY)\n\n        self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n        if use_XY is True:\n            self.k_points = [\n                mp.Vector3(k_point_max, 0, 0),      # X\n                mp.Vector3(0, 0 ,0 ),       # Gamma\n                mp.Vector3(0, k_point_max,0)        # Y\n            ]\n\n        self.geometry = geometry if geometry is not None else Crystal2D.basic_geometry(material = self.material)\n        self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n\n\n\n    def plot_epsilon(self, fig=None, title='Epsilon', **kwargs)-&gt; go.Figure:\n        \"\"\"\n        Plot the dielectric distribution interactively using Plotly.\n\n        Args:\n            fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n            title (str, optional): The title of the plot. Default is 'Epsilon'.\n            **kwargs: Additional keyword arguments for Plotly.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n\n        with suppress_output():\n            if self.epsilon is None:\n                md = mpb.MPBData(rectify=True, periods=self.periods, resolution=self.resolution, lattice=self.geometry_lattice)\n                converted_eps = md.convert(self.ms.get_epsilon())\n            else:\n                converted_eps = self.epsilon\n            if fig is None:\n                fig = go.Figure()\n\n            fig.add_trace(go.Heatmap(z=converted_eps.T, colorscale='Viridis'))\n            fig.update_layout(\n                title=dict(\n                    text=f\"{title}&lt;br&gt;Dielectric Distribution\",\n                    x=0.5,\n                    y=0.95,\n                    xanchor='center',\n                    yanchor='top'\n                ),\n                coloraxis_colorbar=dict(title='$\\\\epsilon $'),\n                xaxis_showgrid=False, \n                yaxis_showgrid=False,\n                xaxis_zeroline=False, \n                yaxis_zeroline=False,\n                xaxis_visible=False, \n                yaxis_visible=False\n            )       \n        self.epsilon = converted_eps\n        print(self.epsilon)    \n        return fig\n\n    def plot_field(self,    \n                target_polarization,\n                target_k_point,\n                target_frequency,\n                frequency_tolerance=0.01,\n                k_point_max_distance=None,\n                periods=5,\n                component: int = 2,\n                bloch_phase: bool = True,\n                quantity: str = \"real\",\n                colorscale: str = \"RdBu\",\n                rectify: bool = True, \n                unwrap: bool = False,\n                phase_in_degrees: bool = False,\n    )-&gt; tuple:\n        \"\"\"\n        Plot the electromagnetic field distribution using Plotly.\n\n        Args:\n            target_polarization (str): The polarization of the mode.\n            target_k_point (tuple): The k-point of the mode.\n            target_frequency (float): The frequency of the mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 5.\n            component (int): The component of the field to plot. x=0, y=1, z=2. Default is 2.\n            bloch_phase (bool): Whether to include the Bloch phase. Default is True.\n            quantity (str): The quantity to plot. Default is 'real'.\n            colorscale (str): The colorscale for the heatmap. Default is 'RdBu'.\n            rectify (bool): Whether to rectify the field. Default is True.\n            unwrap (bool): Whether to unwrap the phase. Default is False.\n            phase_in_degrees (bool): Whether to show the phase in degrees. Default is False.\n\n        Returns:\n            tuple[go.Figure, go.Figure]: The Plotly figure objects for the electric and magnetic fields.\n        \"\"\"\n\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, frequency_tolerance, k_point_max_distance)\n        if not target_modes:\n            print(\"No modes found with the specified criteria.\")\n            return\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=rectify, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon()) \n\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (max_eps + min_eps) / 2\n        num_plots = len(target_modes)\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        for i, mode in enumerate(target_modes):\n            # Initialize visibility status: False for all traces\n            visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n            visible_status_h = [False] * (2 * num_plots)\n\n            visible_status_e[2 * i] = True  # Set the contour plot visible\n            visible_status_h[2 * i] = True\n            visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n            visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n            k_point = mode[\"k_point\"]\n            freq    = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n\n            # Take the specified component of the fields in the center of the slab\n            if bloch_phase:\n\n                e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n                h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n\n            else:\n\n                e_field = mpb.MPBArray(mode[\"e_field_periodic\"], lattice = self.ms.get_lattice(),  kpoint = mp.Vector3())\n                h_field = mpb.MPBArray(mode[\"h_field_periodic\"], lattice = self.ms.get_lattice(),  kpoint = mp.Vector3())\n                #  here the k-point is set to zero so that the phase term is basically 1.\n\n            e_field = e_field[..., component]\n            h_field = h_field[..., component]\n            e_field = np.squeeze(e_field)\n            h_field = np.squeeze(h_field)   \n\n            with suppress_output():\n                e_field = md.convert(e_field) \n                h_field = md.convert(h_field)\n\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            elif quantity == \"phase\": \n                e_field = np.angle(e_field)\n                h_field = np.angle(h_field)\n\n                if unwrap:\n                    e_field = np.unwrap(e_field, axis=0)\n                    h_field = np.unwrap(h_field, axis=0)\n                    e_field = np.unwrap(e_field, axis=1)\n                    h_field = np.unwrap(h_field, axis=1)\n\n                if phase_in_degrees:\n                    e_field = np.degrees(e_field)\n                    h_field = np.degrees(h_field)\n\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n            # Add the contour plot for permittivity (eps) at the midpoint\n            contour_e = go.Contour(z=eps.T,\n                                contours=dict(\n                                    start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                    end=midpoint,\n                                    size=0.1,  # A small size to keep it as a single contour\n                                    coloring='none'  # No filling\n                                ),\n                                line=dict(color='black', width=2),\n                                showscale=False,\n                                opacity=0.7,\n                                visible=True if i ==  0  else False)  # Only the first mode is visible\n            contour_h = contour_e  # Same contour for H-field figure\n\n            # Add the contour trace\n            fig_e.add_trace(contour_e)\n            fig_h.add_trace(contour_h)\n\n            # Add the heatmap for the electric field\n            heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n            # Add the heatmap for the magnetic field\n            heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n\n            # Add the heatmap trace\n            fig_e.add_trace(heatmap_e)\n            fig_h.add_trace(heatmap_h)\n\n            data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n            if component == 0: \n                component_str = \"x-component\"\n            elif component == 1:\n                component_str = \"y-component\"\n            else:\n                component_str = \"z-component\"\n            subtitle_e = f\"E-field, {component_str}, {quantity}\"\n            subtitle_h = f\"H-field, {component_str}, {quantity}\"\n            # Create a button for each field dataset for the dropdown\n            dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                        ]))\n            dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                        ]))\n        k_point = target_modes[0][\"k_point\"]\n        freq    = target_modes[0][\"freq\"]\n        data_str = f\"Mode {0} &lt;br&gt; k:[{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq:{freq:0.3f}, polarization:{polarization}, bloch_phase:{bloch_phase}\"\n\n        fig_e.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_e,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n\n        )\n\n        fig_h.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_h,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n        )\n\n        if quantity == \"phase\":\n            if phase_in_degrees:\n                fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Phase (degrees)')))\n                fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Phase (degrees)')))\n            else:\n                fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Phase')))\n                fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Phase')))\n\n        if quantity == \"abs\":\n            fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Amplitude')))\n            fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Amplitude')))\n\n        if quantity == \"real\":\n            fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Real')))\n            fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Real')))\n\n        if quantity == \"imag\":\n            fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Imaginary')))\n            fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Imaginary')))\n\n        return fig_e, fig_h\n\n\n    def plot_field_components(self,\n                                target_polarization,\n                                target_k_point,\n                                target_frequency,\n                                frequency_tolerance=0.01,\n                                k_point_max_distance=None,\n                                periods: int = 1,\n                                quantity: str = \"real\",\n                                bloch_phase: bool = True,\n                                colorscale: str = 'RdBu',\n                                rectify: bool = True,\n                                unwrap: bool = False,\n                                phase_in_degrees: bool = False\n                                )-&gt; tuple:\n            \"\"\"\n            Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n            For each component, the real, imaginary, absolute value, or phase can be plotted.\n\n            Args:\n                target_polarization (str): The polarization of the target mode.\n                target_k_point (tuple): The k-point of the target mode.\n                target_frequency (float): The frequency of the target mode.\n                frequency_tolerance (float): The tolerance for frequency similarity.\n                k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n                periods (int): The number of periods to extract. Default is 1.\n                quantity (str): The quantity to plot ('real', 'imag', 'phase', or 'abs'). Default is 'real'.\n                bloch_phase (bool): Whether to include the Bloch phase. Default is True.\n                colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n                rectify (bool): Whether to rectify the field. Default is True.\n                unwrap (bool): Whether to unwrap the phase. Default is False.\n                phase_in_degrees (bool): Whether to show the phase in degrees. Default is False.\n\n            Returns:\n                tuple: A tuple containing the electric field figure and the magnetic field figure.\n            \"\"\"\n\n            target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                            freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n            print(f\"Number of target modes found: {len(target_modes)}\")\n\n            with suppress_output():\n                self.run_dumb_simulation()\n                md = mpb.MPBData(rectify=rectify, periods=periods, lattice=self.ms.get_lattice())\n                eps = md.convert(self.ms.get_epsilon())\n\n            # Calculate the midpoint between min and max of the permittivity (eps)\n            min_eps, max_eps = np.min(eps), np.max(eps)\n            midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n            fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n            fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n            dropdown_buttons_e = []\n            dropdown_buttons_h = []\n\n            # Initialize lists to collect all field components across modes\n            all_e_fields = []\n            all_h_fields = []\n\n            # For each mode, collect field components\n            for i, mode in enumerate(target_modes):\n                # Get field arrays for this mode\n                if bloch_phase:\n                    e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n                    h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n                else:\n                    e_field_array = mpb.MPBArray(mode[\"e_field_periodic\"], lattice=self.ms.get_lattice(), kpoint=mp.Vector3(0,0,0))\n                    h_field_array = mpb.MPBArray(mode[\"h_field_periodic\"], lattice=self.ms.get_lattice(), kpoint=mp.Vector3(0,0,0))\n                    # Here the k-point is set to zero so that the phase term is basically 1.\n\n                # Extract field components\n                e_field_x = np.squeeze(e_field_array[..., 0])\n                e_field_y = np.squeeze(e_field_array[..., 1])\n                e_field_z = np.squeeze(e_field_array[..., 2])\n                h_field_x = np.squeeze(h_field_array[..., 0])\n                h_field_y = np.squeeze(h_field_array[..., 1])\n                h_field_z = np.squeeze(h_field_array[..., 2])\n\n                with suppress_output():\n                    e_field_x = md.convert(e_field_x)\n                    e_field_y = md.convert(e_field_y)\n                    e_field_z = md.convert(e_field_z)\n                    h_field_x = md.convert(h_field_x)\n                    h_field_y = md.convert(h_field_y)\n                    h_field_z = md.convert(h_field_z)\n\n                e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n                h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)\n\n                # Select quantity to display\n                if quantity == \"real\":\n                    e_field = np.real(e_field)\n                    h_field = np.real(h_field)\n                elif quantity == \"imag\":\n                    e_field = np.imag(e_field)\n                    h_field = np.imag(h_field)\n                elif quantity == \"abs\":\n                    e_field = np.abs(e_field)\n                    h_field = np.abs(h_field)\n                elif quantity == \"phase\":\n                    e_field = np.angle(e_field)\n                    h_field = np.angle(h_field)\n\n                    if unwrap:\n                        e_field = np.unwrap(e_field, axis=0)\n                        h_field = np.unwrap(h_field, axis=0)\n                        e_field = np.unwrap(e_field, axis=1)\n                        h_field = np.unwrap(h_field, axis=1)\n\n                    if phase_in_degrees:\n                        e_field = np.degrees(e_field)\n                        h_field = np.degrees(h_field)\n                else:\n                    raise ValueError(\"Invalid quantity. Choose 'real', 'imag', 'abs', or 'phase'.\")\n\n                # Collect all field components\n                all_e_fields.append(e_field)\n                all_h_fields.append(h_field)\n\n            # After collecting all fields, compute global min and max values\n            all_e_fields_array = np.concatenate(all_e_fields, axis=0)\n            all_h_fields_array = np.concatenate(all_h_fields, axis=0)\n\n            global_e_min, global_e_max = np.min(all_e_fields_array), np.max(all_e_fields_array)\n            global_h_min, global_h_max = np.min(all_h_fields_array), np.max(all_h_fields_array)\n\n            # Now, add the traces to the figures\n            for i, mode in enumerate(target_modes):\n                e_field = all_e_fields[i]\n                h_field = all_h_fields[i]\n\n                # Components of the E and H fields\n                Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n                Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n                # Visibility settings\n                visible_status_e = [False] * (len(target_modes) * 6)\n                visible_status_h = [False] * (len(target_modes) * 6)\n                for j in range(6):\n                    visible_status_e[6 * i + j] = True\n                    visible_status_h[6 * i + j] = True\n\n                # Add contour traces for permittivity\n                for col in range(1, 4):\n                    fig_e.add_trace(\n                        go.Contour(\n                            z=eps.T,\n                            contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'),\n                            line=dict(color='black', width=2),\n                            showscale=False,\n                            opacity=0.7,\n                            showlegend=False,\n                            visible=True if i == len(target_modes) - 1 else False\n                        ),\n                        row=1, col=col\n                    )\n                    fig_h.add_trace(\n                        go.Contour(\n                            z=eps.T,\n                            contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'),\n                            line=dict(color='black', width=2),\n                            showscale=False,\n                            opacity=0.7,\n                            showlegend=False,\n                            visible=True if i == len(target_modes) - 1 else False\n                        ),\n                        row=1, col=col\n                    )\n\n                # Add E-field components with shared coloraxis\n                fig_e.add_trace(\n                    go.Heatmap(\n                        z=Ex.T,\n                        colorscale=colorscale,\n                        showscale=False,\n                        visible=True if i == len(target_modes) - 1 else False,\n                        zsmooth=\"best\",\n                        opacity=0.8,\n                        coloraxis=\"coloraxis1\"\n                    ),\n                    row=1, col=1\n                )\n                fig_e.add_trace(\n                    go.Heatmap(\n                        z=Ey.T,\n                        colorscale=colorscale,\n                        showscale=False,\n                        visible=True if i == len(target_modes) - 1 else False,\n                        zsmooth=\"best\",\n                        opacity=0.8,\n                        coloraxis=\"coloraxis1\"\n                    ),\n                    row=1, col=2\n                )\n                fig_e.add_trace(\n                    go.Heatmap(\n                        z=Ez.T,\n                        colorscale=colorscale,\n                        showscale=True,\n                        visible=True if i == len(target_modes) - 1 else False,\n                        zsmooth=\"best\",\n                        opacity=0.8,\n                        coloraxis=\"coloraxis1\"\n                    ),\n                    row=1, col=3\n                )\n\n                # Add H-field components with shared coloraxis\n                fig_h.add_trace(\n                    go.Heatmap(\n                        z=Hx.T,\n                        colorscale=colorscale,\n                        showscale=False,\n                        visible=True if i == len(target_modes) - 1 else False,\n                        zsmooth=\"best\",\n                        opacity=0.8,\n                        coloraxis=\"coloraxis2\"\n                    ),\n                    row=1, col=1\n                )\n                fig_h.add_trace(\n                    go.Heatmap(\n                        z=Hy.T,\n                        colorscale=colorscale,\n                        showscale=False,\n                        visible=True if i == len(target_modes) - 1 else False,\n                        zsmooth=\"best\",\n                        opacity=0.8,\n                        coloraxis=\"coloraxis2\"\n                    ),\n                    row=1, col=2\n                )\n                fig_h.add_trace(\n                    go.Heatmap(\n                        z=Hz.T,\n                        colorscale=colorscale,\n                        showscale=True,\n                        visible=True if i == len(target_modes) - 1 else False,\n                        zsmooth=\"best\",\n                        opacity=0.8,\n                        coloraxis=\"coloraxis2\"\n                    ),\n                    row=1, col=3\n                )\n\n                # Dropdown data\n                k_point = mode[\"k_point\"]\n                freq = mode[\"freq\"]\n                polarization = mode[\"polarization\"]\n                mode_id = f\"Mode {i + 1}\"\n                mode_description = (\n                    f\"k:[{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq:{freq:0.3f}, \"\n                    f\"polarization:{polarization}, bloch_phase:{bloch_phase}\"\n                )\n\n                dropdown_buttons_e.append(\n                    dict(\n                        label=f\"Mode {i + 1}\",\n                        method='update',\n                        args=[\n                            {'visible': visible_status_e},\n                            {'title': f\"{mode_id}, {quantity} of E-field components &lt;br&gt;{mode_description}\"}\n                        ]\n                    )\n                )\n\n                dropdown_buttons_h.append(\n                    dict(\n                        label=f\"Mode {i + 1}\",\n                        method='update',\n                        args=[\n                            {'visible': visible_status_h},\n                            {'title': f\"{mode_id}, {quantity} of H-field components &lt;br&gt;{mode_description}\"}\n                        ]\n                    )\n                )\n\n            # Define colorbar title based on quantity\n            if quantity == \"phase\":\n                colorbar_title = 'Phase (degrees)' if phase_in_degrees else 'Phase'\n            elif quantity == \"abs\":\n                colorbar_title = 'Amplitude'\n            elif quantity == \"real\":\n                colorbar_title = 'Real'\n            elif quantity == \"imag\":\n                colorbar_title = 'Imaginary'\n\n            # Layout and color settings for fig_e\n            fig_e.update_layout(\n                title=f\"{mode_id}, {quantity} of E-field components &lt;br&gt;{mode_description}\",\n                updatemenus=[dict(active=len(target_modes) - 1, buttons=dropdown_buttons_e)],\n                coloraxis1=dict(\n                    colorbar=dict(title=colorbar_title, len=0.75, thickness=15),\n                    colorscale=colorscale,\n                    cmin=global_e_min,\n                    cmax=global_e_max\n                ),\n                width=1200,\n                height=400,\n                xaxis_showgrid=False,\n                yaxis_showgrid=False,\n                xaxis_zeroline=False,\n                yaxis_zeroline=False,\n                hovermode=\"closest\"\n            )\n\n            # Layout and color settings for fig_h\n            fig_h.update_layout(\n                title=f\"{mode_id}, {quantity} of H-field components &lt;br&gt;{mode_description}\",\n                updatemenus=[dict(active=len(target_modes) - 1, buttons=dropdown_buttons_h)],\n                coloraxis2=dict(\n                    colorbar=dict(title=colorbar_title, len=0.75, thickness=15),\n                    colorscale=colorscale,\n                    cmin=global_h_min,\n                    cmax=global_h_max\n                ),\n                width=1200,\n                height=400,\n                xaxis_showgrid=False,\n                yaxis_showgrid=False,\n                xaxis_zeroline=False,\n                yaxis_zeroline=False,\n                hovermode=\"closest\"\n            )\n\n            # Final adjustments for axes\n            fig_e.update_xaxes(showticklabels=False)\n            fig_e.update_yaxes(showticklabels=False)\n            fig_h.update_xaxes(showticklabels=False)\n            fig_h.update_yaxes(showticklabels=False)\n\n            # Ensuring aspect ratio is equal\n            fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n            fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n            fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n            fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n            fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n            fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n            # Adding axis titles\n            for fig in [fig_e, fig_h]:\n                fig.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n                fig.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n                fig.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n                fig.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n                fig.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n                fig.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n            return fig_e, fig_h\n\n\n\n\n\n\n\n\n\n\n    def basic_lattice(self, lattice_type='square')-&gt; tuple:\n        \"\"\"\n        Define the basic lattice of the photonic crystal.\n\n        Args:\n            lattice_type (str): The type of lattice. Default is 'square'. Other option is 'triangular'.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n        \"\"\"\n        if lattice_type == 'square':\n            return self.square_lattice()\n        elif lattice_type == 'triangular':\n            return self.triangular_lattice()\n        else:\n            raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n\n\n\n\n    def square_lattice(self)-&gt; tuple:\n        \"\"\"\n        Define the square lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0, 1))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # M\n            mp.Vector3(0.5, 0.5),       # X\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n\n\n    def triangular_lattice(self, flat_top = False)-&gt; tuple:\n        \"\"\"\n        Define the triangular lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n        \"\"\"\n\n        lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                            basis2=mp.Vector3(1, 0),\n                            basis1=mp.Vector3(0.5, math.sqrt(3)/2))\n\n        # lattice = mp.Lattice(size=mp.Vector3(1, 1),\n        #                         basis1=mp.Vector3(math.sqrt(3)/2, 0.5),\n        #                         basis2=mp.Vector3(math.sqrt(3)/2, -0.5))    \n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # K\n            mp.Vector3(-1./3, 1./3),    # M\n            mp.Vector3(),               # Gamma\n        ]\n\n        return lattice, k_points\n\n\n    @staticmethod\n    def basic_geometry(self, r = 0.2, material = None):\n        if material is None:\n            material = PhotonicCrystal.basic_material()\n        geometry = Crystal2D_Geometry(material = material, geometry_type='cylinder', radius=r)\n        return geometry\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.Crystal2D-functions","title":"Functions","text":""},{"location":"api/photonic_crystal/#src.photonic_crystal.Crystal2D.__init__","title":"<code>__init__(lattice_type='square', material=None, geometry=None, num_bands=6, resolution=32, interp=4, periods=3, pickle_id=None, use_XY=True, k_point_max=0.2)</code>","text":"<p>Initializes the Crystal2D object with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. Default is 'square' other option is 'triangular'. It determines the k-points if use_XY is False.</p> <code>'square'</code> <code>material</code> <code>Crystal_Materials</code> <p>The material of the photonic crystal. Default is None.</p> <code>None</code> <code>geometry</code> <code>Crystal2D_Geometry</code> <p>The geometry of the photonic crystal. Default is None.</p> <code>None</code> <code>num_bands</code> <code>int</code> <p>The number of bands to calculate. Default is 6.</p> <code>6</code> <code>resolution</code> <code>tuple[int, int] | int</code> <p>The resolution of the simulation. Default is (32, 32).</p> <code>32</code> <code>interp</code> <code>int</code> <p>The interpolation factor for k-points. Default is 4.</p> <code>4</code> <code>periods</code> <code>int</code> <p>The number of periods to simulate. Default is 3.</p> <code>3</code> <code>pickle_id</code> <code>str</code> <p>The ID for pickling the simulation. Default is None.</p> <code>None</code> <code>use_XY</code> <code>bool</code> <p>Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.</p> <code>True</code> <code>k_point_max</code> <code>float</code> <p>The maximum k-point value. Default is 0.2.</p> <code>0.2</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def __init__(self,\n            lattice_type = \"square\",\n            material: Crystal_Materials = None,\n            geometry: Crystal2D_Geometry = None,\n            num_bands: int = 6,\n            resolution = 32,\n            interp: int = 4,\n            periods: int = 3, \n            pickle_id = None,\n            use_XY = True,\n            k_point_max = 0.2):\n\n    \"\"\"\n    Initializes the Crystal2D object with the specified parameters.\n\n    Args:\n        lattice_type (str): The type of lattice. Default is 'square' other option is 'triangular'. It determines the k-points if use_XY is False.\n        material (Crystal_Materials): The material of the photonic crystal. Default is None.\n        geometry (Crystal2D_Geometry): The geometry of the photonic crystal. Default is None.\n        num_bands (int): The number of bands to calculate. Default is 6.\n        resolution (tuple[int, int] | int): The resolution of the simulation. Default is (32, 32).\n        interp (int): The interpolation factor for k-points. Default is 4.\n        periods (int): The number of periods to simulate. Default is 3.\n        pickle_id (str): The ID for pickling the simulation. Default is None.\n        use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n        k_point_max (float): The maximum k-point value. Default is 0.2.\n    \"\"\"\n\n    super().__init__(lattice_type, material, geometry, num_bands, resolution, interp, periods, pickle_id, use_XY=use_XY)\n\n    self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n    if use_XY is True:\n        self.k_points = [\n            mp.Vector3(k_point_max, 0, 0),      # X\n            mp.Vector3(0, 0 ,0 ),       # Gamma\n            mp.Vector3(0, k_point_max,0)        # Y\n        ]\n\n    self.geometry = geometry if geometry is not None else Crystal2D.basic_geometry(material = self.material)\n    self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.Crystal2D.plot_epsilon","title":"<code>plot_epsilon(fig=None, title='Epsilon', **kwargs)</code>","text":"<p>Plot the dielectric distribution interactively using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the epsilon plot to. Default is None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Epsilon'.</p> <code>'Epsilon'</code> <code>**kwargs</code> <p>Additional keyword arguments for Plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_epsilon(self, fig=None, title='Epsilon', **kwargs)-&gt; go.Figure:\n    \"\"\"\n    Plot the dielectric distribution interactively using Plotly.\n\n    Args:\n        fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n        title (str, optional): The title of the plot. Default is 'Epsilon'.\n        **kwargs: Additional keyword arguments for Plotly.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n\n    with suppress_output():\n        if self.epsilon is None:\n            md = mpb.MPBData(rectify=True, periods=self.periods, resolution=self.resolution, lattice=self.geometry_lattice)\n            converted_eps = md.convert(self.ms.get_epsilon())\n        else:\n            converted_eps = self.epsilon\n        if fig is None:\n            fig = go.Figure()\n\n        fig.add_trace(go.Heatmap(z=converted_eps.T, colorscale='Viridis'))\n        fig.update_layout(\n            title=dict(\n                text=f\"{title}&lt;br&gt;Dielectric Distribution\",\n                x=0.5,\n                y=0.95,\n                xanchor='center',\n                yanchor='top'\n            ),\n            coloraxis_colorbar=dict(title='$\\\\epsilon $'),\n            xaxis_showgrid=False, \n            yaxis_showgrid=False,\n            xaxis_zeroline=False, \n            yaxis_zeroline=False,\n            xaxis_visible=False, \n            yaxis_visible=False\n        )       \n    self.epsilon = converted_eps\n    print(self.epsilon)    \n    return fig\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.Crystal2D.plot_field","title":"<code>plot_field(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=5, component=2, bloch_phase=True, quantity='real', colorscale='RdBu', rectify=True, unwrap=False, phase_in_degrees=False)</code>","text":"<p>Plot the electromagnetic field distribution using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 5.</p> <code>5</code> <code>component</code> <code>int</code> <p>The component of the field to plot. x=0, y=1, z=2. Default is 2.</p> <code>2</code> <code>bloch_phase</code> <code>bool</code> <p>Whether to include the Bloch phase. Default is True.</p> <code>True</code> <code>quantity</code> <code>str</code> <p>The quantity to plot. Default is 'real'.</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the heatmap. Default is 'RdBu'.</p> <code>'RdBu'</code> <code>rectify</code> <code>bool</code> <p>Whether to rectify the field. Default is True.</p> <code>True</code> <code>unwrap</code> <code>bool</code> <p>Whether to unwrap the phase. Default is False.</p> <code>False</code> <code>phase_in_degrees</code> <code>bool</code> <p>Whether to show the phase in degrees. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>tuple[go.Figure, go.Figure]: The Plotly figure objects for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field(self,    \n            target_polarization,\n            target_k_point,\n            target_frequency,\n            frequency_tolerance=0.01,\n            k_point_max_distance=None,\n            periods=5,\n            component: int = 2,\n            bloch_phase: bool = True,\n            quantity: str = \"real\",\n            colorscale: str = \"RdBu\",\n            rectify: bool = True, \n            unwrap: bool = False,\n            phase_in_degrees: bool = False,\n)-&gt; tuple:\n    \"\"\"\n    Plot the electromagnetic field distribution using Plotly.\n\n    Args:\n        target_polarization (str): The polarization of the mode.\n        target_k_point (tuple): The k-point of the mode.\n        target_frequency (float): The frequency of the mode.\n        frequency_tolerance (float): The tolerance for frequency similarity.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n        periods (int): The number of periods to extract. Default is 5.\n        component (int): The component of the field to plot. x=0, y=1, z=2. Default is 2.\n        bloch_phase (bool): Whether to include the Bloch phase. Default is True.\n        quantity (str): The quantity to plot. Default is 'real'.\n        colorscale (str): The colorscale for the heatmap. Default is 'RdBu'.\n        rectify (bool): Whether to rectify the field. Default is True.\n        unwrap (bool): Whether to unwrap the phase. Default is False.\n        phase_in_degrees (bool): Whether to show the phase in degrees. Default is False.\n\n    Returns:\n        tuple[go.Figure, go.Figure]: The Plotly figure objects for the electric and magnetic fields.\n    \"\"\"\n\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n    target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, frequency_tolerance, k_point_max_distance)\n    if not target_modes:\n        print(\"No modes found with the specified criteria.\")\n        return\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=rectify, periods=periods, lattice=self.ms.get_lattice())\n        eps = md.convert(self.ms.get_epsilon()) \n\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (max_eps + min_eps) / 2\n    num_plots = len(target_modes)\n    dropdown_buttons_e = []\n    dropdown_buttons_h = []\n\n    for i, mode in enumerate(target_modes):\n        # Initialize visibility status: False for all traces\n        visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n        visible_status_h = [False] * (2 * num_plots)\n\n        visible_status_e[2 * i] = True  # Set the contour plot visible\n        visible_status_h[2 * i] = True\n        visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n        visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n        k_point = mode[\"k_point\"]\n        freq    = mode[\"freq\"]\n        polarization = mode[\"polarization\"]\n\n        # Take the specified component of the fields in the center of the slab\n        if bloch_phase:\n\n            e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n            h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n\n        else:\n\n            e_field = mpb.MPBArray(mode[\"e_field_periodic\"], lattice = self.ms.get_lattice(),  kpoint = mp.Vector3())\n            h_field = mpb.MPBArray(mode[\"h_field_periodic\"], lattice = self.ms.get_lattice(),  kpoint = mp.Vector3())\n            #  here the k-point is set to zero so that the phase term is basically 1.\n\n        e_field = e_field[..., component]\n        h_field = h_field[..., component]\n        e_field = np.squeeze(e_field)\n        h_field = np.squeeze(h_field)   \n\n        with suppress_output():\n            e_field = md.convert(e_field) \n            h_field = md.convert(h_field)\n\n        if quantity == \"real\":\n            e_field = np.real(e_field)\n            h_field = np.real(h_field)\n        elif quantity == \"imag\":\n            e_field = np.imag(e_field)\n            h_field = np.imag(h_field)\n        elif quantity == \"abs\":\n            e_field = np.abs(e_field)\n            h_field = np.abs(h_field)\n        elif quantity == \"phase\": \n            e_field = np.angle(e_field)\n            h_field = np.angle(h_field)\n\n            if unwrap:\n                e_field = np.unwrap(e_field, axis=0)\n                h_field = np.unwrap(h_field, axis=0)\n                e_field = np.unwrap(e_field, axis=1)\n                h_field = np.unwrap(h_field, axis=1)\n\n            if phase_in_degrees:\n                e_field = np.degrees(e_field)\n                h_field = np.degrees(h_field)\n\n        else:\n            raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n        # Add the contour plot for permittivity (eps) at the midpoint\n        contour_e = go.Contour(z=eps.T,\n                            contours=dict(\n                                start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                end=midpoint,\n                                size=0.1,  # A small size to keep it as a single contour\n                                coloring='none'  # No filling\n                            ),\n                            line=dict(color='black', width=2),\n                            showscale=False,\n                            opacity=0.7,\n                            visible=True if i ==  0  else False)  # Only the first mode is visible\n        contour_h = contour_e  # Same contour for H-field figure\n\n        # Add the contour trace\n        fig_e.add_trace(contour_e)\n        fig_h.add_trace(contour_h)\n\n        # Add the heatmap for the electric field\n        heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n        # Add the heatmap for the magnetic field\n        heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n\n        # Add the heatmap trace\n        fig_e.add_trace(heatmap_e)\n        fig_h.add_trace(heatmap_h)\n\n        data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n        if component == 0: \n            component_str = \"x-component\"\n        elif component == 1:\n            component_str = \"y-component\"\n        else:\n            component_str = \"z-component\"\n        subtitle_e = f\"E-field, {component_str}, {quantity}\"\n        subtitle_h = f\"H-field, {component_str}, {quantity}\"\n        # Create a button for each field dataset for the dropdown\n        dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                    ]))\n        dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                    ]))\n    k_point = target_modes[0][\"k_point\"]\n    freq    = target_modes[0][\"freq\"]\n    data_str = f\"Mode {0} &lt;br&gt; k:[{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq:{freq:0.3f}, polarization:{polarization}, bloch_phase:{bloch_phase}\"\n\n    fig_e.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_e,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n\n    )\n\n    fig_h.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_h,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n    )\n\n    if quantity == \"phase\":\n        if phase_in_degrees:\n            fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Phase (degrees)')))\n            fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Phase (degrees)')))\n        else:\n            fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Phase')))\n            fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Phase')))\n\n    if quantity == \"abs\":\n        fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Amplitude')))\n        fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Amplitude')))\n\n    if quantity == \"real\":\n        fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Real')))\n        fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Real')))\n\n    if quantity == \"imag\":\n        fig_e.update_layout(coloraxis=dict(colorbar=dict(title='Imaginary')))\n        fig_h.update_layout(coloraxis=dict(colorbar=dict(title='Imaginary')))\n\n    return fig_e, fig_h\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.Crystal2D.plot_field_components","title":"<code>plot_field_components(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', bloch_phase=True, colorscale='RdBu', rectify=True, unwrap=False, phase_in_degrees=False)</code>","text":"<p>Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales. For each component, the real, imaginary, absolute value, or phase can be plotted.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the target mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the target mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the target mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>quantity</code> <code>str</code> <p>The quantity to plot ('real', 'imag', 'phase', or 'abs'). Default is 'real'.</p> <code>'real'</code> <code>bloch_phase</code> <code>bool</code> <p>Whether to include the Bloch phase. Default is True.</p> <code>True</code> <code>colorscale</code> <code>str</code> <p>The colorscale to use for the plot. Default is 'RdBu'.</p> <code>'RdBu'</code> <code>rectify</code> <code>bool</code> <p>Whether to rectify the field. Default is True.</p> <code>True</code> <code>unwrap</code> <code>bool</code> <p>Whether to unwrap the phase. Default is False.</p> <code>False</code> <code>phase_in_degrees</code> <code>bool</code> <p>Whether to show the phase in degrees. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the electric field figure and the magnetic field figure.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field_components(self,\n                            target_polarization,\n                            target_k_point,\n                            target_frequency,\n                            frequency_tolerance=0.01,\n                            k_point_max_distance=None,\n                            periods: int = 1,\n                            quantity: str = \"real\",\n                            bloch_phase: bool = True,\n                            colorscale: str = 'RdBu',\n                            rectify: bool = True,\n                            unwrap: bool = False,\n                            phase_in_degrees: bool = False\n                            )-&gt; tuple:\n        \"\"\"\n        Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n        For each component, the real, imaginary, absolute value, or phase can be plotted.\n\n        Args:\n            target_polarization (str): The polarization of the target mode.\n            target_k_point (tuple): The k-point of the target mode.\n            target_frequency (float): The frequency of the target mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 1.\n            quantity (str): The quantity to plot ('real', 'imag', 'phase', or 'abs'). Default is 'real'.\n            bloch_phase (bool): Whether to include the Bloch phase. Default is True.\n            colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n            rectify (bool): Whether to rectify the field. Default is True.\n            unwrap (bool): Whether to unwrap the phase. Default is False.\n            phase_in_degrees (bool): Whether to show the phase in degrees. Default is False.\n\n        Returns:\n            tuple: A tuple containing the electric field figure and the magnetic field figure.\n        \"\"\"\n\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                        freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n        print(f\"Number of target modes found: {len(target_modes)}\")\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=rectify, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon())\n\n        # Calculate the midpoint between min and max of the permittivity (eps)\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n        fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n        fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        # Initialize lists to collect all field components across modes\n        all_e_fields = []\n        all_h_fields = []\n\n        # For each mode, collect field components\n        for i, mode in enumerate(target_modes):\n            # Get field arrays for this mode\n            if bloch_phase:\n                e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n                h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            else:\n                e_field_array = mpb.MPBArray(mode[\"e_field_periodic\"], lattice=self.ms.get_lattice(), kpoint=mp.Vector3(0,0,0))\n                h_field_array = mpb.MPBArray(mode[\"h_field_periodic\"], lattice=self.ms.get_lattice(), kpoint=mp.Vector3(0,0,0))\n                # Here the k-point is set to zero so that the phase term is basically 1.\n\n            # Extract field components\n            e_field_x = np.squeeze(e_field_array[..., 0])\n            e_field_y = np.squeeze(e_field_array[..., 1])\n            e_field_z = np.squeeze(e_field_array[..., 2])\n            h_field_x = np.squeeze(h_field_array[..., 0])\n            h_field_y = np.squeeze(h_field_array[..., 1])\n            h_field_z = np.squeeze(h_field_array[..., 2])\n\n            with suppress_output():\n                e_field_x = md.convert(e_field_x)\n                e_field_y = md.convert(e_field_y)\n                e_field_z = md.convert(e_field_z)\n                h_field_x = md.convert(h_field_x)\n                h_field_y = md.convert(h_field_y)\n                h_field_z = md.convert(h_field_z)\n\n            e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n            h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)\n\n            # Select quantity to display\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            elif quantity == \"phase\":\n                e_field = np.angle(e_field)\n                h_field = np.angle(h_field)\n\n                if unwrap:\n                    e_field = np.unwrap(e_field, axis=0)\n                    h_field = np.unwrap(h_field, axis=0)\n                    e_field = np.unwrap(e_field, axis=1)\n                    h_field = np.unwrap(h_field, axis=1)\n\n                if phase_in_degrees:\n                    e_field = np.degrees(e_field)\n                    h_field = np.degrees(h_field)\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', 'abs', or 'phase'.\")\n\n            # Collect all field components\n            all_e_fields.append(e_field)\n            all_h_fields.append(h_field)\n\n        # After collecting all fields, compute global min and max values\n        all_e_fields_array = np.concatenate(all_e_fields, axis=0)\n        all_h_fields_array = np.concatenate(all_h_fields, axis=0)\n\n        global_e_min, global_e_max = np.min(all_e_fields_array), np.max(all_e_fields_array)\n        global_h_min, global_h_max = np.min(all_h_fields_array), np.max(all_h_fields_array)\n\n        # Now, add the traces to the figures\n        for i, mode in enumerate(target_modes):\n            e_field = all_e_fields[i]\n            h_field = all_h_fields[i]\n\n            # Components of the E and H fields\n            Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n            Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n            # Visibility settings\n            visible_status_e = [False] * (len(target_modes) * 6)\n            visible_status_h = [False] * (len(target_modes) * 6)\n            for j in range(6):\n                visible_status_e[6 * i + j] = True\n                visible_status_h[6 * i + j] = True\n\n            # Add contour traces for permittivity\n            for col in range(1, 4):\n                fig_e.add_trace(\n                    go.Contour(\n                        z=eps.T,\n                        contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'),\n                        line=dict(color='black', width=2),\n                        showscale=False,\n                        opacity=0.7,\n                        showlegend=False,\n                        visible=True if i == len(target_modes) - 1 else False\n                    ),\n                    row=1, col=col\n                )\n                fig_h.add_trace(\n                    go.Contour(\n                        z=eps.T,\n                        contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'),\n                        line=dict(color='black', width=2),\n                        showscale=False,\n                        opacity=0.7,\n                        showlegend=False,\n                        visible=True if i == len(target_modes) - 1 else False\n                    ),\n                    row=1, col=col\n                )\n\n            # Add E-field components with shared coloraxis\n            fig_e.add_trace(\n                go.Heatmap(\n                    z=Ex.T,\n                    colorscale=colorscale,\n                    showscale=False,\n                    visible=True if i == len(target_modes) - 1 else False,\n                    zsmooth=\"best\",\n                    opacity=0.8,\n                    coloraxis=\"coloraxis1\"\n                ),\n                row=1, col=1\n            )\n            fig_e.add_trace(\n                go.Heatmap(\n                    z=Ey.T,\n                    colorscale=colorscale,\n                    showscale=False,\n                    visible=True if i == len(target_modes) - 1 else False,\n                    zsmooth=\"best\",\n                    opacity=0.8,\n                    coloraxis=\"coloraxis1\"\n                ),\n                row=1, col=2\n            )\n            fig_e.add_trace(\n                go.Heatmap(\n                    z=Ez.T,\n                    colorscale=colorscale,\n                    showscale=True,\n                    visible=True if i == len(target_modes) - 1 else False,\n                    zsmooth=\"best\",\n                    opacity=0.8,\n                    coloraxis=\"coloraxis1\"\n                ),\n                row=1, col=3\n            )\n\n            # Add H-field components with shared coloraxis\n            fig_h.add_trace(\n                go.Heatmap(\n                    z=Hx.T,\n                    colorscale=colorscale,\n                    showscale=False,\n                    visible=True if i == len(target_modes) - 1 else False,\n                    zsmooth=\"best\",\n                    opacity=0.8,\n                    coloraxis=\"coloraxis2\"\n                ),\n                row=1, col=1\n            )\n            fig_h.add_trace(\n                go.Heatmap(\n                    z=Hy.T,\n                    colorscale=colorscale,\n                    showscale=False,\n                    visible=True if i == len(target_modes) - 1 else False,\n                    zsmooth=\"best\",\n                    opacity=0.8,\n                    coloraxis=\"coloraxis2\"\n                ),\n                row=1, col=2\n            )\n            fig_h.add_trace(\n                go.Heatmap(\n                    z=Hz.T,\n                    colorscale=colorscale,\n                    showscale=True,\n                    visible=True if i == len(target_modes) - 1 else False,\n                    zsmooth=\"best\",\n                    opacity=0.8,\n                    coloraxis=\"coloraxis2\"\n                ),\n                row=1, col=3\n            )\n\n            # Dropdown data\n            k_point = mode[\"k_point\"]\n            freq = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n            mode_id = f\"Mode {i + 1}\"\n            mode_description = (\n                f\"k:[{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq:{freq:0.3f}, \"\n                f\"polarization:{polarization}, bloch_phase:{bloch_phase}\"\n            )\n\n            dropdown_buttons_e.append(\n                dict(\n                    label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[\n                        {'visible': visible_status_e},\n                        {'title': f\"{mode_id}, {quantity} of E-field components &lt;br&gt;{mode_description}\"}\n                    ]\n                )\n            )\n\n            dropdown_buttons_h.append(\n                dict(\n                    label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[\n                        {'visible': visible_status_h},\n                        {'title': f\"{mode_id}, {quantity} of H-field components &lt;br&gt;{mode_description}\"}\n                    ]\n                )\n            )\n\n        # Define colorbar title based on quantity\n        if quantity == \"phase\":\n            colorbar_title = 'Phase (degrees)' if phase_in_degrees else 'Phase'\n        elif quantity == \"abs\":\n            colorbar_title = 'Amplitude'\n        elif quantity == \"real\":\n            colorbar_title = 'Real'\n        elif quantity == \"imag\":\n            colorbar_title = 'Imaginary'\n\n        # Layout and color settings for fig_e\n        fig_e.update_layout(\n            title=f\"{mode_id}, {quantity} of E-field components &lt;br&gt;{mode_description}\",\n            updatemenus=[dict(active=len(target_modes) - 1, buttons=dropdown_buttons_e)],\n            coloraxis1=dict(\n                colorbar=dict(title=colorbar_title, len=0.75, thickness=15),\n                colorscale=colorscale,\n                cmin=global_e_min,\n                cmax=global_e_max\n            ),\n            width=1200,\n            height=400,\n            xaxis_showgrid=False,\n            yaxis_showgrid=False,\n            xaxis_zeroline=False,\n            yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        # Layout and color settings for fig_h\n        fig_h.update_layout(\n            title=f\"{mode_id}, {quantity} of H-field components &lt;br&gt;{mode_description}\",\n            updatemenus=[dict(active=len(target_modes) - 1, buttons=dropdown_buttons_h)],\n            coloraxis2=dict(\n                colorbar=dict(title=colorbar_title, len=0.75, thickness=15),\n                colorscale=colorscale,\n                cmin=global_h_min,\n                cmax=global_h_max\n            ),\n            width=1200,\n            height=400,\n            xaxis_showgrid=False,\n            yaxis_showgrid=False,\n            xaxis_zeroline=False,\n            yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        # Final adjustments for axes\n        fig_e.update_xaxes(showticklabels=False)\n        fig_e.update_yaxes(showticklabels=False)\n        fig_h.update_xaxes(showticklabels=False)\n        fig_h.update_yaxes(showticklabels=False)\n\n        # Ensuring aspect ratio is equal\n        fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n        fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n        # Adding axis titles\n        for fig in [fig_e, fig_h]:\n            fig.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n            fig.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n            fig.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n            fig.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n            fig.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n            fig.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n        return fig_e, fig_h\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.Crystal2D.basic_lattice","title":"<code>basic_lattice(lattice_type='square')</code>","text":"<p>Define the basic lattice of the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. Default is 'square'. Other option is 'triangular'.</p> <code>'square'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def basic_lattice(self, lattice_type='square')-&gt; tuple:\n    \"\"\"\n    Define the basic lattice of the photonic crystal.\n\n    Args:\n        lattice_type (str): The type of lattice. Default is 'square'. Other option is 'triangular'.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n    \"\"\"\n    if lattice_type == 'square':\n        return self.square_lattice()\n    elif lattice_type == 'triangular':\n        return self.triangular_lattice()\n    else:\n        raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.Crystal2D.square_lattice","title":"<code>square_lattice()</code>","text":"<p>Define the square lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def square_lattice(self)-&gt; tuple:\n    \"\"\"\n    Define the square lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0, 1))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # M\n        mp.Vector3(0.5, 0.5),       # X\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.Crystal2D.triangular_lattice","title":"<code>triangular_lattice(flat_top=False)</code>","text":"<p>Define the triangular lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def triangular_lattice(self, flat_top = False)-&gt; tuple:\n    \"\"\"\n    Define the triangular lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n    \"\"\"\n\n    lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                        basis2=mp.Vector3(1, 0),\n                        basis1=mp.Vector3(0.5, math.sqrt(3)/2))\n\n    # lattice = mp.Lattice(size=mp.Vector3(1, 1),\n    #                         basis1=mp.Vector3(math.sqrt(3)/2, 0.5),\n    #                         basis2=mp.Vector3(math.sqrt(3)/2, -0.5))    \n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # K\n        mp.Vector3(-1./3, 1./3),    # M\n        mp.Vector3(),               # Gamma\n    ]\n\n    return lattice, k_points\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab","title":"<code>CrystalSlab</code>","text":"<p>               Bases: <code>PhotonicCrystal</code></p> <p>CrystalSlab class represents a photonic crystal slab structure, inheriting from the PhotonicCrystal class. This class provides methods to define the lattice, geometry, and to plot various properties of the photonic crystal slab. Geometries can be added using mpb functions such as Cylinder, Ellipsoid, etc.</p> <p>Attributes:</p> Name Type Description <code>geometry_lattice</code> <code>Lattice</code> <p>The lattice structure of the photonic crystal.</p> <code>k_points</code> <code>list</code> <p>List of k-points for the simulation.</p> <code>geometry</code> <code>list</code> <p>List of geometric objects defining the photonic crystal.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points for the simulation.</p> <code>epsilon</code> <code>ndarray</code> <p>Dielectric function values obtained from the simulation.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the CrystalSlab object with the given parameters.</p> <code>plot_epsilon</code> <p>Plots the epsilon values obtained from the simulation using Plotly.</p> <code>basic_lattice</code> <p>Defines the basic lattice structure for the photonic crystal.</p> <code>square_lattice</code> <p>Defines the square lattice for the photonic crystal.</p> <code>triangular_lattice</code> <p>Defines the triangular lattice for the photonic crystal.</p> <code>basic_geometry</code> <p>Defines the basic geometry for the photonic crystal.</p> <code>plot_field</code> <p>Plots the field for a specific mode based on the given parameters.</p> <code>plot_field_components</code> <p>Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>class CrystalSlab(PhotonicCrystal):\n    \"\"\"\n    CrystalSlab class represents a photonic crystal slab structure, inheriting from the PhotonicCrystal class.\n    This class provides methods to define the lattice, geometry, and to plot various properties of the photonic crystal slab.\n    Geometries can be added using mpb functions such as Cylinder, Ellipsoid, etc.\n\n\n    Attributes:\n        geometry_lattice (mp.Lattice): The lattice structure of the photonic crystal.\n        k_points (list): List of k-points for the simulation.\n        geometry (list): List of geometric objects defining the photonic crystal.\n        k_points_interpolated (list): Interpolated k-points for the simulation.\n        epsilon (np.ndarray): Dielectric function values obtained from the simulation.\n\n    Methods:\n        __init__(self, lattice_type=None, num_bands=4, resolution=mp.Vector3(32,32,16), interp=2, periods=3, pickle_id=None, geometry=None, use_XY=True, k_point_max=0.2):\n            Initializes the CrystalSlab object with the given parameters.\n        plot_epsilon(self, fig=None, opacity=0.3, colorscale='PuBuGn', override_resolution_with=None, periods=1):\n            Plots the epsilon values obtained from the simulation using Plotly.\n        basic_lattice(lattice_type='square', height_supercell=4):\n            Defines the basic lattice structure for the photonic crystal.\n        square_lattice(height_supercell=4):\n            Defines the square lattice for the photonic crystal.\n        triangular_lattice(height_supercell=4):\n            Defines the triangular lattice for the photonic crystal.\n        basic_geometry(radius=0.2, material=None):\n            Defines the basic geometry for the photonic crystal.\n        plot_field(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, component=2, quantity='real', colorscale='RdBu'):\n            Plots the field for a specific mode based on the given parameters.\n        plot_field_components(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', colorscale='RdBu'):\n            Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n    \"\"\"\n\n    def __init__(self,\n                lattice_type = \"square\",\n                material: Crystal_Materials = None,\n                geometry = None, \n                num_bands: int = 4,\n                resolution = mp.Vector3(32,32,16),\n                interp: int =2,\n                periods: int =3, \n                pickle_id = None,\n                use_XY = True,\n                k_point_max = 0.2):\n        \"\"\"\n        Initializes the CrystalSlab object with the given parameters.\n\n        Args:\n            lattice_type (str): The type of lattice. It can be 'square' or 'triangular'. Default is 'square'.\n            material (Crystal_Materials): The material object for the photonic crystal. Default is None.\n            geometry (CrystalSlab_Geometry): The geometry of the photonic crystal. Default is None. If it is none, the basic geometry is used.\n            num_bands (int): The number of bands to calculate. Default is 4.\n            resolution (mp.Vector3): The resolution of the simulation. Default is mp.Vector3(32, 32, 16).\n            interp (int): The interpolation factor for k-points. Default is 2.\n            periods (int): The number of periods to use in some plotting functions. Default is 3.\n            pickle_id (str): The ID for pickling the simulation. Default is None.\n            use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n            k_point_max (float): The maximum k-point value. Default is 0.2.\n        \"\"\"\n\n\n        super().__init__(lattice_type, material,geometry, num_bands, resolution, interp, periods, pickle_id, use_XY)\n\n\n        self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n        if use_XY is True: \n            self.k_points = [\n                mp.Vector3(k_point_max, 0, 0),      # X\n                mp.Vector3(0, 0 ,0 ),               # Gamma\n                mp.Vector3(0, k_point_max, 0)       # Y\n            ]\n        self.geometry = geometry if geometry is not None else self.basic_geometry()\n        self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n\n    def plot_epsilon(self,\n                    fig=None, \n                    opacity=0.3, \n                    colorscale='PuBuGn', \n                    override_resolution_with = None, \n                    periods = 1,\n                    )-&gt; go.Figure:\n        \"\"\"\n        Plot the epsilon values obtained from the simulation using Plotly.\n\n        Args:\n            fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n            opacity (float, optional): The opacity of the plot. Default is 0.3.\n            colorscale (str, optional): The colorscale for the plot. Default is 'PuBuGn'.\n            override_resolution_with (int, optional): The resolution to use for plotting. You can change the resolution just for the plot, but the simulation will still use the value set in the __init__ method. Default is None.\n            periods (int, optional): The number of periods to plot. Default is 1.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n\n        if self.epsilon is None:\n\n            if override_resolution_with is None:\n                resolution = self.resolution\n            else:\n                resolution = override_resolution_with\n            md = mpb.MPBData(rectify=True, periods=periods, resolution=resolution)\n\n\n            converted_eps = md.convert(self.ms.get_epsilon())\n        else:\n            converted_eps = self.epsilon\n        self.epsilon = converted_eps\n        if fig is None:\n            fig = go.Figure()\n\n        z_points = converted_eps.shape[2]//periods\n        z_mid = converted_eps.shape[2]//2\n        epsilon = converted_eps[..., z_mid-z_points//2:z_mid+z_points//2-1] \n        print(epsilon.shape)\n        epsilon = np.transpose(epsilon,(1,0,2)) \n\n        # Create indices for x, y, z axes (meshgrid)\n        x, y, z = np.meshgrid(np.arange(epsilon.shape[0]),\n                            np.arange(epsilon.shape[1]),\n                            np.arange(epsilon.shape[2]))\n\n        # Flatten the arrays for Plotly\n        x_flat = x.flatten()\n        y_flat = y.flatten()\n        z_flat = z.flatten()\n        epsilon_flat = epsilon.flatten()\n\n        # Get the minimum and maximum values from the epsilon array (ensure they are floats)\n        isomin_value = float(np.min(epsilon_flat))\n        isomax_value = float(np.max(epsilon_flat))\n\n        # Create the 3D volume plot using Plotly\n        fig = go.Figure(data=go.Volume(\n            x=x_flat, y=y_flat, z=z_flat,\n            value=epsilon_flat,  # Use the dielectric function values\n            isomin=isomin_value,\n            isomax=isomax_value,\n            opacity=opacity,  # Adjust opacity to visualize internal structure\n            surface_count=3,  # Number of surfaces to display\n            colorscale=colorscale,  # Color scale for the dielectric function\n            colorbar=dict(title='Dielectric Constant')\n        ))\n\n        # Add layout details\n        fig.update_layout(\n            title='3D Volume Plot of Dielectric Function',\n            scene=dict(\n            xaxis=dict(title='X', visible=True),\n            yaxis=dict(title='Y', visible=True),\n            zaxis=dict(title='Z', visible=True),\n            )\n        )\n\n        fig.update_layout(height=800, width=600)\n\n        return fig\n\n\n    def basic_lattice(self, lattice_type='square', height_supercell=4)-&gt; tuple:\n        \"\"\"\n        Define the basic lattice structure for the photonic crystal.\n\n        Args:\n            lattice_type (str): The type of lattice. Default is 'square'.\n            height_supercell (int): The height of the supercell. Default is 4.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n        \"\"\"\n\n        if lattice_type == 'square':\n            return self.square_lattice(height_supercell=height_supercell)\n        elif lattice_type == 'triangular':\n            return self.triangular_lattice(height_supercell=height_supercell)\n        else:\n            raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n\n\n    def square_lattice(self, height_supercell=4)-&gt; tuple:\n        \"\"\"\n        Define the square lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0, 1))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # M\n            mp.Vector3(0.5, 0.5),       # X\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n\n    def triangular_lattice(self, height_supercell=4)-&gt; tuple:\n        \"\"\"\n        Define the triangular lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # K\n            mp.Vector3(-1./3, 1./3),    # M\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n    @staticmethod \n    def basic_geometry(\n        radius = 0.2,\n        material: Crystal_Materials = None,\n    ):\n        \"\"\"\n        Define the basic geometry for the photonic crystal slab.\n\n        Args:\n            radius (float): The radius of the cylinder. Default is 0.2.\n            material (Crystal_Materials): The material object for the photonic crystal. Default is None.\n\n        Returns:\n            CrystalSlab_Geometry: The geometry object representing the photonic crystal slab.\n        \"\"\"\n\n        if material is None:\n            material = PhotonicCrystal.basic_material()\n        geometry = CrystalSlab_Geometry(material = material, geometry_type='cylinder', radius = radius)\n        return geometry\n\n\n\n\n    def plot_field(self, \n            target_polarization, \n            target_k_point, \n            target_frequency, \n            frequency_tolerance = 0.01, \n            k_point_max_distance = None,\n            periods: int=1, \n            component: int = 2, \n            bloch_phase: bool = True,\n            quantity: str = \"real\", \n            colorscale: str = 'RdBu',                  \n            ):\n        \"\"\"\n        Plot the field for a specific mode based on the given parameters.\n\n        Args:\n            target_polarization (str): The polarization of the target mode.\n            target_k_point (tuple): The k-point of the target mode.\n            target_frequency (float): The frequency of the target mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            periods (int): The number of periods to extract. Default is 1.\n            component (int): The component of the field to plot (0 for x, 1 for y, 2 for z). Default is 2.\n            quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n            bloch_phase (bool): Whether to include the Bloch phase. Default is True.\n            colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n        Returns:\n            tuple: A tuple containing the electric field figure and the magnetic field figure.\n        \"\"\"\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, freq_tolerance = frequency_tolerance, k_point_max_distance = k_point_max_distance)\n        #print(len(target_modes))\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon()) \n\n        z_points = eps.shape[2] // periods\n        z_mid = eps.shape[2] // 2\n\n        # Now take only epsilon in the center of the slab\n        eps = eps[..., z_mid]\n        # Calculate the midpoint between min and max of the permittivity (eps)\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        num_plots = len(target_modes)\n\n        for i, mode in enumerate(target_modes):\n            # Initialize visibility status: False for all traces\n            visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n            visible_status_h = [False] * (2 * num_plots)\n\n            visible_status_e[2 * i] = True  # Set the contour plot visible\n            visible_status_h[2 * i] = True\n            visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n            visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n            k_point = mode[\"k_point\"]\n            freq    = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n\n            # Take the specified component of the fields in the center of the slab\n            if bloch_phase:\n                e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n                h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n            else:\n                e_field = mpb.MPBArray(mode[\"e_field_periodic\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n                h_field = mpb.MPBArray(mode[\"h_field_periodic\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n            e_field = e_field[..., z_points // 2, component]\n            h_field = h_field[..., z_points // 2, component]\n            with suppress_output():\n                e_field = md.convert(e_field) \n                h_field = md.convert(h_field)\n\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n            # Add the contour plot for permittivity (eps) at the midpoint\n            contour_e = go.Contour(z=eps.T,\n                                contours=dict(\n                                    start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                    end=midpoint,\n                                    size=0.1,  # A small size to keep it as a single contour\n                                    coloring='none'  # No filling\n                                ),\n                                line=dict(color='black', width=2),\n                                showscale=False,\n                                opacity=0.7,\n                                visible=True if i ==  0  else False)  # Only the first mode is visible\n            contour_h = contour_e  # Same contour for H-field figure\n\n            # Add the contour trace\n            fig_e.add_trace(contour_e)\n            fig_h.add_trace(contour_h)\n\n            # Add the heatmap for the electric field\n            heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n            # Add the heatmap for the magnetic field\n            heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n\n            # Add the heatmap trace\n            fig_e.add_trace(heatmap_e)\n            fig_h.add_trace(heatmap_h)\n\n\n\n            data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n            if component == 0: \n                component_str = \"x-component\"\n            elif component == 1:\n                component_str = \"y-component\"\n            else:\n                component_str = \"z-component\"\n            subtitle_e = f\"E-field, {component_str}, {quantity}\"\n            subtitle_h = f\"H-field, {component_str}, {quantity}\"\n            # Create a button for each field dataset for the dropdown\n            dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                        ]))\n            dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                        ]))\n\n        # print(len(target_modes))\n        k_point = target_modes[0][\"k_point\"]\n        freq    = target_modes[0][\"freq\"]\n        data_str = f\"Mode {0} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n        fig_e.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_e,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n\n        )\n\n        fig_h.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_h,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n        )\n\n        return fig_e, fig_h\n\n\n\n    def plot_field_components(self,\n                            target_polarization,\n                            target_k_point,\n                            target_frequency,\n                            frequency_tolerance=0.01,\n                            k_point_max_distance=None,\n                            periods: int = 1,\n                            quantity: str = \"real\",\n                            bloch_phase: bool = True,\n                            colorscale: str = 'RdBu',\n                            )-&gt; tuple:\n        \"\"\"\n        Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n\n        Args:\n            target_polarization (str): The polarization of the target mode.\n            target_k_point (tuple): The k-point of the target mode.\n            target_frequency (float): The frequency of the target mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 1.\n            quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n            bloch_phase (bool): Whether to include the Bloch\n            colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n        Returns:\n            tuple: A tuple containing the electric field figure and the magnetic field figure.\n        \"\"\"\n\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                        freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n        print(f\"Number of target modes found: {len(target_modes)}\")\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon())\n\n        z_points = eps.shape[2] // periods\n        z_mid = eps.shape[2] // 2\n\n        # Now take only epsilon in the center of the slab\n        eps = eps[..., z_mid]\n        # Calculate the midpoint between min and max of the permittivity (eps)\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n        fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n        fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        # For each mode, calculate separate min and max values for Ex, Ey, Ez (and similarly Hx, Hy, Hz)\n        for i, mode in enumerate(target_modes):\n            # Get field arrays for this mode\n            if bloch_phase:\n                e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n                h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            else:\n                e_field_array = mpb.MPBArray(mode[\"e_field_periodic\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n                h_field_array = mpb.MPBArray(mode[\"h_field_periodic\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n            # Extract field components in the center of the slab\n            e_field_x = e_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n            e_field_y = e_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n            e_field_z = e_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n            h_field_x = h_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n            h_field_y = h_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n            h_field_z = h_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n\n            with suppress_output():\n                e_field_x = md.convert(e_field_x)\n                e_field_y = md.convert(e_field_y)\n                e_field_z = md.convert(e_field_z)\n                h_field_x = md.convert(h_field_x)\n                h_field_y = md.convert(h_field_y)\n                h_field_z = md.convert(h_field_z)\n\n            e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n            h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)                                    \n\n            # Select quantity to display (real, imag, abs)\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n            # Calculate the component-specific min/max for E and H fields of this mode\n            e_min = np.min(e_field)\n            e_max = np.max(e_field)\n            h_min = np.min(h_field)\n            h_max = np.max(h_field)\n\n            # Components of the E and H fields\n            Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n            Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n            # Define visibility settings per mode, including contours as always visible\n            visible_status_e = [False] * (len(target_modes) * 6)  # 3 components per mode, with contour for each\n            visible_status_h = [False] * (len(target_modes) * 6)\n            # Make the contour visible by default\n\n\n\n\n            # Make this mode's components and the corresponding contour visible in the initial layout \n            for j in range(6):\n                visible_status_e[6*i + j] = True\n                visible_status_h[6*i + j] = True\n\n\n            # Add contour traces for permittivity to each subplot of fig_e and fig_h for this mode\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n            # Add Ex, Ey, Ez with shared colorbar limits for the E field of this mode\n            fig_e.add_trace(go.Heatmap(z=Ex.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n            fig_e.add_trace(go.Heatmap(z=Ey.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n            fig_e.add_trace(go.Heatmap(z=Ez.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"E-field\", len=0.75, thickness=15), zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n            # Add Hx, Hy, Hz with shared colorbar limits for the H field of this mode\n            fig_h.add_trace(go.Heatmap(z=Hx.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n            fig_h.add_trace(go.Heatmap(z=Hy.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n            fig_h.add_trace(go.Heatmap(z=Hz.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"H-field\", len=0.75, thickness=15), zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n\n\n            # Dropdown data for E-field\n            k_point = mode[\"k_point\"]\n            freq = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n            mode_description = f\"Mode {i + 1}&lt;br&gt;k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n            dropdown_buttons_e.append(\n                dict(label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[{'visible': visible_status_e},\n                        {'title': f\"{mode_description}: {quantity} of E-field components\"}]))\n\n            dropdown_buttons_h.append(\n                dict(label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[{'visible': visible_status_h},\n                        {'title': f\"{mode_description}: {quantity} of H-field components\"}]))\n\n        # Layout and color settings\n        fig_e.update_layout(\n            title=f\"{mode_description}: {quantity} of E-field components\",\n            updatemenus=[dict(\n                active=len(target_modes) - 1,\n                buttons=dropdown_buttons_e)],\n            coloraxis=dict(colorbar=dict(len=0.75)),\n            width=1200, height=400,\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        fig_h.update_layout(\n            title=f\"{mode_description}: {quantity} of H-field components\",\n            updatemenus=[dict(\n                active=len(target_modes) - 1,\n                buttons=dropdown_buttons_h)],\n            coloraxis=dict(colorbar=dict(len=0.75)),\n            width=1200, height=400,\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        # Final adjustments\n        fig_e.update_xaxes(showticklabels=False)\n        fig_e.update_yaxes(showticklabels=False)\n        fig_h.update_xaxes(showticklabels=False)\n        fig_h.update_yaxes(showticklabels=False)\n\n        fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n        fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n        return fig_e, fig_h\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab-functions","title":"Functions","text":""},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab.__init__","title":"<code>__init__(lattice_type='square', material=None, geometry=None, num_bands=4, resolution=mp.Vector3(32, 32, 16), interp=2, periods=3, pickle_id=None, use_XY=True, k_point_max=0.2)</code>","text":"<p>Initializes the CrystalSlab object with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. It can be 'square' or 'triangular'. Default is 'square'.</p> <code>'square'</code> <code>material</code> <code>Crystal_Materials</code> <p>The material object for the photonic crystal. Default is None.</p> <code>None</code> <code>geometry</code> <code>CrystalSlab_Geometry</code> <p>The geometry of the photonic crystal. Default is None. If it is none, the basic geometry is used.</p> <code>None</code> <code>num_bands</code> <code>int</code> <p>The number of bands to calculate. Default is 4.</p> <code>4</code> <code>resolution</code> <code>Vector3</code> <p>The resolution of the simulation. Default is mp.Vector3(32, 32, 16).</p> <code>Vector3(32, 32, 16)</code> <code>interp</code> <code>int</code> <p>The interpolation factor for k-points. Default is 2.</p> <code>2</code> <code>periods</code> <code>int</code> <p>The number of periods to use in some plotting functions. Default is 3.</p> <code>3</code> <code>pickle_id</code> <code>str</code> <p>The ID for pickling the simulation. Default is None.</p> <code>None</code> <code>use_XY</code> <code>bool</code> <p>Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.</p> <code>True</code> <code>k_point_max</code> <code>float</code> <p>The maximum k-point value. Default is 0.2.</p> <code>0.2</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def __init__(self,\n            lattice_type = \"square\",\n            material: Crystal_Materials = None,\n            geometry = None, \n            num_bands: int = 4,\n            resolution = mp.Vector3(32,32,16),\n            interp: int =2,\n            periods: int =3, \n            pickle_id = None,\n            use_XY = True,\n            k_point_max = 0.2):\n    \"\"\"\n    Initializes the CrystalSlab object with the given parameters.\n\n    Args:\n        lattice_type (str): The type of lattice. It can be 'square' or 'triangular'. Default is 'square'.\n        material (Crystal_Materials): The material object for the photonic crystal. Default is None.\n        geometry (CrystalSlab_Geometry): The geometry of the photonic crystal. Default is None. If it is none, the basic geometry is used.\n        num_bands (int): The number of bands to calculate. Default is 4.\n        resolution (mp.Vector3): The resolution of the simulation. Default is mp.Vector3(32, 32, 16).\n        interp (int): The interpolation factor for k-points. Default is 2.\n        periods (int): The number of periods to use in some plotting functions. Default is 3.\n        pickle_id (str): The ID for pickling the simulation. Default is None.\n        use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n        k_point_max (float): The maximum k-point value. Default is 0.2.\n    \"\"\"\n\n\n    super().__init__(lattice_type, material,geometry, num_bands, resolution, interp, periods, pickle_id, use_XY)\n\n\n    self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n    if use_XY is True: \n        self.k_points = [\n            mp.Vector3(k_point_max, 0, 0),      # X\n            mp.Vector3(0, 0 ,0 ),               # Gamma\n            mp.Vector3(0, k_point_max, 0)       # Y\n        ]\n    self.geometry = geometry if geometry is not None else self.basic_geometry()\n    self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab.plot_epsilon","title":"<code>plot_epsilon(fig=None, opacity=0.3, colorscale='PuBuGn', override_resolution_with=None, periods=1)</code>","text":"<p>Plot the epsilon values obtained from the simulation using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the epsilon plot to. Default is None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the plot. Default is 0.3.</p> <code>0.3</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the plot. Default is 'PuBuGn'.</p> <code>'PuBuGn'</code> <code>override_resolution_with</code> <code>int</code> <p>The resolution to use for plotting. You can change the resolution just for the plot, but the simulation will still use the value set in the init method. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to plot. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_epsilon(self,\n                fig=None, \n                opacity=0.3, \n                colorscale='PuBuGn', \n                override_resolution_with = None, \n                periods = 1,\n                )-&gt; go.Figure:\n    \"\"\"\n    Plot the epsilon values obtained from the simulation using Plotly.\n\n    Args:\n        fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n        opacity (float, optional): The opacity of the plot. Default is 0.3.\n        colorscale (str, optional): The colorscale for the plot. Default is 'PuBuGn'.\n        override_resolution_with (int, optional): The resolution to use for plotting. You can change the resolution just for the plot, but the simulation will still use the value set in the __init__ method. Default is None.\n        periods (int, optional): The number of periods to plot. Default is 1.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n\n    if self.epsilon is None:\n\n        if override_resolution_with is None:\n            resolution = self.resolution\n        else:\n            resolution = override_resolution_with\n        md = mpb.MPBData(rectify=True, periods=periods, resolution=resolution)\n\n\n        converted_eps = md.convert(self.ms.get_epsilon())\n    else:\n        converted_eps = self.epsilon\n    self.epsilon = converted_eps\n    if fig is None:\n        fig = go.Figure()\n\n    z_points = converted_eps.shape[2]//periods\n    z_mid = converted_eps.shape[2]//2\n    epsilon = converted_eps[..., z_mid-z_points//2:z_mid+z_points//2-1] \n    print(epsilon.shape)\n    epsilon = np.transpose(epsilon,(1,0,2)) \n\n    # Create indices for x, y, z axes (meshgrid)\n    x, y, z = np.meshgrid(np.arange(epsilon.shape[0]),\n                        np.arange(epsilon.shape[1]),\n                        np.arange(epsilon.shape[2]))\n\n    # Flatten the arrays for Plotly\n    x_flat = x.flatten()\n    y_flat = y.flatten()\n    z_flat = z.flatten()\n    epsilon_flat = epsilon.flatten()\n\n    # Get the minimum and maximum values from the epsilon array (ensure they are floats)\n    isomin_value = float(np.min(epsilon_flat))\n    isomax_value = float(np.max(epsilon_flat))\n\n    # Create the 3D volume plot using Plotly\n    fig = go.Figure(data=go.Volume(\n        x=x_flat, y=y_flat, z=z_flat,\n        value=epsilon_flat,  # Use the dielectric function values\n        isomin=isomin_value,\n        isomax=isomax_value,\n        opacity=opacity,  # Adjust opacity to visualize internal structure\n        surface_count=3,  # Number of surfaces to display\n        colorscale=colorscale,  # Color scale for the dielectric function\n        colorbar=dict(title='Dielectric Constant')\n    ))\n\n    # Add layout details\n    fig.update_layout(\n        title='3D Volume Plot of Dielectric Function',\n        scene=dict(\n        xaxis=dict(title='X', visible=True),\n        yaxis=dict(title='Y', visible=True),\n        zaxis=dict(title='Z', visible=True),\n        )\n    )\n\n    fig.update_layout(height=800, width=600)\n\n    return fig\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab.basic_lattice","title":"<code>basic_lattice(lattice_type='square', height_supercell=4)</code>","text":"<p>Define the basic lattice structure for the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. Default is 'square'.</p> <code>'square'</code> <code>height_supercell</code> <code>int</code> <p>The height of the supercell. Default is 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def basic_lattice(self, lattice_type='square', height_supercell=4)-&gt; tuple:\n    \"\"\"\n    Define the basic lattice structure for the photonic crystal.\n\n    Args:\n        lattice_type (str): The type of lattice. Default is 'square'.\n        height_supercell (int): The height of the supercell. Default is 4.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n    \"\"\"\n\n    if lattice_type == 'square':\n        return self.square_lattice(height_supercell=height_supercell)\n    elif lattice_type == 'triangular':\n        return self.triangular_lattice(height_supercell=height_supercell)\n    else:\n        raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab.square_lattice","title":"<code>square_lattice(height_supercell=4)</code>","text":"<p>Define the square lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def square_lattice(self, height_supercell=4)-&gt; tuple:\n    \"\"\"\n    Define the square lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0, 1))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # M\n        mp.Vector3(0.5, 0.5),       # X\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab.triangular_lattice","title":"<code>triangular_lattice(height_supercell=4)</code>","text":"<p>Define the triangular lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def triangular_lattice(self, height_supercell=4)-&gt; tuple:\n    \"\"\"\n    Define the triangular lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # K\n        mp.Vector3(-1./3, 1./3),    # M\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab.basic_geometry","title":"<code>basic_geometry(radius=0.2, material=None)</code>  <code>staticmethod</code>","text":"<p>Define the basic geometry for the photonic crystal slab.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius of the cylinder. Default is 0.2.</p> <code>0.2</code> <code>material</code> <code>Crystal_Materials</code> <p>The material object for the photonic crystal. Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CrystalSlab_Geometry</code> <p>The geometry object representing the photonic crystal slab.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod \ndef basic_geometry(\n    radius = 0.2,\n    material: Crystal_Materials = None,\n):\n    \"\"\"\n    Define the basic geometry for the photonic crystal slab.\n\n    Args:\n        radius (float): The radius of the cylinder. Default is 0.2.\n        material (Crystal_Materials): The material object for the photonic crystal. Default is None.\n\n    Returns:\n        CrystalSlab_Geometry: The geometry object representing the photonic crystal slab.\n    \"\"\"\n\n    if material is None:\n        material = PhotonicCrystal.basic_material()\n    geometry = CrystalSlab_Geometry(material = material, geometry_type='cylinder', radius = radius)\n    return geometry\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab.plot_field","title":"<code>plot_field(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, component=2, bloch_phase=True, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the field for a specific mode based on the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the target mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the target mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the target mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>component</code> <code>int</code> <p>The component of the field to plot (0 for x, 1 for y, 2 for z). Default is 2.</p> <code>2</code> <code>quantity</code> <code>str</code> <p>The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.</p> <code>'real'</code> <code>bloch_phase</code> <code>bool</code> <p>Whether to include the Bloch phase. Default is True.</p> <code>True</code> <code>colorscale</code> <code>str</code> <p>The colorscale to use for the plot. Default is 'RdBu'.</p> <code>'RdBu'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the electric field figure and the magnetic field figure.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field(self, \n        target_polarization, \n        target_k_point, \n        target_frequency, \n        frequency_tolerance = 0.01, \n        k_point_max_distance = None,\n        periods: int=1, \n        component: int = 2, \n        bloch_phase: bool = True,\n        quantity: str = \"real\", \n        colorscale: str = 'RdBu',                  \n        ):\n    \"\"\"\n    Plot the field for a specific mode based on the given parameters.\n\n    Args:\n        target_polarization (str): The polarization of the target mode.\n        target_k_point (tuple): The k-point of the target mode.\n        target_frequency (float): The frequency of the target mode.\n        frequency_tolerance (float): The tolerance for frequency similarity.\n        periods (int): The number of periods to extract. Default is 1.\n        component (int): The component of the field to plot (0 for x, 1 for y, 2 for z). Default is 2.\n        quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n        bloch_phase (bool): Whether to include the Bloch phase. Default is True.\n        colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n    Returns:\n        tuple: A tuple containing the electric field figure and the magnetic field figure.\n    \"\"\"\n    target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, freq_tolerance = frequency_tolerance, k_point_max_distance = k_point_max_distance)\n    #print(len(target_modes))\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        eps = md.convert(self.ms.get_epsilon()) \n\n    z_points = eps.shape[2] // periods\n    z_mid = eps.shape[2] // 2\n\n    # Now take only epsilon in the center of the slab\n    eps = eps[..., z_mid]\n    # Calculate the midpoint between min and max of the permittivity (eps)\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n    dropdown_buttons_e = []\n    dropdown_buttons_h = []\n\n    num_plots = len(target_modes)\n\n    for i, mode in enumerate(target_modes):\n        # Initialize visibility status: False for all traces\n        visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n        visible_status_h = [False] * (2 * num_plots)\n\n        visible_status_e[2 * i] = True  # Set the contour plot visible\n        visible_status_h[2 * i] = True\n        visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n        visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n        k_point = mode[\"k_point\"]\n        freq    = mode[\"freq\"]\n        polarization = mode[\"polarization\"]\n\n        # Take the specified component of the fields in the center of the slab\n        if bloch_phase:\n            e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n            h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n        else:\n            e_field = mpb.MPBArray(mode[\"e_field_periodic\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n            h_field = mpb.MPBArray(mode[\"h_field_periodic\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n        e_field = e_field[..., z_points // 2, component]\n        h_field = h_field[..., z_points // 2, component]\n        with suppress_output():\n            e_field = md.convert(e_field) \n            h_field = md.convert(h_field)\n\n        if quantity == \"real\":\n            e_field = np.real(e_field)\n            h_field = np.real(h_field)\n        elif quantity == \"imag\":\n            e_field = np.imag(e_field)\n            h_field = np.imag(h_field)\n        elif quantity == \"abs\":\n            e_field = np.abs(e_field)\n            h_field = np.abs(h_field)\n        else:\n            raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n        # Add the contour plot for permittivity (eps) at the midpoint\n        contour_e = go.Contour(z=eps.T,\n                            contours=dict(\n                                start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                end=midpoint,\n                                size=0.1,  # A small size to keep it as a single contour\n                                coloring='none'  # No filling\n                            ),\n                            line=dict(color='black', width=2),\n                            showscale=False,\n                            opacity=0.7,\n                            visible=True if i ==  0  else False)  # Only the first mode is visible\n        contour_h = contour_e  # Same contour for H-field figure\n\n        # Add the contour trace\n        fig_e.add_trace(contour_e)\n        fig_h.add_trace(contour_h)\n\n        # Add the heatmap for the electric field\n        heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n        # Add the heatmap for the magnetic field\n        heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n\n        # Add the heatmap trace\n        fig_e.add_trace(heatmap_e)\n        fig_h.add_trace(heatmap_h)\n\n\n\n        data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n        if component == 0: \n            component_str = \"x-component\"\n        elif component == 1:\n            component_str = \"y-component\"\n        else:\n            component_str = \"z-component\"\n        subtitle_e = f\"E-field, {component_str}, {quantity}\"\n        subtitle_h = f\"H-field, {component_str}, {quantity}\"\n        # Create a button for each field dataset for the dropdown\n        dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                    ]))\n        dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                    ]))\n\n    # print(len(target_modes))\n    k_point = target_modes[0][\"k_point\"]\n    freq    = target_modes[0][\"freq\"]\n    data_str = f\"Mode {0} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n    fig_e.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_e,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n\n    )\n\n    fig_h.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_h,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n    )\n\n    return fig_e, fig_h\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal.CrystalSlab.plot_field_components","title":"<code>plot_field_components(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', bloch_phase=True, colorscale='RdBu')</code>","text":"<p>Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the target mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the target mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the target mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>quantity</code> <code>str</code> <p>The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.</p> <code>'real'</code> <code>bloch_phase</code> <code>bool</code> <p>Whether to include the Bloch</p> <code>True</code> <code>colorscale</code> <code>str</code> <p>The colorscale to use for the plot. Default is 'RdBu'.</p> <code>'RdBu'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the electric field figure and the magnetic field figure.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field_components(self,\n                        target_polarization,\n                        target_k_point,\n                        target_frequency,\n                        frequency_tolerance=0.01,\n                        k_point_max_distance=None,\n                        periods: int = 1,\n                        quantity: str = \"real\",\n                        bloch_phase: bool = True,\n                        colorscale: str = 'RdBu',\n                        )-&gt; tuple:\n    \"\"\"\n    Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n\n    Args:\n        target_polarization (str): The polarization of the target mode.\n        target_k_point (tuple): The k-point of the target mode.\n        target_frequency (float): The frequency of the target mode.\n        frequency_tolerance (float): The tolerance for frequency similarity.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n        periods (int): The number of periods to extract. Default is 1.\n        quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n        bloch_phase (bool): Whether to include the Bloch\n        colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n    Returns:\n        tuple: A tuple containing the electric field figure and the magnetic field figure.\n    \"\"\"\n\n    target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                    freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n    print(f\"Number of target modes found: {len(target_modes)}\")\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        eps = md.convert(self.ms.get_epsilon())\n\n    z_points = eps.shape[2] // periods\n    z_mid = eps.shape[2] // 2\n\n    # Now take only epsilon in the center of the slab\n    eps = eps[..., z_mid]\n    # Calculate the midpoint between min and max of the permittivity (eps)\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n    fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n    fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n    dropdown_buttons_e = []\n    dropdown_buttons_h = []\n\n    # For each mode, calculate separate min and max values for Ex, Ey, Ez (and similarly Hx, Hy, Hz)\n    for i, mode in enumerate(target_modes):\n        # Get field arrays for this mode\n        if bloch_phase:\n            e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n        else:\n            e_field_array = mpb.MPBArray(mode[\"e_field_periodic\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            h_field_array = mpb.MPBArray(mode[\"h_field_periodic\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n        # Extract field components in the center of the slab\n        e_field_x = e_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n        e_field_y = e_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n        e_field_z = e_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n        h_field_x = h_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n        h_field_y = h_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n        h_field_z = h_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n\n        with suppress_output():\n            e_field_x = md.convert(e_field_x)\n            e_field_y = md.convert(e_field_y)\n            e_field_z = md.convert(e_field_z)\n            h_field_x = md.convert(h_field_x)\n            h_field_y = md.convert(h_field_y)\n            h_field_z = md.convert(h_field_z)\n\n        e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n        h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)                                    \n\n        # Select quantity to display (real, imag, abs)\n        if quantity == \"real\":\n            e_field = np.real(e_field)\n            h_field = np.real(h_field)\n        elif quantity == \"imag\":\n            e_field = np.imag(e_field)\n            h_field = np.imag(h_field)\n        elif quantity == \"abs\":\n            e_field = np.abs(e_field)\n            h_field = np.abs(h_field)\n        else:\n            raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n        # Calculate the component-specific min/max for E and H fields of this mode\n        e_min = np.min(e_field)\n        e_max = np.max(e_field)\n        h_min = np.min(h_field)\n        h_max = np.max(h_field)\n\n        # Components of the E and H fields\n        Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n        Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n        # Define visibility settings per mode, including contours as always visible\n        visible_status_e = [False] * (len(target_modes) * 6)  # 3 components per mode, with contour for each\n        visible_status_h = [False] * (len(target_modes) * 6)\n        # Make the contour visible by default\n\n\n\n\n        # Make this mode's components and the corresponding contour visible in the initial layout \n        for j in range(6):\n            visible_status_e[6*i + j] = True\n            visible_status_h[6*i + j] = True\n\n\n        # Add contour traces for permittivity to each subplot of fig_e and fig_h for this mode\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n        # Add Ex, Ey, Ez with shared colorbar limits for the E field of this mode\n        fig_e.add_trace(go.Heatmap(z=Ex.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n        fig_e.add_trace(go.Heatmap(z=Ey.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n        fig_e.add_trace(go.Heatmap(z=Ez.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"E-field\", len=0.75, thickness=15), zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n        # Add Hx, Hy, Hz with shared colorbar limits for the H field of this mode\n        fig_h.add_trace(go.Heatmap(z=Hx.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n        fig_h.add_trace(go.Heatmap(z=Hy.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n        fig_h.add_trace(go.Heatmap(z=Hz.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"H-field\", len=0.75, thickness=15), zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n\n\n        # Dropdown data for E-field\n        k_point = mode[\"k_point\"]\n        freq = mode[\"freq\"]\n        polarization = mode[\"polarization\"]\n        mode_description = f\"Mode {i + 1}&lt;br&gt;k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n        dropdown_buttons_e.append(\n            dict(label=f\"Mode {i + 1}\",\n                method='update',\n                args=[{'visible': visible_status_e},\n                    {'title': f\"{mode_description}: {quantity} of E-field components\"}]))\n\n        dropdown_buttons_h.append(\n            dict(label=f\"Mode {i + 1}\",\n                method='update',\n                args=[{'visible': visible_status_h},\n                    {'title': f\"{mode_description}: {quantity} of H-field components\"}]))\n\n    # Layout and color settings\n    fig_e.update_layout(\n        title=f\"{mode_description}: {quantity} of E-field components\",\n        updatemenus=[dict(\n            active=len(target_modes) - 1,\n            buttons=dropdown_buttons_e)],\n        coloraxis=dict(colorbar=dict(len=0.75)),\n        width=1200, height=400,\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        hovermode=\"closest\"\n    )\n\n    fig_h.update_layout(\n        title=f\"{mode_description}: {quantity} of H-field components\",\n        updatemenus=[dict(\n            active=len(target_modes) - 1,\n            buttons=dropdown_buttons_h)],\n        coloraxis=dict(colorbar=dict(len=0.75)),\n        width=1200, height=400,\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        hovermode=\"closest\"\n    )\n\n    # Final adjustments\n    fig_e.update_xaxes(showticklabels=False)\n    fig_e.update_yaxes(showticklabels=False)\n    fig_h.update_xaxes(showticklabels=False)\n    fig_h.update_yaxes(showticklabels=False)\n\n    fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n    fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n    fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n    fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n    fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n    fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n    return fig_e, fig_h\n</code></pre>"},{"location":"api/photonic_crystal/#src.photonic_crystal-functions","title":"Functions","text":""},{"location":"api/photonic_crystal/#src.photonic_crystal.suppress_output","title":"<code>suppress_output()</code>","text":"<p>Context manager to suppress stdout and stderr.</p> <p>This context manager redirects the standard output (stdout) and standard error (stderr) to os.devnull, effectively suppressing any output within its context.</p> <p>Yields:</p> Name Type Description <code>None</code> <p>This context manager does not return any value.</p> Example <pre><code>with suppress_output():\n    print(\"This will not be printed\")\n    raise ValueError(\"This error will not be shown\")\n</code></pre> Source code in <code>src/photonic_crystal.py</code> <pre><code>@contextlib.contextmanager\ndef suppress_output():\n    \"\"\"\n    Context manager to suppress stdout and stderr.\n\n    This context manager redirects the standard output (stdout) and standard error (stderr)\n    to os.devnull, effectively suppressing any output within its context.\n\n    Yields:\n        None: This context manager does not return any value.\n\n    Example:\n        ```python\n        with suppress_output():\n            print(\"This will not be printed\")\n            raise ValueError(\"This error will not be shown\")\n        ```\n    \"\"\"\n    with open(os.devnull, 'w') as devnull:\n        old_stdout = sys.stdout\n        old_stderr = sys.stderr\n        sys.stdout = devnull\n        sys.stderr = devnull\n        try:\n            yield\n        finally:\n            sys.stdout = old_stdout\n            sys.stderr = old_stderr\n</code></pre>"}]}