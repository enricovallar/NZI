{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome in the NZI Material Finder!","text":"<p>This tool leverages the MPB Python Interface, which is part of the MEEP repository, to perform simulations of 2D photonic crystals and photonic crystal slabs. This tool has been developed to find NZI Material realized with of PhCs. </p> <p>It is possible to use the Dash application or directly write your code in Python using the API for further data analysis; for the latter I suggest using Jupyther Notebook. </p> <p>The basic process flow is: </p> <ol> <li>Choose the crystal type (2D or Slab)</li> <li>Choose the lattice type (triangular or square)</li> <li>Choose the materials of background, substrate,  bulk and atom</li> <li>Choose the geometry of the atom (circular, square, elliptical or rectangular)</li> <li>Set the MPB Solver</li> <li>Run the simulatiom </li> <li>Plot the bands</li> <li>Investigate the field at specific band points</li> <li>If you want, you can sweep some geometry parameters. </li> </ol>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#how-to-run-this-mpb-based-application","title":"How to run this MPB based application?","text":"<p>At its core this is a Python Dash application that use MPB to do the calculations. </p> <p>In its current version MPB's Python interface is part of MEEP's Python interface.  Hence, MEEP must be installed to make it work. </p> <p>MEEP is not available for ARM processors, so it cannot be installed on some Macbooks for example.  If you have this problem you might want to use DTU HPC based on Alma Linux. Otherwise you can just install it in your machine. </p>"},{"location":"installation/#how-to-connect-to-dtu-hpc","title":"How to connect to DTU HPC","text":"<p>To connect to DTU HPC follow the guide on the offical website and use ThinLinc Client to get access.</p> <p>When you are connected:</p> <ol> <li>Click on Application</li> <li>Click on Terminal Emulator. </li> <li>In the terminal write the command 'code'. It should open Visual Studio Code Vsc</li> <li>(Skip to 6 if you are  already logged with your GitHub account)     On the bottom-left corner click on Accounts and then \"Backup and Sync Settings...\"</li> <li>You will be redirected to the GitHub login: follow the instructions. </li> <li>Fork my repo into your account. </li> <li>Go back to VSC and in a new window on the left panel click on Source Control (git symbol) and click on \"Clone Repository\". Clone the repository from GitHub following the instructions.</li> </ol>"},{"location":"installation/#installing-miniconda","title":"Installing Miniconda","text":"<p>We need a virtual conda envirenment to install MEEP. </p> <p>Open a new 'Terminal'. Write the following lines:  <pre><code>wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\nbash Miniconda3-latest-Linux-x86_64.sh\n\nsource ~/miniconda3/bin/activate\n\nconda init\n</code></pre></p> <p>After this restart your terminal. </p>"},{"location":"installation/#installing-meep","title":"Installing MEEP","text":"<p>In the terminal: <pre><code>conda create -n mp -c conda-forge pymeep pymeep-extras\n\nconda activate mp\n</code></pre> and reload the terminal</p>"},{"location":"installation/#installing-dash","title":"Installing Dash","text":"<pre><code>conda install dash\n\nconda install dash-bootstrap-components\n\nconda install dash-daq\n</code></pre>"},{"location":"photonic_crystal/","title":"Photonic crystal","text":""},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D","title":"<code>Crystal2D</code>","text":"<p>               Bases: <code>PhotonicCrystal</code></p> <p>This class provides methods to define and simulate 2D photonic crystals with various lattice types and geometries.  It allows for the calculation and visualization of dielectric distributions and electromagnetic fields within the crystal.</p> <p>Attributes:</p> Name Type Description <code>geometry_lattice</code> <code>Lattice</code> <p>The lattice structure of the photonic crystal.</p> <code>k_points</code> <code>list</code> <p>List of k-points for the simulation.</p> <code>geometry</code> <code>list</code> <p>List of geometric objects defining the photonic crystal.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points for the simulation.</p> <code>epsilon</code> <code>ndarray</code> <p>Dielectric distribution of the photonic crystal.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the Crystal2D object with the specified parameters.</p> <code>plot_epsilon</code> <p>Plots the dielectric distribution interactively using Plotly.</p> <code>plot_field</code> <p>Plots the electromagnetic field distribution interactively using Plotly.</p> <code>plot_field_components</code> <p>Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> <code>basic_geometry</code> <p>Defines a basic geometry for the photonic crystal.</p> <code>ellipsoid_geometry</code> <p>Defines an ellipsoid geometry for the photonic crystal.</p> <code>advanced_material_geometry</code> <p>Defines an advanced material geometry for the photonic crystal.</p> <code>basic_lattice</code> <p>Defines the basic lattice structure for the photonic crystal.</p> <code>square_lattice</code> <p>Defines a square lattice for the photonic crystal.</p> <code>triangular_lattice</code> <p>Defines a triangular lattice for the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>class Crystal2D(PhotonicCrystal):\n    \"\"\"\n    This class provides methods to define and simulate 2D photonic crystals with various lattice types and geometries. \n    It allows for the calculation and visualization of dielectric distributions and electromagnetic fields within the crystal.\n\n    Attributes:\n        geometry_lattice (mp.Lattice): The lattice structure of the photonic crystal.\n        k_points (list): List of k-points for the simulation.\n        geometry (list): List of geometric objects defining the photonic crystal.\n        k_points_interpolated (list): Interpolated k-points for the simulation.\n        epsilon (ndarray): Dielectric distribution of the photonic crystal.\n\n    Methods:\n        __init__(self, lattice_type=None, num_bands=6, resolution=(32, 32), interp=4, periods=3, pickle_id=None, geometry=None, use_XY=True, k_point_max=0.2):\n            Initializes the Crystal2D object with the specified parameters.\n        plot_epsilon(self, fig=None, title='Epsilon', **kwargs):\n            Plots the dielectric distribution interactively using Plotly.\n        plot_field(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=5, component=2, quantity=\"real\", colorscale='RdBu'):\n            Plots the electromagnetic field distribution interactively using Plotly.\n        plot_field_components(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity=\"real\", colorscale='RdBu'):\n            Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n        basic_geometry(radius_1=0.2, eps_atom_1=1, radius_2=None, eps_atom_2=None, eps_bulk=12):\n            Defines a basic geometry for the photonic crystal.\n        ellipsoid_geometry(e1=0.2, e2=0.3, eps_atom=1, eps_bulk=12):\n            Defines an ellipsoid geometry for the photonic crystal.\n        advanced_material_geometry(radius_1=0.2, epsilon_diag=mp.Vector3(12, 12, 12), epsilon_offdiag=mp.Vector3(0, 0, 0), chi2_diag=mp.Vector3(0, 0, 0), chi3_diag=mp.Vector3(0, 0, 0), eps_atom_1=1):\n            Defines an advanced material geometry for the photonic crystal.\n        basic_lattice(lattice_type='square'):\n            Defines the basic lattice structure for the photonic crystal.\n        square_lattice():\n            Defines a square lattice for the photonic crystal.\n        triangular_lattice():\n            Defines a triangular lattice for the photonic crystal.\n    \"\"\"\n\n\n\n    def __init__(self,\n                lattice_type = \"square\",\n                material: Crystal_Materials = None,\n                geometry: Crystal2D_Geometry = None,\n                num_bands: int = 6,\n                resolution = 32,\n                interp: int = 4,\n                periods: int = 3, \n                pickle_id = None,\n                use_XY = True,\n                k_point_max = 0.2):\n\n        \"\"\"\n        Initializes the Crystal2D object with the specified parameters.\n\n        Args:\n            lattice_type (str): The type of lattice. Default is 'square' other option is 'triangular'. It determines the k-points if use_XY is False.\n            material (Crystal_Materials): The material of the photonic crystal. Default is None.\n            geometry (Crystal2D_Geometry): The geometry of the photonic crystal. Default is None.\n            num_bands (int): The number of bands to calculate. Default is 6.\n            resolution (tuple[int, int] | int): The resolution of the simulation. Default is (32, 32).\n            interp (int): The interpolation factor for k-points. Default is 4.\n            periods (int): The number of periods to simulate. Default is 3.\n            pickle_id (str): The ID for pickling the simulation. Default is None.\n            use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n            k_point_max (float): The maximum k-point value. Default is 0.2.\n        \"\"\"\n\n        super().__init__(lattice_type, material, geometry, num_bands, resolution, interp, periods, pickle_id, use_XY=use_XY)\n\n        self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n        if use_XY is True:\n            self.k_points = [\n                mp.Vector3(k_point_max, 0, 0),      # X\n                mp.Vector3(0, 0 ,0 ),       # Gamma\n                mp.Vector3(0, k_point_max,0)        # Y\n            ]\n\n        self.geometry = geometry if geometry is not None else Crystal2D.basic_geometry(material = self.material)\n        self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n\n\n\n    def plot_epsilon(self, fig=None, title='Epsilon', **kwargs)-&gt; go.Figure:\n        \"\"\"\n        Plot the dielectric distribution interactively using Plotly.\n\n        Args:\n            fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n            title (str, optional): The title of the plot. Default is 'Epsilon'.\n            **kwargs: Additional keyword arguments for Plotly.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n\n        with suppress_output():\n            if self.epsilon is None:\n                md = mpb.MPBData(rectify=True, periods=self.periods, resolution=self.resolution)\n                converted_eps = md.convert(self.ms.get_epsilon())\n            else:\n                converted_eps = self.epsilon\n            if fig is None:\n                fig = go.Figure()\n\n            fig.add_trace(go.Heatmap(z=converted_eps.T, colorscale='Viridis'))\n            fig.update_layout(\n                title=dict(\n                    text=f\"{title}&lt;br&gt;Dielectric Distribution\",\n                    x=0.5,\n                    y=0.95,\n                    xanchor='center',\n                    yanchor='top'\n                ),\n                coloraxis_colorbar=dict(title='$\\\\epsilon $'),\n                xaxis_showgrid=False, \n                yaxis_showgrid=False,\n                xaxis_zeroline=False, \n                yaxis_zeroline=False,\n                xaxis_visible=False, \n                yaxis_visible=False\n            )       \n        self.epsilon = converted_eps\n        print(self.epsilon)    \n        return fig\n\n    def plot_field(self,    \n                target_polarization,\n                target_k_point,\n                target_frequency,\n                frequency_tolerance=0.01,\n                k_point_max_distance=None,\n                periods=5,\n                component: int = 2,\n                quantity: str = \"real\",\n                colorscale: str = \"RdBu\",\n    )-&gt; tuple:\n        \"\"\"\n        Plot the electromagnetic field distribution using Plotly.\n\n        Args:\n            target_polarization (str): The polarization of the mode.\n            target_k_point (tuple): The k-point of the mode.\n            target_frequency (float): The frequency of the mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 5.\n            component (int): The component of the field to plot. x=0, y=1, z=2. Default is 2.\n            quantity (str): The quantity to plot. Default is 'real'.\n            colorscale (str): The colorscale for the heatmap. Default is 'RdBu'.\n\n        Returns:\n            tuple[go.Figure, go.Figure]: The Plotly figure objects for the electric and magnetic fields.\n        \"\"\"\n\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, frequency_tolerance, k_point_max_distance)\n        if not target_modes:\n            print(\"No modes found with the specified criteria.\")\n            return\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon()) \n\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (max_eps + min_eps) / 2\n        num_plots = len(target_modes)\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        for i, mode in enumerate(target_modes):\n            # Initialize visibility status: False for all traces\n            visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n            visible_status_h = [False] * (2 * num_plots)\n\n            visible_status_e[2 * i] = True  # Set the contour plot visible\n            visible_status_h[2 * i] = True\n            visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n            visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n            k_point = mode[\"k_point\"]\n            freq    = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n\n            # Take the specified component of the fields in the center of the slab\n\n            e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n            h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n            e_field = e_field[..., component]\n            h_field = h_field[..., component]\n            e_field = np.squeeze(e_field)\n            h_field = np.squeeze(h_field)   \n\n            with suppress_output():\n                e_field = md.convert(e_field) \n                h_field = md.convert(h_field)\n\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n            # Add the contour plot for permittivity (eps) at the midpoint\n            contour_e = go.Contour(z=eps.T,\n                                contours=dict(\n                                    start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                    end=midpoint,\n                                    size=0.1,  # A small size to keep it as a single contour\n                                    coloring='none'  # No filling\n                                ),\n                                line=dict(color='black', width=2),\n                                showscale=False,\n                                opacity=0.7,\n                                visible=True if i ==  0  else False)  # Only the first mode is visible\n            contour_h = contour_e  # Same contour for H-field figure\n\n            # Add the contour trace\n            fig_e.add_trace(contour_e)\n            fig_h.add_trace(contour_h)\n\n            # Add the heatmap for the electric field\n            heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n            # Add the heatmap for the magnetic field\n            heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n\n            # Add the heatmap trace\n            fig_e.add_trace(heatmap_e)\n            fig_h.add_trace(heatmap_h)\n\n            data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n            if component == 0: \n                component_str = \"x-component\"\n            elif component == 1:\n                component_str = \"y-component\"\n            else:\n                component_str = \"z-component\"\n            subtitle_e = f\"E-field, {component_str}, {quantity}\"\n            subtitle_h = f\"H-field, {component_str}, {quantity}\"\n            # Create a button for each field dataset for the dropdown\n            dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                        ]))\n            dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                        ]))\n        k_point = target_modes[0][\"k_point\"]\n        freq    = target_modes[0][\"freq\"]\n        data_str = f\"Mode {0} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n        fig_e.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_e,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n\n        )\n\n        fig_h.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_h,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n        )\n\n        return fig_e, fig_h\n\n\n    def plot_field_components(self,\n                            target_polarization,\n                            target_k_point,\n                            target_frequency,\n                            frequency_tolerance=0.01,\n                            k_point_max_distance=None,\n                            periods: int = 1,\n                            quantity: str = \"real\",\n                            colorscale: str = 'RdBu',\n                            )-&gt; tuple:\n        \"\"\"\n        Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n        For each component, the real, imaginary, or absolute value can be plotted.\n\n        Args:\n            target_polarization (str): The polarization of the target mode.\n            target_k_point (tuple): The k-point of the target mode.\n            target_frequency (float): The frequency of the target mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 1.\n            quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n            colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n        Returns:\n            tuple: A tuple containing the electric field figure and the magnetic field figure.\n        \"\"\"\n\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                        freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n        print(f\"Number of target modes found: {len(target_modes)}\")\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon())\n\n        # Calculate the midpoint between min and max of the permittivity (eps)\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n        fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n        fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        # For each mode, calculate separate min and max values for Ex, Ey, Ez (and similarly Hx, Hy, Hz)\n        for i, mode in enumerate(target_modes):\n            # Get field arrays for this mode\n            e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n            # Extract field components in the center of the slab\n            e_field_x = e_field_array[..., 0]  # Shape (Nx, Ny)\n            e_field_y = e_field_array[..., 1]  # Shape (Nx, Ny)\n            e_field_z = e_field_array[..., 2]  # Shape (Nx, Ny)\n            h_field_x = h_field_array[..., 0]  # Shape (Nx, Ny)\n            h_field_y = h_field_array[..., 1]  # Shape (Nx, Ny)\n            h_field_z = h_field_array[..., 2]  # Shape (Nx, Ny)\n\n            # Convert the field arrays to the correct shape\n            e_field_x = np.squeeze(e_field_x)\n            e_field_y = np.squeeze(e_field_y)\n            e_field_z = np.squeeze(e_field_z)\n            h_field_x = np.squeeze(h_field_x)\n            h_field_y = np.squeeze(h_field_y)\n            h_field_z = np.squeeze(h_field_z)\n\n\n            with suppress_output():\n                e_field_x = md.convert(e_field_x)\n                e_field_y = md.convert(e_field_y)\n                e_field_z = md.convert(e_field_z)\n                h_field_x = md.convert(h_field_x)\n                h_field_y = md.convert(h_field_y)\n                h_field_z = md.convert(h_field_z)\n\n            e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n            h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)                                    \n\n            # Select quantity to display (real, imag, abs)\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n            # Calculate the component-specific min/max for E and H fields of this mode\n            e_min = np.min(e_field)\n            e_max = np.max(e_field)\n            h_min = np.min(h_field)\n            h_max = np.max(h_field)\n\n            # Components of the E and H fields\n            Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n            Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n            # Define visibility settings per mode, including contours as always visible\n            visible_status_e = [False] * (len(target_modes) * 6)  # 3 components per mode, with contour for each\n            visible_status_h = [False] * (len(target_modes) * 6)\n            # Make the contour visible by default\n\n\n            # Make this mode's components and the corresponding contour visible in the initial layout \n            for j in range(6):\n                visible_status_e[6*i + j] = True\n                visible_status_h[6*i + j] = True\n\n\n            # Add contour traces for permittivity to each subplot of fig_e and fig_h for this mode\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n            # Add Ex, Ey, Ez with shared colorbar limits for the E field of this mode\n            fig_e.add_trace(go.Heatmap(z=Ex.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n            fig_e.add_trace(go.Heatmap(z=Ey.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n            fig_e.add_trace(go.Heatmap(z=Ez.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"E-field\", len=0.75, thickness=15), zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n            # Add Hx, Hy, Hz with shared colorbar limits for the H field of this mode\n            fig_h.add_trace(go.Heatmap(z=Hx.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n            fig_h.add_trace(go.Heatmap(z=Hy.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n            fig_h.add_trace(go.Heatmap(z=Hz.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"H-field\", len=0.75, thickness=15), zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n\n\n            # Dropdown data for E-field\n            k_point = mode[\"k_point\"]\n            freq = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n            mode_description = f\"Mode {i + 1}&lt;br&gt;k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n            dropdown_buttons_e.append(\n                dict(label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[{'visible': visible_status_e},\n                        {'title': f\"{mode_description}: {quantity} of E-field components\"}]))\n\n            dropdown_buttons_h.append(\n                dict(label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[{'visible': visible_status_h},\n                        {'title': f\"{mode_description}: {quantity} of H-field components\"}]))\n\n        # Layout and color settings\n        fig_e.update_layout(\n            title=f\"{mode_description}: {quantity} of E-field components\",\n            updatemenus=[dict(\n                active=len(target_modes) - 1,\n                buttons=dropdown_buttons_e)],\n            coloraxis=dict(colorbar=dict(len=0.75)),\n            width=1200, height=400,\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        fig_h.update_layout(\n            title=f\"{mode_description}: {quantity} of H-field components\",\n            updatemenus=[dict(\n                active=len(target_modes) - 1,\n                buttons=dropdown_buttons_h)],\n            coloraxis=dict(colorbar=dict(len=0.75)),\n            width=1200, height=400,\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        # Final adjustments\n        fig_e.update_xaxes(showticklabels=False)\n        fig_e.update_yaxes(showticklabels=False)\n        fig_h.update_xaxes(showticklabels=False)\n        fig_h.update_yaxes(showticklabels=False)\n\n        fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n        fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n        return fig_e, fig_h\n\n\n\n\n\n\n\n\n\n    @staticmethod\n    def basic_lattice(lattice_type='square')-&gt; tuple:\n        \"\"\"\n        Define the basic lattice of the photonic crystal.\n\n        Args:\n            lattice_type (str): The type of lattice. Default is 'square'. Other option is 'triangular'.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n        \"\"\"\n        if lattice_type == 'square':\n            return Crystal2D.square_lattice()\n        elif lattice_type == 'triangular':\n            return Crystal2D.triangular_lattice()\n        else:\n            raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n\n\n\n    @staticmethod\n    def square_lattice()-&gt; tuple:\n        \"\"\"\n        Define the square lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0, 1))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # M\n            mp.Vector3(0.5, 0.5),       # X\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n\n    @staticmethod\n    def triangular_lattice()-&gt; tuple:\n        \"\"\"\n        Define the triangular lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # K\n            mp.Vector3(-1./3, 1./3),    # M\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n\n    @staticmethod\n    def basic_geometry(r = 0.2, material = None):\n        if material is None:\n            material = PhotonicCrystal.basic_material()\n        geometry = Crystal2D_Geometry(material = material, geometry_type='cylinder', radius=r)\n        return geometry\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.__init__","title":"<code>__init__(lattice_type='square', material=None, geometry=None, num_bands=6, resolution=32, interp=4, periods=3, pickle_id=None, use_XY=True, k_point_max=0.2)</code>","text":"<p>Initializes the Crystal2D object with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. Default is 'square' other option is 'triangular'. It determines the k-points if use_XY is False.</p> <code>'square'</code> <code>material</code> <code>Crystal_Materials</code> <p>The material of the photonic crystal. Default is None.</p> <code>None</code> <code>geometry</code> <code>Crystal2D_Geometry</code> <p>The geometry of the photonic crystal. Default is None.</p> <code>None</code> <code>num_bands</code> <code>int</code> <p>The number of bands to calculate. Default is 6.</p> <code>6</code> <code>resolution</code> <code>tuple[int, int] | int</code> <p>The resolution of the simulation. Default is (32, 32).</p> <code>32</code> <code>interp</code> <code>int</code> <p>The interpolation factor for k-points. Default is 4.</p> <code>4</code> <code>periods</code> <code>int</code> <p>The number of periods to simulate. Default is 3.</p> <code>3</code> <code>pickle_id</code> <code>str</code> <p>The ID for pickling the simulation. Default is None.</p> <code>None</code> <code>use_XY</code> <code>bool</code> <p>Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.</p> <code>True</code> <code>k_point_max</code> <code>float</code> <p>The maximum k-point value. Default is 0.2.</p> <code>0.2</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def __init__(self,\n            lattice_type = \"square\",\n            material: Crystal_Materials = None,\n            geometry: Crystal2D_Geometry = None,\n            num_bands: int = 6,\n            resolution = 32,\n            interp: int = 4,\n            periods: int = 3, \n            pickle_id = None,\n            use_XY = True,\n            k_point_max = 0.2):\n\n    \"\"\"\n    Initializes the Crystal2D object with the specified parameters.\n\n    Args:\n        lattice_type (str): The type of lattice. Default is 'square' other option is 'triangular'. It determines the k-points if use_XY is False.\n        material (Crystal_Materials): The material of the photonic crystal. Default is None.\n        geometry (Crystal2D_Geometry): The geometry of the photonic crystal. Default is None.\n        num_bands (int): The number of bands to calculate. Default is 6.\n        resolution (tuple[int, int] | int): The resolution of the simulation. Default is (32, 32).\n        interp (int): The interpolation factor for k-points. Default is 4.\n        periods (int): The number of periods to simulate. Default is 3.\n        pickle_id (str): The ID for pickling the simulation. Default is None.\n        use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n        k_point_max (float): The maximum k-point value. Default is 0.2.\n    \"\"\"\n\n    super().__init__(lattice_type, material, geometry, num_bands, resolution, interp, periods, pickle_id, use_XY=use_XY)\n\n    self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n    if use_XY is True:\n        self.k_points = [\n            mp.Vector3(k_point_max, 0, 0),      # X\n            mp.Vector3(0, 0 ,0 ),       # Gamma\n            mp.Vector3(0, k_point_max,0)        # Y\n        ]\n\n    self.geometry = geometry if geometry is not None else Crystal2D.basic_geometry(material = self.material)\n    self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.basic_lattice","title":"<code>basic_lattice(lattice_type='square')</code>  <code>staticmethod</code>","text":"<p>Define the basic lattice of the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. Default is 'square'. Other option is 'triangular'.</p> <code>'square'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_lattice(lattice_type='square')-&gt; tuple:\n    \"\"\"\n    Define the basic lattice of the photonic crystal.\n\n    Args:\n        lattice_type (str): The type of lattice. Default is 'square'. Other option is 'triangular'.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n    \"\"\"\n    if lattice_type == 'square':\n        return Crystal2D.square_lattice()\n    elif lattice_type == 'triangular':\n        return Crystal2D.triangular_lattice()\n    else:\n        raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.plot_epsilon","title":"<code>plot_epsilon(fig=None, title='Epsilon', **kwargs)</code>","text":"<p>Plot the dielectric distribution interactively using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the epsilon plot to. Default is None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Epsilon'.</p> <code>'Epsilon'</code> <code>**kwargs</code> <p>Additional keyword arguments for Plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_epsilon(self, fig=None, title='Epsilon', **kwargs)-&gt; go.Figure:\n    \"\"\"\n    Plot the dielectric distribution interactively using Plotly.\n\n    Args:\n        fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n        title (str, optional): The title of the plot. Default is 'Epsilon'.\n        **kwargs: Additional keyword arguments for Plotly.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n\n    with suppress_output():\n        if self.epsilon is None:\n            md = mpb.MPBData(rectify=True, periods=self.periods, resolution=self.resolution)\n            converted_eps = md.convert(self.ms.get_epsilon())\n        else:\n            converted_eps = self.epsilon\n        if fig is None:\n            fig = go.Figure()\n\n        fig.add_trace(go.Heatmap(z=converted_eps.T, colorscale='Viridis'))\n        fig.update_layout(\n            title=dict(\n                text=f\"{title}&lt;br&gt;Dielectric Distribution\",\n                x=0.5,\n                y=0.95,\n                xanchor='center',\n                yanchor='top'\n            ),\n            coloraxis_colorbar=dict(title='$\\\\epsilon $'),\n            xaxis_showgrid=False, \n            yaxis_showgrid=False,\n            xaxis_zeroline=False, \n            yaxis_zeroline=False,\n            xaxis_visible=False, \n            yaxis_visible=False\n        )       \n    self.epsilon = converted_eps\n    print(self.epsilon)    \n    return fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.plot_field","title":"<code>plot_field(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=5, component=2, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the electromagnetic field distribution using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 5.</p> <code>5</code> <code>component</code> <code>int</code> <p>The component of the field to plot. x=0, y=1, z=2. Default is 2.</p> <code>2</code> <code>quantity</code> <code>str</code> <p>The quantity to plot. Default is 'real'.</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the heatmap. Default is 'RdBu'.</p> <code>'RdBu'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>tuple[go.Figure, go.Figure]: The Plotly figure objects for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field(self,    \n            target_polarization,\n            target_k_point,\n            target_frequency,\n            frequency_tolerance=0.01,\n            k_point_max_distance=None,\n            periods=5,\n            component: int = 2,\n            quantity: str = \"real\",\n            colorscale: str = \"RdBu\",\n)-&gt; tuple:\n    \"\"\"\n    Plot the electromagnetic field distribution using Plotly.\n\n    Args:\n        target_polarization (str): The polarization of the mode.\n        target_k_point (tuple): The k-point of the mode.\n        target_frequency (float): The frequency of the mode.\n        frequency_tolerance (float): The tolerance for frequency similarity.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n        periods (int): The number of periods to extract. Default is 5.\n        component (int): The component of the field to plot. x=0, y=1, z=2. Default is 2.\n        quantity (str): The quantity to plot. Default is 'real'.\n        colorscale (str): The colorscale for the heatmap. Default is 'RdBu'.\n\n    Returns:\n        tuple[go.Figure, go.Figure]: The Plotly figure objects for the electric and magnetic fields.\n    \"\"\"\n\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n    target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, frequency_tolerance, k_point_max_distance)\n    if not target_modes:\n        print(\"No modes found with the specified criteria.\")\n        return\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        eps = md.convert(self.ms.get_epsilon()) \n\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (max_eps + min_eps) / 2\n    num_plots = len(target_modes)\n    dropdown_buttons_e = []\n    dropdown_buttons_h = []\n\n    for i, mode in enumerate(target_modes):\n        # Initialize visibility status: False for all traces\n        visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n        visible_status_h = [False] * (2 * num_plots)\n\n        visible_status_e[2 * i] = True  # Set the contour plot visible\n        visible_status_h[2 * i] = True\n        visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n        visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n        k_point = mode[\"k_point\"]\n        freq    = mode[\"freq\"]\n        polarization = mode[\"polarization\"]\n\n        # Take the specified component of the fields in the center of the slab\n\n        e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n        h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n        e_field = e_field[..., component]\n        h_field = h_field[..., component]\n        e_field = np.squeeze(e_field)\n        h_field = np.squeeze(h_field)   \n\n        with suppress_output():\n            e_field = md.convert(e_field) \n            h_field = md.convert(h_field)\n\n        if quantity == \"real\":\n            e_field = np.real(e_field)\n            h_field = np.real(h_field)\n        elif quantity == \"imag\":\n            e_field = np.imag(e_field)\n            h_field = np.imag(h_field)\n        elif quantity == \"abs\":\n            e_field = np.abs(e_field)\n            h_field = np.abs(h_field)\n        else:\n            raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n        # Add the contour plot for permittivity (eps) at the midpoint\n        contour_e = go.Contour(z=eps.T,\n                            contours=dict(\n                                start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                end=midpoint,\n                                size=0.1,  # A small size to keep it as a single contour\n                                coloring='none'  # No filling\n                            ),\n                            line=dict(color='black', width=2),\n                            showscale=False,\n                            opacity=0.7,\n                            visible=True if i ==  0  else False)  # Only the first mode is visible\n        contour_h = contour_e  # Same contour for H-field figure\n\n        # Add the contour trace\n        fig_e.add_trace(contour_e)\n        fig_h.add_trace(contour_h)\n\n        # Add the heatmap for the electric field\n        heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n        # Add the heatmap for the magnetic field\n        heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n\n        # Add the heatmap trace\n        fig_e.add_trace(heatmap_e)\n        fig_h.add_trace(heatmap_h)\n\n        data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n        if component == 0: \n            component_str = \"x-component\"\n        elif component == 1:\n            component_str = \"y-component\"\n        else:\n            component_str = \"z-component\"\n        subtitle_e = f\"E-field, {component_str}, {quantity}\"\n        subtitle_h = f\"H-field, {component_str}, {quantity}\"\n        # Create a button for each field dataset for the dropdown\n        dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                    ]))\n        dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                    ]))\n    k_point = target_modes[0][\"k_point\"]\n    freq    = target_modes[0][\"freq\"]\n    data_str = f\"Mode {0} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n    fig_e.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_e,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n\n    )\n\n    fig_h.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_h,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n    )\n\n    return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.plot_field_components","title":"<code>plot_field_components(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales. For each component, the real, imaginary, or absolute value can be plotted.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the target mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the target mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the target mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>quantity</code> <code>str</code> <p>The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale to use for the plot. Default is 'RdBu'.</p> <code>'RdBu'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the electric field figure and the magnetic field figure.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field_components(self,\n                        target_polarization,\n                        target_k_point,\n                        target_frequency,\n                        frequency_tolerance=0.01,\n                        k_point_max_distance=None,\n                        periods: int = 1,\n                        quantity: str = \"real\",\n                        colorscale: str = 'RdBu',\n                        )-&gt; tuple:\n    \"\"\"\n    Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n    For each component, the real, imaginary, or absolute value can be plotted.\n\n    Args:\n        target_polarization (str): The polarization of the target mode.\n        target_k_point (tuple): The k-point of the target mode.\n        target_frequency (float): The frequency of the target mode.\n        frequency_tolerance (float): The tolerance for frequency similarity.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n        periods (int): The number of periods to extract. Default is 1.\n        quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n        colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n    Returns:\n        tuple: A tuple containing the electric field figure and the magnetic field figure.\n    \"\"\"\n\n    target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                    freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n    print(f\"Number of target modes found: {len(target_modes)}\")\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        eps = md.convert(self.ms.get_epsilon())\n\n    # Calculate the midpoint between min and max of the permittivity (eps)\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n    fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n    fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n    dropdown_buttons_e = []\n    dropdown_buttons_h = []\n\n    # For each mode, calculate separate min and max values for Ex, Ey, Ez (and similarly Hx, Hy, Hz)\n    for i, mode in enumerate(target_modes):\n        # Get field arrays for this mode\n        e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n        h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n        # Extract field components in the center of the slab\n        e_field_x = e_field_array[..., 0]  # Shape (Nx, Ny)\n        e_field_y = e_field_array[..., 1]  # Shape (Nx, Ny)\n        e_field_z = e_field_array[..., 2]  # Shape (Nx, Ny)\n        h_field_x = h_field_array[..., 0]  # Shape (Nx, Ny)\n        h_field_y = h_field_array[..., 1]  # Shape (Nx, Ny)\n        h_field_z = h_field_array[..., 2]  # Shape (Nx, Ny)\n\n        # Convert the field arrays to the correct shape\n        e_field_x = np.squeeze(e_field_x)\n        e_field_y = np.squeeze(e_field_y)\n        e_field_z = np.squeeze(e_field_z)\n        h_field_x = np.squeeze(h_field_x)\n        h_field_y = np.squeeze(h_field_y)\n        h_field_z = np.squeeze(h_field_z)\n\n\n        with suppress_output():\n            e_field_x = md.convert(e_field_x)\n            e_field_y = md.convert(e_field_y)\n            e_field_z = md.convert(e_field_z)\n            h_field_x = md.convert(h_field_x)\n            h_field_y = md.convert(h_field_y)\n            h_field_z = md.convert(h_field_z)\n\n        e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n        h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)                                    \n\n        # Select quantity to display (real, imag, abs)\n        if quantity == \"real\":\n            e_field = np.real(e_field)\n            h_field = np.real(h_field)\n        elif quantity == \"imag\":\n            e_field = np.imag(e_field)\n            h_field = np.imag(h_field)\n        elif quantity == \"abs\":\n            e_field = np.abs(e_field)\n            h_field = np.abs(h_field)\n        else:\n            raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n        # Calculate the component-specific min/max for E and H fields of this mode\n        e_min = np.min(e_field)\n        e_max = np.max(e_field)\n        h_min = np.min(h_field)\n        h_max = np.max(h_field)\n\n        # Components of the E and H fields\n        Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n        Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n        # Define visibility settings per mode, including contours as always visible\n        visible_status_e = [False] * (len(target_modes) * 6)  # 3 components per mode, with contour for each\n        visible_status_h = [False] * (len(target_modes) * 6)\n        # Make the contour visible by default\n\n\n        # Make this mode's components and the corresponding contour visible in the initial layout \n        for j in range(6):\n            visible_status_e[6*i + j] = True\n            visible_status_h[6*i + j] = True\n\n\n        # Add contour traces for permittivity to each subplot of fig_e and fig_h for this mode\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n        # Add Ex, Ey, Ez with shared colorbar limits for the E field of this mode\n        fig_e.add_trace(go.Heatmap(z=Ex.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n        fig_e.add_trace(go.Heatmap(z=Ey.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n        fig_e.add_trace(go.Heatmap(z=Ez.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"E-field\", len=0.75, thickness=15), zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n        # Add Hx, Hy, Hz with shared colorbar limits for the H field of this mode\n        fig_h.add_trace(go.Heatmap(z=Hx.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n        fig_h.add_trace(go.Heatmap(z=Hy.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n        fig_h.add_trace(go.Heatmap(z=Hz.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"H-field\", len=0.75, thickness=15), zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n\n\n        # Dropdown data for E-field\n        k_point = mode[\"k_point\"]\n        freq = mode[\"freq\"]\n        polarization = mode[\"polarization\"]\n        mode_description = f\"Mode {i + 1}&lt;br&gt;k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n        dropdown_buttons_e.append(\n            dict(label=f\"Mode {i + 1}\",\n                method='update',\n                args=[{'visible': visible_status_e},\n                    {'title': f\"{mode_description}: {quantity} of E-field components\"}]))\n\n        dropdown_buttons_h.append(\n            dict(label=f\"Mode {i + 1}\",\n                method='update',\n                args=[{'visible': visible_status_h},\n                    {'title': f\"{mode_description}: {quantity} of H-field components\"}]))\n\n    # Layout and color settings\n    fig_e.update_layout(\n        title=f\"{mode_description}: {quantity} of E-field components\",\n        updatemenus=[dict(\n            active=len(target_modes) - 1,\n            buttons=dropdown_buttons_e)],\n        coloraxis=dict(colorbar=dict(len=0.75)),\n        width=1200, height=400,\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        hovermode=\"closest\"\n    )\n\n    fig_h.update_layout(\n        title=f\"{mode_description}: {quantity} of H-field components\",\n        updatemenus=[dict(\n            active=len(target_modes) - 1,\n            buttons=dropdown_buttons_h)],\n        coloraxis=dict(colorbar=dict(len=0.75)),\n        width=1200, height=400,\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        hovermode=\"closest\"\n    )\n\n    # Final adjustments\n    fig_e.update_xaxes(showticklabels=False)\n    fig_e.update_yaxes(showticklabels=False)\n    fig_h.update_xaxes(showticklabels=False)\n    fig_h.update_yaxes(showticklabels=False)\n\n    fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n    fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n    fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n    fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n    fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n    fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n    return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.square_lattice","title":"<code>square_lattice()</code>  <code>staticmethod</code>","text":"<p>Define the square lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef square_lattice()-&gt; tuple:\n    \"\"\"\n    Define the square lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0, 1))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # M\n        mp.Vector3(0.5, 0.5),       # X\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.Crystal2D.triangular_lattice","title":"<code>triangular_lattice()</code>  <code>staticmethod</code>","text":"<p>Define the triangular lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef triangular_lattice()-&gt; tuple:\n    \"\"\"\n    Define the triangular lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # K\n        mp.Vector3(-1./3, 1./3),    # M\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab","title":"<code>CrystalSlab</code>","text":"<p>               Bases: <code>PhotonicCrystal</code></p> <p>CrystalSlab class represents a photonic crystal slab structure, inheriting from the PhotonicCrystal class. This class provides methods to define the lattice, geometry, and to plot various properties of the photonic crystal slab. Geometries can be added using mpb functions such as Cylinder, Ellipsoid, etc.</p> <p>Attributes:</p> Name Type Description <code>geometry_lattice</code> <code>Lattice</code> <p>The lattice structure of the photonic crystal.</p> <code>k_points</code> <code>list</code> <p>List of k-points for the simulation.</p> <code>geometry</code> <code>list</code> <p>List of geometric objects defining the photonic crystal.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points for the simulation.</p> <code>epsilon</code> <code>ndarray</code> <p>Dielectric function values obtained from the simulation.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the CrystalSlab object with the given parameters.</p> <code>plot_epsilon</code> <p>Plots the epsilon values obtained from the simulation using Plotly.</p> <code>basic_lattice</code> <p>Defines the basic lattice structure for the photonic crystal.</p> <code>square_lattice</code> <p>Defines the square lattice for the photonic crystal.</p> <code>triangular_lattice</code> <p>Defines the triangular lattice for the photonic crystal.</p> <code>basic_geometry</code> <p>Defines the basic geometry for the photonic crystal.</p> <code>plot_field</code> <p>Plots the field for a specific mode based on the given parameters.</p> <code>plot_field_components</code> <p>Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>class CrystalSlab(PhotonicCrystal):\n    \"\"\"\n    CrystalSlab class represents a photonic crystal slab structure, inheriting from the PhotonicCrystal class.\n    This class provides methods to define the lattice, geometry, and to plot various properties of the photonic crystal slab.\n    Geometries can be added using mpb functions such as Cylinder, Ellipsoid, etc.\n\n\n    Attributes:\n        geometry_lattice (mp.Lattice): The lattice structure of the photonic crystal.\n        k_points (list): List of k-points for the simulation.\n        geometry (list): List of geometric objects defining the photonic crystal.\n        k_points_interpolated (list): Interpolated k-points for the simulation.\n        epsilon (np.ndarray): Dielectric function values obtained from the simulation.\n\n    Methods:\n        __init__(self, lattice_type=None, num_bands=4, resolution=mp.Vector3(32,32,16), interp=2, periods=3, pickle_id=None, geometry=None, use_XY=True, k_point_max=0.2):\n            Initializes the CrystalSlab object with the given parameters.\n        plot_epsilon(self, fig=None, opacity=0.3, colorscale='PuBuGn', override_resolution_with=None, periods=1):\n            Plots the epsilon values obtained from the simulation using Plotly.\n        basic_lattice(lattice_type='square', height_supercell=4):\n            Defines the basic lattice structure for the photonic crystal.\n        square_lattice(height_supercell=4):\n            Defines the square lattice for the photonic crystal.\n        triangular_lattice(height_supercell=4):\n            Defines the triangular lattice for the photonic crystal.\n        basic_geometry(radius=0.2, material=None):\n            Defines the basic geometry for the photonic crystal.\n        plot_field(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, component=2, quantity='real', colorscale='RdBu'):\n            Plots the field for a specific mode based on the given parameters.\n        plot_field_components(self, target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', colorscale='RdBu'):\n            Plots the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n    \"\"\"\n\n    def __init__(self,\n                lattice_type = \"square\",\n                material: Crystal_Materials = None,\n                geometry = None, \n                num_bands: int = 4,\n                resolution = mp.Vector3(32,32,16),\n                interp: int =2,\n                periods: int =3, \n                pickle_id = None,\n                use_XY = True,\n                k_point_max = 0.2):\n        \"\"\"\n        Initializes the CrystalSlab object with the given parameters.\n\n        Args:\n            lattice_type (str): The type of lattice. It can be 'square' or 'triangular'. Default is 'square'.\n            material (Crystal_Materials): The material object for the photonic crystal. Default is None.\n            geometry (CrystalSlab_Geometry): The geometry of the photonic crystal. Default is None. If it is none, the basic geometry is used.\n            num_bands (int): The number of bands to calculate. Default is 4.\n            resolution (mp.Vector3): The resolution of the simulation. Default is mp.Vector3(32, 32, 16).\n            interp (int): The interpolation factor for k-points. Default is 2.\n            periods (int): The number of periods to use in some plotting functions. Default is 3.\n            pickle_id (str): The ID for pickling the simulation. Default is None.\n            use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n            k_point_max (float): The maximum k-point value. Default is 0.2.\n        \"\"\"\n\n\n        super().__init__(lattice_type, material,geometry, num_bands, resolution, interp, periods, pickle_id, use_XY)\n\n\n        self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n        if use_XY is True: \n            self.k_points = [\n                mp.Vector3(k_point_max, 0, 0),      # X\n                mp.Vector3(0, 0 ,0 ),               # Gamma\n                mp.Vector3(0, k_point_max, 0)       # Y\n            ]\n        self.geometry = geometry if geometry is not None else self.basic_geometry()\n        self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n\n    def plot_epsilon(self,\n                    fig=None, \n                    opacity=0.3, \n                    colorscale='PuBuGn', \n                    override_resolution_with = None, \n                    periods = 1,\n                    )-&gt; go.Figure:\n        \"\"\"\n        Plot the epsilon values obtained from the simulation using Plotly.\n\n        Args:\n            fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n            opacity (float, optional): The opacity of the plot. Default is 0.3.\n            colorscale (str, optional): The colorscale for the plot. Default is 'PuBuGn'.\n            override_resolution_with (int, optional): The resolution to use for plotting. You can change the resolution just for the plot, but the simulation will still use the value set in the __init__ method. Default is None.\n            periods (int, optional): The number of periods to plot. Default is 1.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n\n        if self.epsilon is None:\n\n            if override_resolution_with is None:\n                resolution = self.resolution\n            else:\n                resolution = override_resolution_with\n            md = mpb.MPBData(rectify=True, periods=periods, resolution=resolution)\n\n\n            converted_eps = md.convert(self.ms.get_epsilon())\n        else:\n            converted_eps = self.epsilon\n        self.epsilon = converted_eps\n        if fig is None:\n            fig = go.Figure()\n\n        z_points = converted_eps.shape[2]//periods\n        z_mid = converted_eps.shape[2]//2\n        epsilon = converted_eps[..., z_mid-z_points//2:z_mid+z_points//2-1] \n        print(epsilon.shape)\n        epsilon = np.transpose(epsilon,(1,0,2)) \n\n        # Create indices for x, y, z axes (meshgrid)\n        x, y, z = np.meshgrid(np.arange(epsilon.shape[0]),\n                            np.arange(epsilon.shape[1]),\n                            np.arange(epsilon.shape[2]))\n\n        # Flatten the arrays for Plotly\n        x_flat = x.flatten()\n        y_flat = y.flatten()\n        z_flat = z.flatten()\n        epsilon_flat = epsilon.flatten()\n\n        # Get the minimum and maximum values from the epsilon array (ensure they are floats)\n        isomin_value = float(np.min(epsilon_flat))\n        isomax_value = float(np.max(epsilon_flat))\n\n        # Create the 3D volume plot using Plotly\n        fig = go.Figure(data=go.Volume(\n            x=x_flat, y=y_flat, z=z_flat,\n            value=epsilon_flat,  # Use the dielectric function values\n            isomin=isomin_value,\n            isomax=isomax_value,\n            opacity=opacity,  # Adjust opacity to visualize internal structure\n            surface_count=3,  # Number of surfaces to display\n            colorscale=colorscale,  # Color scale for the dielectric function\n            colorbar=dict(title='Dielectric Constant')\n        ))\n\n        # Add layout details\n        fig.update_layout(\n            title='3D Volume Plot of Dielectric Function',\n            scene=dict(\n            xaxis=dict(title='X', visible=True),\n            yaxis=dict(title='Y', visible=True),\n            zaxis=dict(title='Z', visible=True),\n            )\n        )\n\n        fig.update_layout(height=800, width=600)\n\n        return fig\n\n    @staticmethod\n    def basic_lattice(lattice_type='square', height_supercell=4)-&gt; tuple:\n        \"\"\"\n        Define the basic lattice structure for the photonic crystal.\n\n        Args:\n            lattice_type (str): The type of lattice. Default is 'square'.\n            height_supercell (int): The height of the supercell. Default is 4.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n        \"\"\"\n\n        if lattice_type == 'square':\n            return CrystalSlab.square_lattice(height_supercell=height_supercell)\n        elif lattice_type == 'triangular':\n            return CrystalSlab.triangular_lattice(height_supercell=height_supercell)\n        else:\n            raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n\n    @staticmethod\n    def square_lattice(height_supercell=4)-&gt; tuple:\n        \"\"\"\n        Define the square lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0, 1))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # M\n            mp.Vector3(0.5, 0.5),       # X\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n    @staticmethod\n    def triangular_lattice(height_supercell=4)-&gt; tuple:\n        \"\"\"\n        Define the triangular lattice for the photonic crystal.\n\n        Returns:\n            tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n        \"\"\"\n        lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                          basis1=mp.Vector3(1, 0),\n                          basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n        k_points = [\n            mp.Vector3(),               # Gamma\n            mp.Vector3(y=0.5),          # K\n            mp.Vector3(-1./3, 1./3),    # M\n            mp.Vector3(),               # Gamma\n        ]\n        return lattice, k_points\n\n    @staticmethod \n    def basic_geometry(\n        radius = 0.2,\n        material: Crystal_Materials = None,\n    ):\n        \"\"\"\n        Define the basic geometry for the photonic crystal slab.\n\n        Args:\n            radius (float): The radius of the cylinder. Default is 0.2.\n            material (Crystal_Materials): The material object for the photonic crystal. Default is None.\n\n        Returns:\n            CrystalSlab_Geometry: The geometry object representing the photonic crystal slab.\n        \"\"\"\n\n        if material is None:\n            material = PhotonicCrystal.basic_material()\n        geometry = CrystalSlab_Geometry(material = material, geometry_type='cylinder', radius = radius)\n        return geometry\n\n\n\n\n    def plot_field(self, \n            target_polarization, \n            target_k_point, \n            target_frequency, \n            frequency_tolerance = 0.01, \n            k_point_max_distance = None,\n            periods: int=1, \n            component: int = 2, \n            quantity: str = \"real\", \n            colorscale: str = 'RdBu',                  \n            ):\n        \"\"\"\n        Plot the field for a specific mode based on the given parameters.\n\n        Args:\n            target_polarization (str): The polarization of the target mode.\n            target_k_point (tuple): The k-point of the target mode.\n            target_frequency (float): The frequency of the target mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            periods (int): The number of periods to extract. Default is 1.\n            component (int): The component of the field to plot (0 for x, 1 for y, 2 for z). Default is 2.\n            quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n            colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n        Returns:\n            tuple: A tuple containing the electric field figure and the magnetic field figure.\n        \"\"\"\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, freq_tolerance = frequency_tolerance, k_point_max_distance = k_point_max_distance)\n        #print(len(target_modes))\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon()) \n\n        z_points = eps.shape[2] // periods\n        z_mid = eps.shape[2] // 2\n\n        # Now take only epsilon in the center of the slab\n        eps = eps[..., z_mid]\n        # Calculate the midpoint between min and max of the permittivity (eps)\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        num_plots = len(target_modes)\n\n        for i, mode in enumerate(target_modes):\n            # Initialize visibility status: False for all traces\n            visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n            visible_status_h = [False] * (2 * num_plots)\n\n            visible_status_e[2 * i] = True  # Set the contour plot visible\n            visible_status_h[2 * i] = True\n            visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n            visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n            k_point = mode[\"k_point\"]\n            freq    = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n\n            # Take the specified component of the fields in the center of the slab\n\n            e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n            h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n            e_field = e_field[..., z_points // 2, component]\n            h_field = h_field[..., z_points // 2, component]\n            with suppress_output():\n                e_field = md.convert(e_field) \n                h_field = md.convert(h_field)\n\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n            # Add the contour plot for permittivity (eps) at the midpoint\n            contour_e = go.Contour(z=eps.T,\n                                contours=dict(\n                                    start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                    end=midpoint,\n                                    size=0.1,  # A small size to keep it as a single contour\n                                    coloring='none'  # No filling\n                                ),\n                                line=dict(color='black', width=2),\n                                showscale=False,\n                                opacity=0.7,\n                                visible=True if i ==  0  else False)  # Only the first mode is visible\n            contour_h = contour_e  # Same contour for H-field figure\n\n            # Add the contour trace\n            fig_e.add_trace(contour_e)\n            fig_h.add_trace(contour_h)\n\n            # Add the heatmap for the electric field\n            heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n            # Add the heatmap for the magnetic field\n            heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                    showscale=True, visible= True if i == 0 else False)\n\n            # Add the heatmap trace\n            fig_e.add_trace(heatmap_e)\n            fig_h.add_trace(heatmap_h)\n\n\n\n            data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n            if component == 0: \n                component_str = \"x-component\"\n            elif component == 1:\n                component_str = \"y-component\"\n            else:\n                component_str = \"z-component\"\n            subtitle_e = f\"E-field, {component_str}, {quantity}\"\n            subtitle_h = f\"H-field, {component_str}, {quantity}\"\n            # Create a button for each field dataset for the dropdown\n            dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                        ]))\n            dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                        method='update',\n                                        args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                            {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                        ]))\n\n        # print(len(target_modes))\n        k_point = target_modes[0][\"k_point\"]\n        freq    = target_modes[0][\"freq\"]\n        data_str = f\"Mode {0} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n        fig_e.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_e,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n\n        )\n\n        fig_h.update_layout(\n            updatemenus=[dict(active=0,\n                            buttons=dropdown_buttons_h,\n                            x=1.15, y=1.15,\n                            xanchor='left', yanchor='top')],\n            title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            xaxis_visible=False, yaxis_visible=False,\n            hovermode=\"closest\",\n            width=800, height=800,\n            xaxis_title=\"X\",\n            yaxis_title=\"Y\"\n        )\n\n        return fig_e, fig_h\n\n\n\n    def plot_field_components(self,\n                            target_polarization,\n                            target_k_point,\n                            target_frequency,\n                            frequency_tolerance=0.01,\n                            k_point_max_distance=None,\n                            periods: int = 1,\n                            quantity: str = \"real\",\n                            colorscale: str = 'RdBu',\n                            )-&gt; tuple:\n        \"\"\"\n        Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n\n        Args:\n            target_polarization (str): The polarization of the target mode.\n            target_k_point (tuple): The k-point of the target mode.\n            target_frequency (float): The frequency of the target mode.\n            frequency_tolerance (float): The tolerance for frequency similarity.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 1.\n            quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n            colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n        Returns:\n            tuple: A tuple containing the electric field figure and the magnetic field figure.\n        \"\"\"\n\n        target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                        freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n        print(f\"Number of target modes found: {len(target_modes)}\")\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            eps = md.convert(self.ms.get_epsilon())\n\n        z_points = eps.shape[2] // periods\n        z_mid = eps.shape[2] // 2\n\n        # Now take only epsilon in the center of the slab\n        eps = eps[..., z_mid]\n        # Calculate the midpoint between min and max of the permittivity (eps)\n        min_eps, max_eps = np.min(eps), np.max(eps)\n        midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n        fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n        fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n        dropdown_buttons_e = []\n        dropdown_buttons_h = []\n\n        # For each mode, calculate separate min and max values for Ex, Ey, Ez (and similarly Hx, Hy, Hz)\n        for i, mode in enumerate(target_modes):\n            # Get field arrays for this mode\n            e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n            # Extract field components in the center of the slab\n            e_field_x = e_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n            e_field_y = e_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n            e_field_z = e_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n            h_field_x = h_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n            h_field_y = h_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n            h_field_z = h_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n\n            with suppress_output():\n                e_field_x = md.convert(e_field_x)\n                e_field_y = md.convert(e_field_y)\n                e_field_z = md.convert(e_field_z)\n                h_field_x = md.convert(h_field_x)\n                h_field_y = md.convert(h_field_y)\n                h_field_z = md.convert(h_field_z)\n\n            e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n            h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)                                    \n\n            # Select quantity to display (real, imag, abs)\n            if quantity == \"real\":\n                e_field = np.real(e_field)\n                h_field = np.real(h_field)\n            elif quantity == \"imag\":\n                e_field = np.imag(e_field)\n                h_field = np.imag(h_field)\n            elif quantity == \"abs\":\n                e_field = np.abs(e_field)\n                h_field = np.abs(h_field)\n            else:\n                raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n            # Calculate the component-specific min/max for E and H fields of this mode\n            e_min = np.min(e_field)\n            e_max = np.max(e_field)\n            h_min = np.min(h_field)\n            h_max = np.max(h_field)\n\n            # Components of the E and H fields\n            Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n            Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n            # Define visibility settings per mode, including contours as always visible\n            visible_status_e = [False] * (len(target_modes) * 6)  # 3 components per mode, with contour for each\n            visible_status_h = [False] * (len(target_modes) * 6)\n            # Make the contour visible by default\n\n\n\n\n            # Make this mode's components and the corresponding contour visible in the initial layout \n            for j in range(6):\n                visible_status_e[6*i + j] = True\n                visible_status_h[6*i + j] = True\n\n\n            # Add contour traces for permittivity to each subplot of fig_e and fig_h for this mode\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n            fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n            fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n            # Add Ex, Ey, Ez with shared colorbar limits for the E field of this mode\n            fig_e.add_trace(go.Heatmap(z=Ex.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n            fig_e.add_trace(go.Heatmap(z=Ey.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n            fig_e.add_trace(go.Heatmap(z=Ez.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"E-field\", len=0.75, thickness=15), zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n            # Add Hx, Hy, Hz with shared colorbar limits for the H field of this mode\n            fig_h.add_trace(go.Heatmap(z=Hx.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n            fig_h.add_trace(go.Heatmap(z=Hy.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n            fig_h.add_trace(go.Heatmap(z=Hz.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"H-field\", len=0.75, thickness=15), zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n\n\n            # Dropdown data for E-field\n            k_point = mode[\"k_point\"]\n            freq = mode[\"freq\"]\n            polarization = mode[\"polarization\"]\n            mode_description = f\"Mode {i + 1}&lt;br&gt;k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n            dropdown_buttons_e.append(\n                dict(label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[{'visible': visible_status_e},\n                        {'title': f\"{mode_description}: {quantity} of E-field components\"}]))\n\n            dropdown_buttons_h.append(\n                dict(label=f\"Mode {i + 1}\",\n                    method='update',\n                    args=[{'visible': visible_status_h},\n                        {'title': f\"{mode_description}: {quantity} of H-field components\"}]))\n\n        # Layout and color settings\n        fig_e.update_layout(\n            title=f\"{mode_description}: {quantity} of E-field components\",\n            updatemenus=[dict(\n                active=len(target_modes) - 1,\n                buttons=dropdown_buttons_e)],\n            coloraxis=dict(colorbar=dict(len=0.75)),\n            width=1200, height=400,\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        fig_h.update_layout(\n            title=f\"{mode_description}: {quantity} of H-field components\",\n            updatemenus=[dict(\n                active=len(target_modes) - 1,\n                buttons=dropdown_buttons_h)],\n            coloraxis=dict(colorbar=dict(len=0.75)),\n            width=1200, height=400,\n            xaxis_showgrid=False, yaxis_showgrid=False,\n            xaxis_zeroline=False, yaxis_zeroline=False,\n            hovermode=\"closest\"\n        )\n\n        # Final adjustments\n        fig_e.update_xaxes(showticklabels=False)\n        fig_e.update_yaxes(showticklabels=False)\n        fig_h.update_xaxes(showticklabels=False)\n        fig_h.update_yaxes(showticklabels=False)\n\n        fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n        fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n        fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n        fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n        fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n        fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n        fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n        fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n        return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.__init__","title":"<code>__init__(lattice_type='square', material=None, geometry=None, num_bands=4, resolution=mp.Vector3(32, 32, 16), interp=2, periods=3, pickle_id=None, use_XY=True, k_point_max=0.2)</code>","text":"<p>Initializes the CrystalSlab object with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. It can be 'square' or 'triangular'. Default is 'square'.</p> <code>'square'</code> <code>material</code> <code>Crystal_Materials</code> <p>The material object for the photonic crystal. Default is None.</p> <code>None</code> <code>geometry</code> <code>CrystalSlab_Geometry</code> <p>The geometry of the photonic crystal. Default is None. If it is none, the basic geometry is used.</p> <code>None</code> <code>num_bands</code> <code>int</code> <p>The number of bands to calculate. Default is 4.</p> <code>4</code> <code>resolution</code> <code>Vector3</code> <p>The resolution of the simulation. Default is mp.Vector3(32, 32, 16).</p> <code>Vector3(32, 32, 16)</code> <code>interp</code> <code>int</code> <p>The interpolation factor for k-points. Default is 2.</p> <code>2</code> <code>periods</code> <code>int</code> <p>The number of periods to use in some plotting functions. Default is 3.</p> <code>3</code> <code>pickle_id</code> <code>str</code> <p>The ID for pickling the simulation. Default is None.</p> <code>None</code> <code>use_XY</code> <code>bool</code> <p>Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.</p> <code>True</code> <code>k_point_max</code> <code>float</code> <p>The maximum k-point value. Default is 0.2.</p> <code>0.2</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def __init__(self,\n            lattice_type = \"square\",\n            material: Crystal_Materials = None,\n            geometry = None, \n            num_bands: int = 4,\n            resolution = mp.Vector3(32,32,16),\n            interp: int =2,\n            periods: int =3, \n            pickle_id = None,\n            use_XY = True,\n            k_point_max = 0.2):\n    \"\"\"\n    Initializes the CrystalSlab object with the given parameters.\n\n    Args:\n        lattice_type (str): The type of lattice. It can be 'square' or 'triangular'. Default is 'square'.\n        material (Crystal_Materials): The material object for the photonic crystal. Default is None.\n        geometry (CrystalSlab_Geometry): The geometry of the photonic crystal. Default is None. If it is none, the basic geometry is used.\n        num_bands (int): The number of bands to calculate. Default is 4.\n        resolution (mp.Vector3): The resolution of the simulation. Default is mp.Vector3(32, 32, 16).\n        interp (int): The interpolation factor for k-points. Default is 2.\n        periods (int): The number of periods to use in some plotting functions. Default is 3.\n        pickle_id (str): The ID for pickling the simulation. Default is None.\n        use_XY (bool): Whether to use the X and Y directions for the x-axis or high symmetry points. Default is True.\n        k_point_max (float): The maximum k-point value. Default is 0.2.\n    \"\"\"\n\n\n    super().__init__(lattice_type, material,geometry, num_bands, resolution, interp, periods, pickle_id, use_XY)\n\n\n    self.geometry_lattice, self.k_points = self.basic_lattice(lattice_type)\n    if use_XY is True: \n        self.k_points = [\n            mp.Vector3(k_point_max, 0, 0),      # X\n            mp.Vector3(0, 0 ,0 ),               # Gamma\n            mp.Vector3(0, k_point_max, 0)       # Y\n        ]\n    self.geometry = geometry if geometry is not None else self.basic_geometry()\n    self.k_points_interpolated = mp.interpolate(interp, self.k_points)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.basic_geometry","title":"<code>basic_geometry(radius=0.2, material=None)</code>  <code>staticmethod</code>","text":"<p>Define the basic geometry for the photonic crystal slab.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius of the cylinder. Default is 0.2.</p> <code>0.2</code> <code>material</code> <code>Crystal_Materials</code> <p>The material object for the photonic crystal. Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CrystalSlab_Geometry</code> <p>The geometry object representing the photonic crystal slab.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod \ndef basic_geometry(\n    radius = 0.2,\n    material: Crystal_Materials = None,\n):\n    \"\"\"\n    Define the basic geometry for the photonic crystal slab.\n\n    Args:\n        radius (float): The radius of the cylinder. Default is 0.2.\n        material (Crystal_Materials): The material object for the photonic crystal. Default is None.\n\n    Returns:\n        CrystalSlab_Geometry: The geometry object representing the photonic crystal slab.\n    \"\"\"\n\n    if material is None:\n        material = PhotonicCrystal.basic_material()\n    geometry = CrystalSlab_Geometry(material = material, geometry_type='cylinder', radius = radius)\n    return geometry\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.basic_lattice","title":"<code>basic_lattice(lattice_type='square', height_supercell=4)</code>  <code>staticmethod</code>","text":"<p>Define the basic lattice structure for the photonic crystal.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>The type of lattice. Default is 'square'.</p> <code>'square'</code> <code>height_supercell</code> <code>int</code> <p>The height of the supercell. Default is 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_lattice(lattice_type='square', height_supercell=4)-&gt; tuple:\n    \"\"\"\n    Define the basic lattice structure for the photonic crystal.\n\n    Args:\n        lattice_type (str): The type of lattice. Default is 'square'.\n        height_supercell (int): The height of the supercell. Default is 4.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the lattice and a list of k-points for the simulation.\n    \"\"\"\n\n    if lattice_type == 'square':\n        return CrystalSlab.square_lattice(height_supercell=height_supercell)\n    elif lattice_type == 'triangular':\n        return CrystalSlab.triangular_lattice(height_supercell=height_supercell)\n    else:\n        raise ValueError(\"Invalid lattice type. Choose 'square' or 'triangular'.\")\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.plot_epsilon","title":"<code>plot_epsilon(fig=None, opacity=0.3, colorscale='PuBuGn', override_resolution_with=None, periods=1)</code>","text":"<p>Plot the epsilon values obtained from the simulation using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the epsilon plot to. Default is None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>The opacity of the plot. Default is 0.3.</p> <code>0.3</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the plot. Default is 'PuBuGn'.</p> <code>'PuBuGn'</code> <code>override_resolution_with</code> <code>int</code> <p>The resolution to use for plotting. You can change the resolution just for the plot, but the simulation will still use the value set in the init method. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to plot. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_epsilon(self,\n                fig=None, \n                opacity=0.3, \n                colorscale='PuBuGn', \n                override_resolution_with = None, \n                periods = 1,\n                )-&gt; go.Figure:\n    \"\"\"\n    Plot the epsilon values obtained from the simulation using Plotly.\n\n    Args:\n        fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n        opacity (float, optional): The opacity of the plot. Default is 0.3.\n        colorscale (str, optional): The colorscale for the plot. Default is 'PuBuGn'.\n        override_resolution_with (int, optional): The resolution to use for plotting. You can change the resolution just for the plot, but the simulation will still use the value set in the __init__ method. Default is None.\n        periods (int, optional): The number of periods to plot. Default is 1.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n\n    if self.epsilon is None:\n\n        if override_resolution_with is None:\n            resolution = self.resolution\n        else:\n            resolution = override_resolution_with\n        md = mpb.MPBData(rectify=True, periods=periods, resolution=resolution)\n\n\n        converted_eps = md.convert(self.ms.get_epsilon())\n    else:\n        converted_eps = self.epsilon\n    self.epsilon = converted_eps\n    if fig is None:\n        fig = go.Figure()\n\n    z_points = converted_eps.shape[2]//periods\n    z_mid = converted_eps.shape[2]//2\n    epsilon = converted_eps[..., z_mid-z_points//2:z_mid+z_points//2-1] \n    print(epsilon.shape)\n    epsilon = np.transpose(epsilon,(1,0,2)) \n\n    # Create indices for x, y, z axes (meshgrid)\n    x, y, z = np.meshgrid(np.arange(epsilon.shape[0]),\n                        np.arange(epsilon.shape[1]),\n                        np.arange(epsilon.shape[2]))\n\n    # Flatten the arrays for Plotly\n    x_flat = x.flatten()\n    y_flat = y.flatten()\n    z_flat = z.flatten()\n    epsilon_flat = epsilon.flatten()\n\n    # Get the minimum and maximum values from the epsilon array (ensure they are floats)\n    isomin_value = float(np.min(epsilon_flat))\n    isomax_value = float(np.max(epsilon_flat))\n\n    # Create the 3D volume plot using Plotly\n    fig = go.Figure(data=go.Volume(\n        x=x_flat, y=y_flat, z=z_flat,\n        value=epsilon_flat,  # Use the dielectric function values\n        isomin=isomin_value,\n        isomax=isomax_value,\n        opacity=opacity,  # Adjust opacity to visualize internal structure\n        surface_count=3,  # Number of surfaces to display\n        colorscale=colorscale,  # Color scale for the dielectric function\n        colorbar=dict(title='Dielectric Constant')\n    ))\n\n    # Add layout details\n    fig.update_layout(\n        title='3D Volume Plot of Dielectric Function',\n        scene=dict(\n        xaxis=dict(title='X', visible=True),\n        yaxis=dict(title='Y', visible=True),\n        zaxis=dict(title='Z', visible=True),\n        )\n    )\n\n    fig.update_layout(height=800, width=600)\n\n    return fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.plot_field","title":"<code>plot_field(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, component=2, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the field for a specific mode based on the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the target mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the target mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the target mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>component</code> <code>int</code> <p>The component of the field to plot (0 for x, 1 for y, 2 for z). Default is 2.</p> <code>2</code> <code>quantity</code> <code>str</code> <p>The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale to use for the plot. Default is 'RdBu'.</p> <code>'RdBu'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the electric field figure and the magnetic field figure.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field(self, \n        target_polarization, \n        target_k_point, \n        target_frequency, \n        frequency_tolerance = 0.01, \n        k_point_max_distance = None,\n        periods: int=1, \n        component: int = 2, \n        quantity: str = \"real\", \n        colorscale: str = 'RdBu',                  \n        ):\n    \"\"\"\n    Plot the field for a specific mode based on the given parameters.\n\n    Args:\n        target_polarization (str): The polarization of the target mode.\n        target_k_point (tuple): The k-point of the target mode.\n        target_frequency (float): The frequency of the target mode.\n        frequency_tolerance (float): The tolerance for frequency similarity.\n        periods (int): The number of periods to extract. Default is 1.\n        component (int): The component of the field to plot (0 for x, 1 for y, 2 for z). Default is 2.\n        quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n        colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n    Returns:\n        tuple: A tuple containing the electric field figure and the magnetic field figure.\n    \"\"\"\n    target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency, freq_tolerance = frequency_tolerance, k_point_max_distance = k_point_max_distance)\n    #print(len(target_modes))\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        eps = md.convert(self.ms.get_epsilon()) \n\n    z_points = eps.shape[2] // periods\n    z_mid = eps.shape[2] // 2\n\n    # Now take only epsilon in the center of the slab\n    eps = eps[..., z_mid]\n    # Calculate the midpoint between min and max of the permittivity (eps)\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n    dropdown_buttons_e = []\n    dropdown_buttons_h = []\n\n    num_plots = len(target_modes)\n\n    for i, mode in enumerate(target_modes):\n        # Initialize visibility status: False for all traces\n        visible_status_e = [False] * (2 * num_plots)  # Each mode adds two traces\n        visible_status_h = [False] * (2 * num_plots)\n\n        visible_status_e[2 * i] = True  # Set the contour plot visible\n        visible_status_h[2 * i] = True\n        visible_status_e[2 * i + 1] = True  # Set the heatmap visible\n        visible_status_h[2 * i + 1] = True  # Set the heatmap visible\n\n        k_point = mode[\"k_point\"]\n        freq    = mode[\"freq\"]\n        polarization = mode[\"polarization\"]\n\n        # Take the specified component of the fields in the center of the slab\n\n        e_field = mpb.MPBArray(mode[\"e_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"] )\n        h_field = mpb.MPBArray(mode[\"h_field\"], lattice = self.ms.get_lattice(),  kpoint = mode[\"k_point\"])\n        e_field = e_field[..., z_points // 2, component]\n        h_field = h_field[..., z_points // 2, component]\n        with suppress_output():\n            e_field = md.convert(e_field) \n            h_field = md.convert(h_field)\n\n        if quantity == \"real\":\n            e_field = np.real(e_field)\n            h_field = np.real(h_field)\n        elif quantity == \"imag\":\n            e_field = np.imag(e_field)\n            h_field = np.imag(h_field)\n        elif quantity == \"abs\":\n            e_field = np.abs(e_field)\n            h_field = np.abs(h_field)\n        else:\n            raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n        # Add the contour plot for permittivity (eps) at the midpoint\n        contour_e = go.Contour(z=eps.T,\n                            contours=dict(\n                                start=midpoint,  # Start and end at the midpoint to ensure a single level\n                                end=midpoint,\n                                size=0.1,  # A small size to keep it as a single contour\n                                coloring='none'  # No filling\n                            ),\n                            line=dict(color='black', width=2),\n                            showscale=False,\n                            opacity=0.7,\n                            visible=True if i ==  0  else False)  # Only the first mode is visible\n        contour_h = contour_e  # Same contour for H-field figure\n\n        # Add the contour trace\n        fig_e.add_trace(contour_e)\n        fig_h.add_trace(contour_h)\n\n        # Add the heatmap for the electric field\n        heatmap_e = go.Heatmap(z=e_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n        # Add the heatmap for the magnetic field\n        heatmap_h = go.Heatmap(z=h_field.T, colorscale=colorscale, zsmooth='best', opacity=0.9,\n                                showscale=True, visible= True if i == 0 else False)\n\n        # Add the heatmap trace\n        fig_e.add_trace(heatmap_e)\n        fig_h.add_trace(heatmap_h)\n\n\n\n        data_str = f\"Mode {i + 1} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n        if component == 0: \n            component_str = \"x-component\"\n        elif component == 1:\n            component_str = \"y-component\"\n        else:\n            component_str = \"z-component\"\n        subtitle_e = f\"E-field, {component_str}, {quantity}\"\n        subtitle_h = f\"H-field, {component_str}, {quantity}\"\n        # Create a button for each field dataset for the dropdown\n        dropdown_buttons_e.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_e},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_e}\"}\n                                    ]))\n        dropdown_buttons_h.append(dict(label=f'Mode {i + 1}',\n                                    method='update',\n                                    args=[{'visible': visible_status_h},  # Update visibility for both eps and field\n                                        {'title':f\"{data_str}:&lt;br&gt; {subtitle_h}\"}\n                                    ]))\n\n    # print(len(target_modes))\n    k_point = target_modes[0][\"k_point\"]\n    freq    = target_modes[0][\"freq\"]\n    data_str = f\"Mode {0} &lt;br&gt; k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n    fig_e.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_e,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_e}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n\n    )\n\n    fig_h.update_layout(\n        updatemenus=[dict(active=0,\n                        buttons=dropdown_buttons_h,\n                        x=1.15, y=1.15,\n                        xanchor='left', yanchor='top')],\n        title=f\"{data_str}:&lt;br&gt; {subtitle_h}\",\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        xaxis_visible=False, yaxis_visible=False,\n        hovermode=\"closest\",\n        width=800, height=800,\n        xaxis_title=\"X\",\n        yaxis_title=\"Y\"\n    )\n\n    return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.plot_field_components","title":"<code>plot_field_components(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the target mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the target mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the target mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>quantity</code> <code>str</code> <p>The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale to use for the plot. Default is 'RdBu'.</p> <code>'RdBu'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the electric field figure and the magnetic field figure.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field_components(self,\n                        target_polarization,\n                        target_k_point,\n                        target_frequency,\n                        frequency_tolerance=0.01,\n                        k_point_max_distance=None,\n                        periods: int = 1,\n                        quantity: str = \"real\",\n                        colorscale: str = 'RdBu',\n                        )-&gt; tuple:\n    \"\"\"\n    Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n\n    Args:\n        target_polarization (str): The polarization of the target mode.\n        target_k_point (tuple): The k-point of the target mode.\n        target_frequency (float): The frequency of the target mode.\n        frequency_tolerance (float): The tolerance for frequency similarity.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n        periods (int): The number of periods to extract. Default is 1.\n        quantity (str): The quantity to plot ('real', 'imag', or 'abs'). Default is 'real'.\n        colorscale (str): The colorscale to use for the plot. Default is 'RdBu'.\n\n    Returns:\n        tuple: A tuple containing the electric field figure and the magnetic field figure.\n    \"\"\"\n\n    target_modes = self.look_for_mode(target_polarization, target_k_point, target_frequency,\n                                    freq_tolerance=frequency_tolerance, k_point_max_distance=k_point_max_distance)\n    print(f\"Number of target modes found: {len(target_modes)}\")\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        eps = md.convert(self.ms.get_epsilon())\n\n    z_points = eps.shape[2] // periods\n    z_mid = eps.shape[2] // 2\n\n    # Now take only epsilon in the center of the slab\n    eps = eps[..., z_mid]\n    # Calculate the midpoint between min and max of the permittivity (eps)\n    min_eps, max_eps = np.min(eps), np.max(eps)\n    midpoint = (min_eps + max_eps) / 2  # The level to be plotted\n\n    fig_e = make_subplots(rows=1, cols=3, subplot_titles=(\"Ex\", \"Ey\", \"Ez\"))\n    fig_h = make_subplots(rows=1, cols=3, subplot_titles=(\"Hx\", \"Hy\", \"Hz\"))\n    dropdown_buttons_e = []\n    dropdown_buttons_h = []\n\n    # For each mode, calculate separate min and max values for Ex, Ey, Ez (and similarly Hx, Hy, Hz)\n    for i, mode in enumerate(target_modes):\n        # Get field arrays for this mode\n        e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n        h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n        # Extract field components in the center of the slab\n        e_field_x = e_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n        e_field_y = e_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n        e_field_z = e_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n        h_field_x = h_field_array[..., z_points // 2, 0]  # Shape (Nx, Ny)\n        h_field_y = h_field_array[..., z_points // 2, 1]  # Shape (Nx, Ny)\n        h_field_z = h_field_array[..., z_points // 2, 2]  # Shape (Nx, Ny)\n\n        with suppress_output():\n            e_field_x = md.convert(e_field_x)\n            e_field_y = md.convert(e_field_y)\n            e_field_z = md.convert(e_field_z)\n            h_field_x = md.convert(h_field_x)\n            h_field_y = md.convert(h_field_y)\n            h_field_z = md.convert(h_field_z)\n\n        e_field = np.stack([e_field_x, e_field_y, e_field_z], axis=-1)\n        h_field = np.stack([h_field_x, h_field_y, h_field_z], axis=-1)                                    \n\n        # Select quantity to display (real, imag, abs)\n        if quantity == \"real\":\n            e_field = np.real(e_field)\n            h_field = np.real(h_field)\n        elif quantity == \"imag\":\n            e_field = np.imag(e_field)\n            h_field = np.imag(h_field)\n        elif quantity == \"abs\":\n            e_field = np.abs(e_field)\n            h_field = np.abs(h_field)\n        else:\n            raise ValueError(\"Invalid quantity. Choose 'real', 'imag', or 'abs'.\")\n\n        # Calculate the component-specific min/max for E and H fields of this mode\n        e_min = np.min(e_field)\n        e_max = np.max(e_field)\n        h_min = np.min(h_field)\n        h_max = np.max(h_field)\n\n        # Components of the E and H fields\n        Ex, Ey, Ez = e_field[..., 0], e_field[..., 1], e_field[..., 2]\n        Hx, Hy, Hz = h_field[..., 0], h_field[..., 1], h_field[..., 2]\n\n        # Define visibility settings per mode, including contours as always visible\n        visible_status_e = [False] * (len(target_modes) * 6)  # 3 components per mode, with contour for each\n        visible_status_h = [False] * (len(target_modes) * 6)\n        # Make the contour visible by default\n\n\n\n\n        # Make this mode's components and the corresponding contour visible in the initial layout \n        for j in range(6):\n            visible_status_e[6*i + j] = True\n            visible_status_h[6*i + j] = True\n\n\n        # Add contour traces for permittivity to each subplot of fig_e and fig_h for this mode\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n        fig_e.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=1)\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=2)\n        fig_h.add_trace(go.Contour(z=eps.T, contours=dict(start=midpoint, end=midpoint, size=0.1, coloring='none'), line=dict(color='black', width=2), showscale=False, opacity=0.7, showlegend=False, visible=True if i == len(target_modes)-1 else False), row=1, col=3)\n\n        # Add Ex, Ey, Ez with shared colorbar limits for the E field of this mode\n        fig_e.add_trace(go.Heatmap(z=Ex.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n        fig_e.add_trace(go.Heatmap(z=Ey.T, colorscale=colorscale, showscale=False, zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n        fig_e.add_trace(go.Heatmap(z=Ez.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"E-field\", len=0.75, thickness=15), zmin=e_min, zmax=e_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n        # Add Hx, Hy, Hz with shared colorbar limits for the H field of this mode\n        fig_h.add_trace(go.Heatmap(z=Hx.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=1)\n        fig_h.add_trace(go.Heatmap(z=Hy.T, colorscale=colorscale, showscale=False, zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=2)\n        fig_h.add_trace(go.Heatmap(z=Hz.T, colorscale=colorscale, showscale=True, colorbar=dict(title=\"H-field\", len=0.75, thickness=15), zmin=h_min, zmax=h_max, visible=True if i == len(target_modes)-1 else False, zsmooth=\"best\", opacity=0.8), row=1, col=3)\n\n\n\n        # Dropdown data for E-field\n        k_point = mode[\"k_point\"]\n        freq = mode[\"freq\"]\n        polarization = mode[\"polarization\"]\n        mode_description = f\"Mode {i + 1}&lt;br&gt;k = [{k_point[0]:0.2f}, {k_point[1]:0.2f}], freq={freq:0.3f}, polarization={polarization}\"\n\n        dropdown_buttons_e.append(\n            dict(label=f\"Mode {i + 1}\",\n                method='update',\n                args=[{'visible': visible_status_e},\n                    {'title': f\"{mode_description}: {quantity} of E-field components\"}]))\n\n        dropdown_buttons_h.append(\n            dict(label=f\"Mode {i + 1}\",\n                method='update',\n                args=[{'visible': visible_status_h},\n                    {'title': f\"{mode_description}: {quantity} of H-field components\"}]))\n\n    # Layout and color settings\n    fig_e.update_layout(\n        title=f\"{mode_description}: {quantity} of E-field components\",\n        updatemenus=[dict(\n            active=len(target_modes) - 1,\n            buttons=dropdown_buttons_e)],\n        coloraxis=dict(colorbar=dict(len=0.75)),\n        width=1200, height=400,\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        hovermode=\"closest\"\n    )\n\n    fig_h.update_layout(\n        title=f\"{mode_description}: {quantity} of H-field components\",\n        updatemenus=[dict(\n            active=len(target_modes) - 1,\n            buttons=dropdown_buttons_h)],\n        coloraxis=dict(colorbar=dict(len=0.75)),\n        width=1200, height=400,\n        xaxis_showgrid=False, yaxis_showgrid=False,\n        xaxis_zeroline=False, yaxis_zeroline=False,\n        hovermode=\"closest\"\n    )\n\n    # Final adjustments\n    fig_e.update_xaxes(showticklabels=False)\n    fig_e.update_yaxes(showticklabels=False)\n    fig_h.update_xaxes(showticklabels=False)\n    fig_h.update_yaxes(showticklabels=False)\n\n    fig_e.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n    fig_h.update_layout(yaxis_scaleanchor=\"x\", yaxis_scaleratio=1)\n    fig_e.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n    fig_h.update_layout(yaxis2_scaleanchor=\"x2\", yaxis2_scaleratio=1)\n    fig_e.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n    fig_h.update_layout(yaxis3_scaleanchor=\"x3\", yaxis3_scaleratio=1)\n\n\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n    fig_e.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n    fig_e.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=1)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=1)\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=2)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=2)\n    fig_h.update_xaxes(title_text=\"X-axis\", row=1, col=3)\n    fig_h.update_yaxes(title_text=\"Y-axis\", row=1, col=3)\n\n    return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.square_lattice","title":"<code>square_lattice(height_supercell=4)</code>  <code>staticmethod</code>","text":"<p>Define the square lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef square_lattice(height_supercell=4)-&gt; tuple:\n    \"\"\"\n    Define the square lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the square lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0, 1))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # M\n        mp.Vector3(0.5, 0.5),       # X\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.CrystalSlab.triangular_lattice","title":"<code>triangular_lattice(height_supercell=4)</code>  <code>staticmethod</code>","text":"<p>Define the triangular lattice for the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef triangular_lattice(height_supercell=4)-&gt; tuple:\n    \"\"\"\n    Define the triangular lattice for the photonic crystal.\n\n    Returns:\n        tuple: A tuple containing the lattice object representing the triangular lattice and a list of k-points for the simulation.\n    \"\"\"\n    lattice = mp.Lattice(size=mp.Vector3(1, 1, height_supercell),\n                      basis1=mp.Vector3(1, 0),\n                      basis2=mp.Vector3(0.5, math.sqrt(3)/2))\n    k_points = [\n        mp.Vector3(),               # Gamma\n        mp.Vector3(y=0.5),          # K\n        mp.Vector3(-1./3, 1./3),    # M\n        mp.Vector3(),               # Gamma\n    ]\n    return lattice, k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal","title":"<code>PhotonicCrystal</code>","text":"<p>A class to represent a photonic crystal and perform simulations using MPB (MIT Photonic Bands).</p> <p>Attributes:</p> Name Type Description <code>lattice_type</code> <code>str</code> <p>Type of the lattice.</p> <code>num_bands</code> <code>int</code> <p>Number of bands.</p> <code>resolution</code> <code>tuple[int, int] | int</code> <p>Resolution of the simulation.</p> <code>interp</code> <code>int</code> <p>Interpolation factor for k-points.</p> <code>periods</code> <code>int</code> <p>Number of periods.</p> <code>pickle_id</code> <code>str</code> <p>Identifier for pickling.</p> <code>has_been_run</code> <code>bool</code> <p>Flag indicating if the simulation has been run.</p> <code>geometry_lattice</code> <code>None</code> <p>Geometry lattice, set with basic lattice method.</p> <code>k_points</code> <code>list</code> <p>List of k-points.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points.</p> <code>material</code> <code>Crystal_Materials</code> <p>Material of the photonic crystal.</p> <code>geometry</code> <code>Crystal_Geometry</code> <p>Geometry of the photonic crystal.</p> <code>ms</code> <code>None</code> <p>Placeholder for ms attribute.</p> <code>md</code> <code>None</code> <p>Placeholder for md attribute.</p> <code>freqs</code> <code>dict</code> <p>Dictionary to store frequencies.</p> <code>gaps</code> <code>dict</code> <p>Dictionary to store gaps.</p> <code>epsilon</code> <code>None</code> <p>Placeholder for epsilon attribute.</p> <code>modes</code> <code>list</code> <p>List to store modes.</p> <code>use_XY</code> <code>bool</code> <p>Flag to use XY plane.</p> <p>Methods:</p> Name Description <code>__getstate__</code> <p>Get the state for pickling.</p> <code>__setstate__</code> <p>Set the state after unpickling.</p> <code>pickle_photonic_crystal</code> <p>Pickle the photonic crystal object.</p> <code>load_photonic_crystal</code> <p>Load a pickled photonic crystal object.</p> <code>set_solver</code> <p>Set the mode solver for the simulation.</p> <code>run_simulation</code> <p>Run the simulation to calculate the frequencies and gaps.</p> <code>run_simulation_with_output</code> <p>Run the simulation and get mode data.</p> <code>run_dumb_simulation</code> <p>Run a dumb simulation to quickly extract some values.</p> <code>convert_mode_fields</code> <p>Convert the mode fields to arrays for visualization.</p> <code>extract_data</code> <p>Extract the data from the simulation.</p> <code>plot_epsilon</code> <p>Plot the epsilon of the photonic crystal interactively using Plotly.</p> <code>plot_bands</code> <p>Plot the bands of the photonic crystal using Plotly.</p> <code>get_XY_k_points_near_gamma</code> <p>Get the relevant k-points near the gamma point for the X and Y directions.</p> <code>get_high_symmetry_points</code> <p>Get the high symmetry points for the photonic crystal lattice.</p> <code>plot_field</code> <p>Plot the field visualization.</p> <code>plot_field_components</code> <p>Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.</p> <code>look_for_mode</code> <p>Look for modes within the specified criteria.</p> <code>find_modes_symmetries</code> <p>Find the symmetries of the modes.</p> <code>plot_modes_vectorial_fields</code> <p>Plot the vectorial fields of the modes.</p> <code>plot_mode_fields_normal_to_k</code> <p>Plot the fields perpendicular to the wavevector k for the mode.</p> <code>plot_vectorial_fields</code> <p>Plot the vectorial fields of the modes.</p> <code>_field_to_cones</code> <p>Convert a field to cones for visualization.</p> <code>_fields_to_cones</code> <p>Convert a list of fields to cones for visualization.</p> <code>_calculate_field_norm_to_k</code> <p>Calculate the components of the field perpendicular to the wavevector k.</p> <code>_get_direction</code> <p>Determine the primary direction of the wavevector k.</p> <code>_calculate_effective_parameter</code> <p>Calculate the effective parameters of the mode.</p> <code>basic_geometry</code> <p>Define the basic geometry of the photonic crystal.</p> <code>basic_lattice</code> <p>Define the basic lattice of the photonic crystal.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>class PhotonicCrystal:\n    \"\"\"\n    A class to represent a photonic crystal and perform simulations using MPB (MIT Photonic Bands).\n\n    Attributes:\n        lattice_type (str): Type of the lattice.\n        num_bands (int): Number of bands.\n        resolution (tuple[int, int] | int): Resolution of the simulation.\n        interp (int): Interpolation factor for k-points.\n        periods (int): Number of periods.\n        pickle_id (str): Identifier for pickling.\n        has_been_run (bool): Flag indicating if the simulation has been run.\n        geometry_lattice (None): Geometry lattice, set with basic lattice method.\n        k_points (list): List of k-points.\n        k_points_interpolated (list): Interpolated k-points.\n        material (Crystal_Materials): Material of the photonic crystal.\n        geometry (Crystal_Geometry): Geometry of the photonic crystal.\n        ms (None): Placeholder for ms attribute.\n        md (None): Placeholder for md attribute.\n        freqs (dict): Dictionary to store frequencies.\n        gaps (dict): Dictionary to store gaps.\n        epsilon (None): Placeholder for epsilon attribute.\n        modes (list): List to store modes.\n        use_XY (bool): Flag to use XY plane.\n\n    Methods:\n        __getstate__(): Get the state for pickling.\n        __setstate__(state): Set the state after unpickling.\n        pickle_photonic_crystal(pickle_id): Pickle the photonic crystal object.\n        load_photonic_crystal(pickle_id): Load a pickled photonic crystal object.\n        set_solver(k_point): Set the mode solver for the simulation.\n        run_simulation(runner, polarization): Run the simulation to calculate the frequencies and gaps.\n        run_simulation_with_output(runner, polarization): Run the simulation and get mode data.\n        run_dumb_simulation(): Run a dumb simulation to quickly extract some values.\n        convert_mode_fields(mode, periods): Convert the mode fields to arrays for visualization.\n        extract_data(periods): Extract the data from the simulation.\n        plot_epsilon(fig, title): Plot the epsilon of the photonic crystal interactively using Plotly.\n        plot_bands(polarization, title, fig, color): Plot the bands of the photonic crystal using Plotly.\n        get_XY_k_points_near_gamma(distance): Get the relevant k-points near the gamma point for the X and Y directions.\n        get_high_symmetry_points(): Get the high symmetry points for the photonic crystal lattice.\n        plot_field(target_polarization, target_k_point, target_frequency, frequency_tolerance, k_point_max_distance, periods, component, quantity, colorscale): Plot the field visualization.\n        plot_field_components(target_polarization, target_k_point, target_frequency, frequency_tolerance, k_point_max_distance, periods, quantity, colorscale): Plot the field components (Ex, Ey, Ez) and (Hx, Hy, Hz) for specific modes with consistent color scales.\n        look_for_mode(polarization, k_point, freq, freq_tolerance, k_point_max_distance): Look for modes within the specified criteria.\n        find_modes_symmetries(): Find the symmetries of the modes.\n        plot_modes_vectorial_fields(modes, sizemode, names): Plot the vectorial fields of the modes.\n        plot_mode_fields_normal_to_k(mode, k): Plot the fields perpendicular to the wavevector k for the mode.\n        plot_vectorial_fields(fields, colorscales, names): Plot the vectorial fields of the modes.\n        _field_to_cones(field, colorscale, sizemode, sizeref, clim): Convert a field to cones for visualization.\n        _fields_to_cones(fields, colorscale, sizemode, sizeref, clim, colorscales): Convert a list of fields to cones for visualization.\n        _calculate_field_norm_to_k(fields, k): Calculate the components of the field perpendicular to the wavevector k.\n        _get_direction(k_vector): Determine the primary direction of the wavevector k.\n        _calculate_effective_parameter(mode): Calculate the effective parameters of the mode.\n        basic_geometry(): Define the basic geometry of the photonic crystal.\n        basic_lattice(): Define the basic lattice of the photonic crystal.\n    \"\"\"\n    def __init__(self,\n                lattice_type = None,\n                material: Crystal_Materials = None,\n                geometry: Crystal_Geometry = None, \n                num_bands: int = 6,\n                resolution = 32,\n                interp: int = 4,\n                periods: int = 3, \n                pickle_id = None, \n                k_points = None,\n                use_XY  = True\n                ):\n        \"\"\"\n        Initializes the PhotonicCrystal class with the given parameters.\n\n        Args:\n            lattice_type (str, optional): Type of the lattice. Defaults to None.\n            material (Crystal_Materials, optional): The material object. Defaults to None.\n            geometry (Crystal_Geometry, optional): The geometry object. Defaults to None.\n            num_bands (int, optional): Number of bands. Defaults to 6.\n            resolution (tuple[int, int] | int, optional): Resolution of the simulation. Defaults to 32.\n            interp (int, optional): Interpolation factor for k-points. Defaults to 4.\n            periods (int, optional): Number of periods. Defaults to 3.\n            pickle_id (str, optional): Identifier for pickling. Defaults to None.\n            k_points (list, optional): List of k-points. Defaults to None.\n            use_XY (bool, optional): Flag to use XY plane. Defaults to True.\n\n        Attributes:\n            lattice_type (str): Type of the lattice.\n            num_bands (int): Number of bands.\n            resolution (tuple[int, int] | int): Resolution of the simulation.\n            interp (int): Interpolation factor for k-points.\n            periods (int): Number of periods.\n            pickle_id (str): Identifier for pickling.\n            has_been_run (bool): Flag indicating if the simulation has been run.\n            geometry_lattice (None): Geometry lattice, set with basic lattice method.\n            k_points (list): List of k-points.\n            k_points_interpolated (list): Interpolated k-points.\n            material (Crystal_Materials): Material of the photonic crystal.\n            geometry (Crystal_Geometry): Geometry of the photonic crystal.\n            ms (None): Placeholder for ms attribute.\n            md (None): Placeholder for md attribute.\n            freqs (dict): Dictionary to store frequencies.\n            gaps (dict): Dictionary to store gaps.\n            epsilon (None): Placeholder for epsilon attribute.\n            modes (list): List to store modes.\n            use_XY (bool): Flag to use XY plane.\n        \"\"\"\n        self.lattice_type = lattice_type\n        self.num_bands = num_bands\n        self.resolution = resolution\n        self.interp = interp\n        self.periods = periods\n        self.pickle_id = pickle_id\n        self.has_been_run = False #update this manually\n\n        #this values are set with basic lattice method\n        self.geometry_lattice= None \n        self.k_points = k_points\n        if self.k_points is not None:\n            self.k_points_interpolated = mp.interpolate(self.interp, self.k_points)\n\n\n        #material\n        self.material = material if material is not None else PhotonicCrystal.basic_material()\n\n        #geometry\n        self.geometry = geometry if geometry is not None else PhotonicCrystal.basic_geometry(material = self.material)\n\n        self.ms = None\n        self.md = None\n\n        self.freqs = {}\n        self.gaps = {}\n        self.epsilon = None\n        self.modes= []\n        self.use_XY = use_XY\n\n\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Exclude the non-picklable SWIG objects\n        state['ms'] = None\n        state['md'] = None\n        return state\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        # You may want to reinitialize 'ms' and 'md' if needed after loading.\n        self.ms = None\n        self.md = None\n\n    def pickle_photonic_crystal(self, pickle_id):\n        \"\"\"Pickle the photonic crystal object.\n\n        Args:\n            pickle_id (str): The identifier for the pickle file.\n        \"\"\"\n        with open(f\"{pickle_id}.pkl\", \"wb\") as f:\n            pickle.dump(self, f)\n\n    @staticmethod\n    def load_photonic_crystal(pickle_id) -&gt; 'PhotonicCrystal':\n        \"\"\"Load a pickled photonic crystal object.\n\n        Args:\n            pickle_id (str): The identifier for the pickle file.\n\n        Returns:\n            PhotonicCrystal: The loaded photonic crystal object.\n        \"\"\"\n        with open(f\"{pickle_id}.pkl\", \"rb\") as f:\n            return pickle.load(f)\n\n    def set_solver(self, k_point = None):\n        \"\"\"\n        Set the mode solver for the simulation. \n        For how MPB works, it is better to call this method each time you want to run a simulation.\n        This method initializes the mode solver (ms) with the geometry, geometry lattice, \n        k-points, resolution, and number of bands. If a specific k-point is provided, \n        the solver is set up for that k-point. Otherwise, it uses the interpolated k-points.\n\n        Args:\n            k_point (mp.Vector3, optional): The k-point for the simulation. Default is None.\n\n        \"\"\"\n\n        if k_point is not None:\n            self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                                  geometry_lattice=self.geometry_lattice,\n                                  k_points=[k_point],\n                                  resolution=self.resolution,\n                                  num_bands=self.num_bands)\n        else:\n            self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                                    geometry_lattice=self.geometry_lattice,\n                                    k_points=self.k_points_interpolated,\n                                    resolution=self.resolution,\n                                    num_bands=self.num_bands)\n\n    def run_simulation(self, runner=\"run_zeven\", polarization=None):\n        \"\"\"\n        Run the simulation to calculate the frequencies and gaps.\n\n        Args:\n            runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n                runner must correspond to an MPB runner. For example:\n\n                - 'run_zeven': Run the simulation for even parity modes in z-axis.\n                - 'run_zodd': Run the simulation for odd parity modes in z-axis.\n                - 'run_tm': Run the simulation for transverse magnetic modes.\n                - 'run_te': Run the simulation for transverse electric modes.\n                - 'run': Do not consider symmetry.\n            polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n\n\n        \"\"\"\n        if self.ms is None:\n            raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n        if polarization is not None:\n            polarization = polarization\n        else:\n            if runner.startswith(\"run_\"):\n                polarization = runner[4:]\n            else:\n                polarization = runner\n\n        # This is a custom mpb output function that stores the fields and frequencies\n        def get_mode_data(ms, band):\n            mode = {\n                \"h_field\": ms.get_hfield(band, bloch_phase=True),\n                \"e_field\": ms.get_efield(band, bloch_phase=True),\n                \"freq\": ms.freqs[band-1],\n                \"k_point\": ms.current_k,\n                \"polarization\": polarization\n            }\n            self.modes.append(mode)\n\n        print(self.k_points_interpolated)\n        with suppress_output():\n            getattr(self.ms, runner)(get_mode_data)\n            self.freqs[polarization] = self.ms.all_freqs\n            self.gaps[polarization] = self.ms.gap_list\n\n    def run_simulation_with_output(self, runner=\"run_zeven\", polarization=None):\n        \"\"\"\n        Run the simulation and get mode data. Mode data are not stored in the crystal object, \n        but are returned as a list of dictionaries.\n\n        Args:\n            runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n                runner must correspond to an MPB runner. For example: \n\n                - 'run_zeven': Run the simulation for even parity modes in z-axis.\n                - 'run_zodd': Run the simulation for odd parity modes in z-axis.\n                - 'run_tm': Run the simulation for transverse magnetic modes.\n                - 'run_te': Run the simulation for transverse electric modes.\n                - 'run': Do not consider symmetry.   \n\n            polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n\n        \"\"\"\n        if self.ms is None:\n            raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n        if polarization is not None:\n            polarization = polarization\n        else:\n            if runner.startswith(\"run_\"):\n                polarization = runner[4:]\n            else:\n                polarization = runner\n        modes=[]\n        # This is a custom mpb output function that stores the fields and frequencies\n        def get_mode_data(ms, band):\n            mode = {\n                \"h_field\": ms.get_hfield(band, bloch_phase=True),\n                \"e_field\": ms.get_efield(band, bloch_phase=True),\n                \"freq\": ms.freqs[band-1],\n                \"k_point\": ms.current_k,\n                \"polarization\": polarization\n            }\n            modes.append(mode)\n        with suppress_output():\n            getattr(self.ms, runner)(get_mode_data)\n        return modes\n\n\n\n\n    def run_dumb_simulation(self) -&gt; mpb.ModeSolver:    \n        \"\"\"\n        Run a dumb simulation.  It is the first band of the gamma point.\n        This is used to quickly extract some values from the simulation later. \n        For example it can be used to extract epsilon values.\n        \"\"\"\n\n        #run the simulation in the gamma point, find one mode\n        self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                                  geometry_lattice=self.geometry_lattice,\n                                  k_points=[mp.Vector3()],\n                                  resolution=self.resolution,\n                                  num_bands=1)\n        with suppress_output():\n            self.ms.run()\n        ms = self.ms\n        return ms\n\n    def convert_mode_fields(self, mode, periods=1)-&gt; tuple:\n        \"\"\"\n        Convert the mode fields to mpb.MPBArray for visualization.\n        Apparently this is necessary to visualize the fields if crystal is restored from pickle.\n\n        Args:\n            mode (dict): The mode dictionary.\n            periods (int): The number of periods to extract. Default is 1.\n\n        Returns:\n            tuple: A tuple containing the electric field array and the magnetic field array for visualization.\n        \"\"\"\n\n        with suppress_output():\n            self.run_dumb_simulation()\n            md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n            e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n            h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n            e_field =  md.convert(e_field_array)\n            h_field =  md.convert(h_field_array)            \n            return e_field, h_field \n\n\n\n    def extract_data(self, periods = 5):\n        \"\"\"\n        Extract the data from the simulation. Basically it creates a MPBData object.\n\n        Args:\n            periods (int, optional): The number of periods to extract. Default is 5.\n\n        Returns:\n            mpb.MPBData: The MPB data object.\n        \"\"\"\n\n        if self.ms is None:\n            raise ValueError(\"Solver is not set. Call set_solver() before extracting data.\")\n\n        self.md = mpb.MPBData(rectify=True, periods=periods, resolution=self.resolution)\n        return self.md\n\n\n    def plot_epsilon(self, fig=None, title='Epsilon') :\n        \"\"\"\n        Plot the epsilon of the photonic crystal interactively using Plotly.\n        Not implemented in the base class. Must be implemented in the derived class.\n\n        Args:\n            fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n            title (str, optional): The title of the plot. Default is 'Epsilon'.\n\n        Returns:\n            go.Figure: The Plotly figure object.(Not woroking yet, error is thrown)\n        \"\"\"\n        raise NotImplementedError\n\n    def plot_bands(self, polarization=\"te\", title='Bands', fig=None, color='blue')-&gt; go.Figure:\n        \"\"\"\n        Plot the bands of the photonic crystal using Plotly.\n\n        This method plots the bands for the specified polarization.\n        In Dash and Jupyter Notebook, the plot is interactive and data are shown on hover.\n\n        Args:\n            polarization (str, optional): The polarization of the bands. Default is 'te'.\n            title (str, optional): The title of the plot. Default is 'Bands'.\n            fig (go.Figure, optional): The Plotly figure to add the bands plot to. Default is None.\n            color (str, optional): The color of the bands. Default is 'blue'.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n        if self.freqs[polarization] is None:\n            print(\"Simulation not run yet. Please run the simulation first.\")\n            return\n        freqs = self.freqs[polarization]\n        gaps = self.gaps[polarization]\n\n        xs = list(range(len(freqs)))\n\n        # Extract the interpolated k-points as vectors and format them for hover and click\n        k_points_interpolated = [kp for kp in self.k_points_interpolated]\n\n        if fig is None:\n            fig = go.Figure()\n\n        # Iterate through each frequency band and add them to the plot\n        for band_index, band in enumerate(zip(*freqs)):\n            # Generate hover text with the corresponding k-point and frequency\n            hover_texts = [\n                f\"k-point: ({kp.x:.4f}, {kp.y:.4f}, {kp.z:.4f})&lt;br&gt;frequency: {f:.4f}\"\n                for kp, f in zip(k_points_interpolated, band)\n            ]\n\n\n\n            modes =[]\n            for i, kp in enumerate(k_points_interpolated):\n                mode = self.look_for_mode(polarization, kp, band[i], freq_tolerance=1e-12)\n                modes.append(mode[0])\n\n\n\n            # Add the line trace with hover info\n            fig.add_trace(go.Scatter(\n                x=xs, \n                y=band, \n                mode='lines', \n                line=dict(color=color),\n                text=hover_texts,  # Custom hover text\n                hoverinfo='text',  # Display only the custom hover text\n                customdata=[(kp.x, kp.y, kp.z, f, polarization) for kp, f in zip(k_points_interpolated, band)],  # Attach k-points and frequency as custom data\n                showlegend=False,  # Hide from legend (we\u2019ll add a separate legend entry)\n                legendgroup=polarization,  # Group traces by polarization for toggling visibility\n                visible=True,  # Initially visible\n                selectedpoints=[],  # Placeholder for selected points\n                selected=dict(marker=dict(color=\"red\", size=10)),  # Change color and size of selected points\n                unselected=dict(marker=dict(opacity=0.3))  # Make unselected points more transparent\n            ))\n\n        # Add bandgap shading (optional, grouped with the polarization for toggling visibility)\n        for gap in gaps:\n            if gap[0] &gt; 1:\n                fig.add_shape(\n                    type=\"rect\",\n                    x0=xs[0], \n                    x1=xs[-1],\n                    y0=gap[1], \n                    y1=gap[2],\n                    fillcolor=color, \n                    opacity=0.2, \n                    line_width=0,\n                    layer=\"below\",\n                    legendgroup=polarization,  # Group shading with the same polarization\n                    visible=True  # Initially visible\n                )\n\n        # Add a single legend entry for toggling visibility\n        fig.add_trace(go.Scatter(\n            x=[None], y=[None],\n            mode='lines',\n            line=dict(color=color),\n            name=f'{polarization.upper()}',  # Legend entry for the polarization\n            legendgroup=polarization,  # Group with the same polarization traces\n            showlegend=True,  # Show the legend entry\n            visible=True,  # Initially visible\n        ))\n\n        # Customize the x-axis \n        if self.use_XY is True:  # Use X and Y directions for the x-axis\n            relevant_k_points = self.get_XY_k_points_near_gamma()\n            fig.update_layout(\n                title=title,\n                xaxis=dict(\n                    tickmode='array',\n                    tickvals=[i * (len(freqs) - 3) / 2 + i for i in range(3)],\n                    ticktext=list(relevant_k_points.keys())  # Only three values, no repetition\n                ),\n                yaxis_title='frequency (c/a)',\n                showlegend=True,\n                dragmode='select',  # Enables rectangular selection\n                clickmode='event+select',  # Enable click events and selection events\n                legend=dict(  # This ensures that clicking the legend will toggle visibility\n                    itemclick=\"toggle\",  # Toggle visibility when clicked\n                    itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n                )\n            )\n        else:\n            relevant_k_points = self.get_high_symmetry_points() # Use high symmetry points for the x-axis \n                                                                # Gamma, X, M for square lattice and\n                                                                # Gamma, K, M for triangular lattice                                                   \n            fig.update_layout(\n                title=title,\n                xaxis=dict(\n                    tickmode='array',\n                    tickvals=[i * (len(freqs) - 4) / 3 + i for i in range(4)],\n                    ticktext=list(relevant_k_points.keys()) + [list(relevant_k_points.keys())[0]]  # Repeat the first element at the end\n                ),\n                yaxis_title='frequency (c/a)',\n                showlegend=True,\n                dragmode='select',  # Enables rectangular selection\n                clickmode='event+select',  # Enable click events and selection events\n                legend=dict(  # This ensures that clicking the legend will toggle visibility\n                    itemclick=\"toggle\",  # Toggle visibility when clicked\n                    itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n                )\n            )\n\n        return fig\n\n\n    def get_XY_k_points_near_gamma(self, distance = 0.1) -&gt; dict:\n        \"\"\"\n        Get the relevant k-points near the gamma point for the X and Y directions.\n        This is useful for plotting the bands with the X and Y directions on the x-axis.\n\n        Args:\n            distance (float): The distance from the gamma point. Default is 0.1.\n\n        Returns:\n            dict: A dictionary with the relevant k-points for the X and Y directions.\n            with the k-point names as keys and the k-point vectors as values.\n        \"\"\"\n\n        if distance &gt;= 0.5:\n            raise ValueError(\"Distance must be less than 0.5\")\n        relevant_k_points = {\n            'X': mp.Vector3(0.5, 0),\n            '\u0393': mp.Vector3(0, 0, 0),\n            'Y': mp.Vector3(0,0.5, 0)\n        }\n        return relevant_k_points\n\n    def get_high_symmetry_points(self) -&gt; dict:\n        \"\"\"\n        Get the high symmetry points for the photonic crystal lattice.\n        This is useful for plotting the bands with the high symmetry points on the x-axis.\n\n        Returns:\n            dict: A dictionary with the high symmetry points for the lattice.\n            with the k-point names as keys and the k-point vectors as values.\n        \"\"\"\n\n        k_high_sym = {}\n        if self.lattice_type == 'square':\n            k_high_sym = {\n                '\u0393': mp.Vector3(0, 0, 0),\n                'X': mp.Vector3(0.5, 0, 0),\n                'M': mp.Vector3(0.5, 0.5, 0)\n            }\n        elif self.lattice_type == 'triangular':\n            k_high_sym = {\n                '\u0393': mp.Vector3(0, 0, 0),\n                'K': mp.Vector3(1/3, 1/3, 0),\n                'M': mp.Vector3(0.5, 0, 0)\n            }\n        return k_high_sym\n\n\n    def plot_field(\n        self, \n        target_polarization,\n        target_k_point,\n        target_frequency,\n        frequency_tolerance=0.01,\n        k_point_max_distance=None,\n        periods=5,\n        component: int = 2,\n        quantity: str = \"real\",\n        colorscale: str = \"RdBu\",\n    ): \n        \"\"\"\n        Plot the field visualization.\n        Not implemented in the base class. Must be implemented in the derived class.\n\n        Args:\n            target_polarization (str): The polarization of the mode.\n            target_k_point (tuple): The k-point of the mode.\n            target_frequency (float): The frequency of the mode.\n            frequency_tolerance (float): The tolerance for frequency similarity. Default is 0.01.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 5.\n            component (int): The component of the field to plot. Default is 2.\n            quantity (str): The quantity of the field to plot. Default is \"real\".\n            colorscale (str): The colorscale for the plot. Default is \"RdBu\".\n\n        Returns:\n            tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.           \n\n        \"\"\"\n        raise NotImplementedError(\"plot_field method not implemented yet.\")\n\n\n    def plot_field_components(\n            self,\n            target_polarization,\n            target_k_point,\n            target_frequency,\n            frequency_tolerance=0.01,\n            k_point_max_distance=None,\n            periods: int = 1,\n            quantity: str = \"real\",\n            colorscale: str = 'RdBu',\n            ):\n\n        \"\"\"\n        Plot the field visualization.\n        Not implemented in the base class. Must be implemented in the derived class.\n\n        Args:\n            target_polarization (str): The polarization of the mode.\n            target_k_point (tuple): The k-point of the mode.\n            target_frequency (float): The frequency of the mode.\n            frequency_tolerance (float): The tolerance for frequency similarity. Default is 0.01.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n            periods (int): The number of periods to extract. Default is 1.\n            quantity (str): The quantity of the field to plot. Default is \"real\".\n            colorscale (str): The colorscale for the plot. Default is \"RdBu\".\n\n        Returns:\n            tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.           \n        \"\"\"\n\n        raise NotImplementedError(\"plot_field_components method not implemented yet.\")\n\n\n\n\n    def look_for_mode(self, polarization, k_point, freq,  freq_tolerance=0.01, k_point_max_distance = None):\n        \"\"\"\n        Look for modes within the specified criteria.\n\n        Args:\n            polarization (str): The polarization of the mode.\n            k_point (tuple): The k-point of the mode.\n            freq (float): The frequency of the mode.\n            freq_tolerance (float): The tolerance for frequency similarity.\n            k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n\n        Returns:\n            list: A list of mode dictionaries that match the criteria.\n        \"\"\"\n\n        target_modes = []\n        if k_point_max_distance is None:\n            for mode in self.modes:\n                if mode[\"polarization\"] == polarization and mode[\"k_point\"] == k_point and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                    target_modes.append(mode)\n        else:\n            for mode in self.modes:\n                if mode[\"polarization\"] == polarization and np.linalg.norm(np.array(mode[\"k_point\"]) - np.array(k_point)) &lt;= k_point_max_distance and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                    target_modes.append(mode)\n        return target_modes\n\n\n\n    def find_modes_symmetries(self):\n        \"\"\"\n        Find the symmetries of the modes.\n        Not implemented yet. TODO\n        \"\"\"\n        raise NotImplementedError(\"find_modes_symmetries method not implemented yet.\")\n\n\n\n    def plot_modes_vectorial_fields(self, modes, sizemode=\"scaled\", names=[\"Electric Field\", \"Magnetic Field\"]):\n        \"\"\"\n        Plot the vectorial fields of the modes.\n\n        Args:\n            modes (list): The list of modes to plot.\n            sizemode (str): The sizemode for the cones. Default is 'scaled'.\n            names (list): The names of the fields. Default is ['Electric Field', 'Magnetic Field'].\n\n        Returns:\n            tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n        \"\"\"\n\n        colorscales = [\"blues\", \"reds\", \"greens\", \"purples\", \"oranges\", \"ylorbr\"]\n\n        h_fields = [mode[\"h_field\"] for mode in modes]\n        e_fields = [mode[\"e_field\"] for mode in modes]\n\n        max_norm_h = PhotonicCrystal._calculate_fields_max_norms(h_fields)\n        max_norm_e = PhotonicCrystal._calculate_fields_max_norms(e_fields)\n\n        e_sizeref = max_norm_e\n        h_sizeref = max_norm_h\n\n        e_clim = (0, max_norm_e)\n        h_clim= (0, max_norm_h)\n\n\n        e_fig = go.Figure()\n        h_fig = go.Figure()\n\n        e_cones = PhotonicCrystal._fields_to_cones(e_fields, colorscale=colorscales[0], sizemode=sizemode, sizeref=e_sizeref, clim=e_clim, colorscales=colorscales)\n        h_cones = PhotonicCrystal._fields_to_cones(h_fields, colorscale=colorscales[1], sizemode=sizemode, sizeref=h_sizeref, clim=h_clim, colorscales=colorscales) \n\n\n        for e_cone in e_cones:  \n            e_fig.add_trace(e_cone)\n        for h_cone in h_cones:\n            h_fig.add_trace(h_cone)\n\n\n        e_fig.update_layout(\n            title=names[0],\n            scene=dict(\n            xaxis=dict(title='X'),\n            yaxis=dict(title='Y'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n\n        h_fig.update_layout(\n            title=names[1],\n            scene=dict(\n            xaxis=dict(title='X'),\n            yaxis=dict(title='Y'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n\n        return e_fig, h_fig\n\n\n\n\n\n    def plot_mode_fields_normal_to_k(self, mode, k):\n        \"\"\"\n        Plot the fields perpendicular to the wavevector k for the mode.\n        To be tested, not sure if works correctly.\n\n        Args:\n            mode (dict): The mode dictionary.\n            k (numpy.ndarray): The wavevector [kx, ky, kz].\n\n        Returns:\n            tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n        \"\"\"\n        fields = [mode[\"e_field\"], mode[\"h_field\"]]\n        fields_norm_to_k = self._calculate_field_norm_to_k(fields, k)\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n\n\n        fig_e.add_trace(self._field_to_cones(fields_norm_to_k[0], colorscale=\"blues\"))\n        fig_h.add_trace(self._field_to_cones(fields_norm_to_k[1], colorscale=\"reds\"))\n        return fig_e, fig_h \n\n    def plot_vectorial_fields(self, fields, colorscales=[\"Viridis\",\"Viridis\"], names=[\"Field 1\", \"Field 2\"]): \n        \"\"\"\n        Plot the vectorial fields of the modes.\n\n        Args:\n            fields (list): The list of fields to plot.\n            colorscales (list, optional): The colorscales for the cones. Default is [\"Viridis\", \"Viridis\"].\n            names (list, optional): The names of the fields. Default is [\"Field 1\", \"Field 2\"].\n\n        Returns:\n            tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n        \"\"\"\n\n        fig_e = go.Figure()\n        fig_h = go.Figure()\n        fig_e.add_trace(self._field_to_cones(fields[0], colorscale=colorscales[0]))\n        fig_h.add_trace(self._field_to_cones(fields[1], colorscale=colorscales[1]))\n        fig_e.update_layout(\n            title=names[0],\n            scene=dict(\n            xaxis=dict(title='Y'),\n            yaxis=dict(title='X'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n\n        fig_h.update_layout(\n            title=names[1],\n            scene=dict(\n            xaxis=dict(title='Y'),\n            yaxis=dict(title='X'),\n            zaxis=dict(title='Z')\n            ),\n            margin=dict(l=0, r=0, b=0, t=40),\n            showlegend=True\n        )\n        return fig_e, fig_h\n\n\n\n\n    @staticmethod\n    def _field_to_cones(field, colorscale=\"Viridis\", sizemode='absolute', sizeref=1, clim=(0, 1))-&gt; go.Cone:\n        \"\"\"\n        Convert a field to cones for visualization.\n        Auxiliar method for plotting the fields.\n\n        Args:\n            field (np.ndarray): The field to convert.\n            colorscale (str): The colorscale for the cones. Default is 'Viridis'.\n            sizemode (str): The sizemode for the cones. Default is 'absolute'.\n            sizeref (float): The sizeref for the cones. Default is 1.\n            clim (tuple): The color limits for the cones. Default is (0, 1). (Not used now)\n\n        Returns:\n            go.Cone: The Plotly cone object for visualization.\n        \"\"\"\n        field_x = np.real(field[..., 0])\n        field_y = np.real(field[..., 1])\n        field_z = np.real(field[..., 2])\n\n        x, y, z = np.meshgrid(np.arange(field.shape[0]), np.arange(field.shape[1]), np.arange(field.shape[2]))\n\n\n        cone = go.Cone(\n            x=x.flatten(),\n            y=y.flatten(),\n            z=z.flatten(),\n            u=field_x.flatten(),\n            v=field_y.flatten(),\n            w=field_z.flatten(),\n            anchor='tail',\n            sizemode=sizemode,\n            sizeref=sizeref,\n            colorscale=colorscale,\n            #cmin = clim[0],\n            #cmax = clim[1],\n        )\n        return cone\n\n\n    @staticmethod\n    def _fields_to_cones(fields, colorscale=\"Viridis\", sizemode='absolute', sizeref=1, clim=(0, 1), colorscales=None)-&gt; list:\n        \"\"\"\n        Convert a list of fields to cones for visualization.\n        Auxiliar method for plotting the fields.\n\n        Args:\n            fields (list): The list of fields to convert.\n            colorscale (str): The colorscale for the cones. Default is 'Viridis'.\n            sizemode (str): The sizemode for the\n        - sizeref: The sizeref for the cones. Default is 1.\n        - clim: The color limits for the cones. Default is (0, 1).\n        - colorscales: The colorscales for the cones. Default is None.\n\n        Returns:\n        - cones: The list of cones for the fields.\n        \"\"\"\n\n\n        cones = []\n\n        if colorscales is None:\n            colorscales = [\"blues\", \"reds\", \"greens\", \"purples\", \"oranges\", \"ylorbr\"]\n\n        for i, field in enumerate( fields):\n            cone = PhotonicCrystal._field_to_cones(field, colorscale=colorscales[i], sizemode=sizemode, sizeref=sizeref, clim=clim)\n            cones.append(cone)\n        return cones\n\n\n    @staticmethod\n    def _calculate_field_norm_to_k(fields, k):\n        \"\"\"\n        Calculate the components of the field perpendicular to the wavevector k for each field in the list.\n\n        Args:\n            fields (list): A list of numpy arrays, each of shape (Nx, Ny, Nz, 3), where the last dimension contains the x, y, z components of the field.\n            k (numpy.ndarray): A numpy array of shape (3,), representing the wavevector [kx, ky, kz].\n\n        Returns:\n            list: A list of numpy arrays, each of shape (Nx, Ny, Nz, 3), representing the field perpendicular to k for each input field.\n        \"\"\"\n        fields_norm_to_k = []\n\n        for field in fields:\n            # Normalize the wavevector k\n            k_norm = k / np.linalg.norm(k)\n\n            # Compute the dot product of each field vector with the normalized k\n            dot_product = np.einsum('ijkl,l-&gt;ijk', field, k_norm)  # Efficiently computes the dot product\n\n            # Compute the parallel component of the field: (dot_product * k_norm)\n            field_parallel = np.outer(dot_product, k_norm).reshape(field.shape)\n\n            # Subtract the parallel component to get the perpendicular component\n            field_norm_to_k = field - field_parallel\n\n            fields_norm_to_k.append(field_norm_to_k)\n\n        return fields_norm_to_k\n\n\n\n\n\n    @staticmethod\n    def _get_direction(k_vector):\n        \"\"\"\n        Determine the primary direction of the wavevector k.\n\n        Args:\n            k_vector: A numpy array or list of shape (3,), representing the wavevector [kx, ky, kz].\n\n        Returns:\n            int: 0 for x-direction, 1 for y-direction, 2 for z-direction.\n        \"\"\"\n        if k_vector[0] != 0 and k_vector[1] == 0 and k_vector[2] == 0:\n            return 0  # x-direction\n        elif k_vector[0] == 0 and k_vector[1] != 0 and k_vector[2] == 0:\n            return 1  # y-direction\n        elif k_vector[0] == 0 and k_vector[1] == 0 and k_vector[2] != 0:\n            return 2  # z-direction\n        else:\n            raise ValueError(\"The wavevector k does not align with a primary axis.\")\n\n\n\n\n    @staticmethod\n    def _calculate_effective_parameter(mode):\n        \"\"\"\n        Calculate the effective parameters of the mode.\n\n        Args:\n            mode (dict): The mode dictionary.\n\n        Returns:\n            dict: A dictionary with the effective parameters of the mode.\n        \"\"\"\n        raise NotImplementedError(\"calculate_effective_parameter method not implemented yet.\")  \n\n    def sweep_geometry_parameter(self, param_to_sweep: str, sweep_values: list, num_bands: int =4)-&gt; list:\n\n        \"\"\"\n        Sweep a parameter of the geometry and run simulations for each value.\n\n        Args:\n            param_to_sweep (str): The parameter to sweep.\n            sweep_values (list): The values to sweep.\n            num_bands (int, optional): The number of bands to calculate. Defaults to 4.\n\n        Returns:\n            list: A list of dictionaries with the simulation data.\n\n        \"\"\"\n        data = []\n        old_geom  = self.geometry\n        old_num_bands = self.num_bands\n\n        partial_geom = self.geometry.to_partial(exclude_key=param_to_sweep)\n        for value in sweep_values:\n            kwargs = {param_to_sweep: value}\n            self.geometry = partial_geom(**kwargs)\n            self.num_bands = num_bands\n            self.set_solver(k_point=mp.Vector3())\n            modes_zeven = self.run_simulation_with_output(runner=\"run_zeven\", polarization=\"zeven\")\n            modes_zodd  = self.run_simulation_with_output(runner=\"run_zodd\", polarization=\"zodd\")\n            data.append({\n                'parameter_value': value,\n                'modes_zeven': modes_zeven,\n                'modes_zodd': modes_zodd,\n                'parameter_name': param_to_sweep,\n            })\n        self.geometry = old_geom\n        self.num_bands = old_num_bands\n        return data\n\n\n\n    def plot_sweep_result(self, data, fig=None) -&gt; go.Figure:\n        \"\"\"\n        Plot the sweep result using Plotly.\n\n        Args:\n            data (list): The data from the sweep.\n            fig (go.Figure): The Plotly figure to add the plot to.\n\n        Returns:\n            go.Figure: The Plotly figure object.\n        \"\"\"\n\n        if fig is None:\n            fig = go.Figure()\n\n        # For each data parameter value in the x axis, add all the modes frequencies (mode[\"freq\"])in the y axis\n        num_bands = len(data[0]['modes_zeven'])\n        for i in range(num_bands):\n            modes_zeven = [d['modes_zeven'][i] for d in data]\n            modes_zodd = [d['modes_zodd'][i] for d in data]\n            param_values = [d['parameter_value'] for d in data]   \n            fig.add_trace(go.Scatter(x=param_values, y=[m[\"freq\"] for m in modes_zeven], mode='lines+markers', name=f'Band {i} TE', line=dict(color='red'), marker=dict(symbol=i, size=10)))\n            fig.add_trace(go.Scatter(x=param_values, y=[m[\"freq\"] for m in modes_zodd], mode='lines+markers', name=f'Band {i} TM', line=dict(color='blue'), marker=dict(symbol=i, size=10)))\n        fig.update_layout(\n            autosize=False,\n            width=700,\n            height=700,\n        )   \n\n        fig.update_layout(\n            xaxis_title='Parameter Value',\n            yaxis_title='Frequency (c/a)',\n            title=f\"Sweep of {data[0]['parameter_name']}\",\n            showlegend=True\n        )\n\n        return fig\n\n    @staticmethod\n    def basic_geometry(**kwargs):\n        \"\"\" \n        Define the basic geometry of the photonic crystal.\n        Must be implemented in the derived class.\n        \"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    def basic_lattice(**kwargs):\n        \"\"\"\n        Define the basic lattice of the photonic crystal.\n        Must be implemented in the derived class.\n        \"\"\"\n\n        raise NotImplementedError\n\n    @staticmethod\n    def basic_material():\n        \"\"\"\n        Define the basic material of the photonic crystal.\n\n        Returns:\n            material (Crystal_Materials): Silicon Membrane. \n        \"\"\"\n\n        material = Crystal_Materials()\n        material.atom = {\"epsilon\": 1}\n        material.background = {\"epsilon\": 1}\n        material.substrate = {\"epsilon\": 1}\n        material.bulk = {\"epsilon\": 11.8}\n        return material\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.__init__","title":"<code>__init__(lattice_type=None, material=None, geometry=None, num_bands=6, resolution=32, interp=4, periods=3, pickle_id=None, k_points=None, use_XY=True)</code>","text":"<p>Initializes the PhotonicCrystal class with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_type</code> <code>str</code> <p>Type of the lattice. Defaults to None.</p> <code>None</code> <code>material</code> <code>Crystal_Materials</code> <p>The material object. Defaults to None.</p> <code>None</code> <code>geometry</code> <code>Crystal_Geometry</code> <p>The geometry object. Defaults to None.</p> <code>None</code> <code>num_bands</code> <code>int</code> <p>Number of bands. Defaults to 6.</p> <code>6</code> <code>resolution</code> <code>tuple[int, int] | int</code> <p>Resolution of the simulation. Defaults to 32.</p> <code>32</code> <code>interp</code> <code>int</code> <p>Interpolation factor for k-points. Defaults to 4.</p> <code>4</code> <code>periods</code> <code>int</code> <p>Number of periods. Defaults to 3.</p> <code>3</code> <code>pickle_id</code> <code>str</code> <p>Identifier for pickling. Defaults to None.</p> <code>None</code> <code>k_points</code> <code>list</code> <p>List of k-points. Defaults to None.</p> <code>None</code> <code>use_XY</code> <code>bool</code> <p>Flag to use XY plane. Defaults to True.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>lattice_type</code> <code>str</code> <p>Type of the lattice.</p> <code>num_bands</code> <code>int</code> <p>Number of bands.</p> <code>resolution</code> <code>tuple[int, int] | int</code> <p>Resolution of the simulation.</p> <code>interp</code> <code>int</code> <p>Interpolation factor for k-points.</p> <code>periods</code> <code>int</code> <p>Number of periods.</p> <code>pickle_id</code> <code>str</code> <p>Identifier for pickling.</p> <code>has_been_run</code> <code>bool</code> <p>Flag indicating if the simulation has been run.</p> <code>geometry_lattice</code> <code>None</code> <p>Geometry lattice, set with basic lattice method.</p> <code>k_points</code> <code>list</code> <p>List of k-points.</p> <code>k_points_interpolated</code> <code>list</code> <p>Interpolated k-points.</p> <code>material</code> <code>Crystal_Materials</code> <p>Material of the photonic crystal.</p> <code>geometry</code> <code>Crystal_Geometry</code> <p>Geometry of the photonic crystal.</p> <code>ms</code> <code>None</code> <p>Placeholder for ms attribute.</p> <code>md</code> <code>None</code> <p>Placeholder for md attribute.</p> <code>freqs</code> <code>dict</code> <p>Dictionary to store frequencies.</p> <code>gaps</code> <code>dict</code> <p>Dictionary to store gaps.</p> <code>epsilon</code> <code>None</code> <p>Placeholder for epsilon attribute.</p> <code>modes</code> <code>list</code> <p>List to store modes.</p> <code>use_XY</code> <code>bool</code> <p>Flag to use XY plane.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def __init__(self,\n            lattice_type = None,\n            material: Crystal_Materials = None,\n            geometry: Crystal_Geometry = None, \n            num_bands: int = 6,\n            resolution = 32,\n            interp: int = 4,\n            periods: int = 3, \n            pickle_id = None, \n            k_points = None,\n            use_XY  = True\n            ):\n    \"\"\"\n    Initializes the PhotonicCrystal class with the given parameters.\n\n    Args:\n        lattice_type (str, optional): Type of the lattice. Defaults to None.\n        material (Crystal_Materials, optional): The material object. Defaults to None.\n        geometry (Crystal_Geometry, optional): The geometry object. Defaults to None.\n        num_bands (int, optional): Number of bands. Defaults to 6.\n        resolution (tuple[int, int] | int, optional): Resolution of the simulation. Defaults to 32.\n        interp (int, optional): Interpolation factor for k-points. Defaults to 4.\n        periods (int, optional): Number of periods. Defaults to 3.\n        pickle_id (str, optional): Identifier for pickling. Defaults to None.\n        k_points (list, optional): List of k-points. Defaults to None.\n        use_XY (bool, optional): Flag to use XY plane. Defaults to True.\n\n    Attributes:\n        lattice_type (str): Type of the lattice.\n        num_bands (int): Number of bands.\n        resolution (tuple[int, int] | int): Resolution of the simulation.\n        interp (int): Interpolation factor for k-points.\n        periods (int): Number of periods.\n        pickle_id (str): Identifier for pickling.\n        has_been_run (bool): Flag indicating if the simulation has been run.\n        geometry_lattice (None): Geometry lattice, set with basic lattice method.\n        k_points (list): List of k-points.\n        k_points_interpolated (list): Interpolated k-points.\n        material (Crystal_Materials): Material of the photonic crystal.\n        geometry (Crystal_Geometry): Geometry of the photonic crystal.\n        ms (None): Placeholder for ms attribute.\n        md (None): Placeholder for md attribute.\n        freqs (dict): Dictionary to store frequencies.\n        gaps (dict): Dictionary to store gaps.\n        epsilon (None): Placeholder for epsilon attribute.\n        modes (list): List to store modes.\n        use_XY (bool): Flag to use XY plane.\n    \"\"\"\n    self.lattice_type = lattice_type\n    self.num_bands = num_bands\n    self.resolution = resolution\n    self.interp = interp\n    self.periods = periods\n    self.pickle_id = pickle_id\n    self.has_been_run = False #update this manually\n\n    #this values are set with basic lattice method\n    self.geometry_lattice= None \n    self.k_points = k_points\n    if self.k_points is not None:\n        self.k_points_interpolated = mp.interpolate(self.interp, self.k_points)\n\n\n    #material\n    self.material = material if material is not None else PhotonicCrystal.basic_material()\n\n    #geometry\n    self.geometry = geometry if geometry is not None else PhotonicCrystal.basic_geometry(material = self.material)\n\n    self.ms = None\n    self.md = None\n\n    self.freqs = {}\n    self.gaps = {}\n    self.epsilon = None\n    self.modes= []\n    self.use_XY = use_XY\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.basic_geometry","title":"<code>basic_geometry(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Define the basic geometry of the photonic crystal. Must be implemented in the derived class.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_geometry(**kwargs):\n    \"\"\" \n    Define the basic geometry of the photonic crystal.\n    Must be implemented in the derived class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.basic_lattice","title":"<code>basic_lattice(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Define the basic lattice of the photonic crystal. Must be implemented in the derived class.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_lattice(**kwargs):\n    \"\"\"\n    Define the basic lattice of the photonic crystal.\n    Must be implemented in the derived class.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.basic_material","title":"<code>basic_material()</code>  <code>staticmethod</code>","text":"<p>Define the basic material of the photonic crystal.</p> <p>Returns:</p> Name Type Description <code>material</code> <code>Crystal_Materials</code> <p>Silicon Membrane.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef basic_material():\n    \"\"\"\n    Define the basic material of the photonic crystal.\n\n    Returns:\n        material (Crystal_Materials): Silicon Membrane. \n    \"\"\"\n\n    material = Crystal_Materials()\n    material.atom = {\"epsilon\": 1}\n    material.background = {\"epsilon\": 1}\n    material.substrate = {\"epsilon\": 1}\n    material.bulk = {\"epsilon\": 11.8}\n    return material\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.convert_mode_fields","title":"<code>convert_mode_fields(mode, periods=1)</code>","text":"<p>Convert the mode fields to mpb.MPBArray for visualization. Apparently this is necessary to visualize the fields if crystal is restored from pickle.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>dict</code> <p>The mode dictionary.</p> required <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the electric field array and the magnetic field array for visualization.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def convert_mode_fields(self, mode, periods=1)-&gt; tuple:\n    \"\"\"\n    Convert the mode fields to mpb.MPBArray for visualization.\n    Apparently this is necessary to visualize the fields if crystal is restored from pickle.\n\n    Args:\n        mode (dict): The mode dictionary.\n        periods (int): The number of periods to extract. Default is 1.\n\n    Returns:\n        tuple: A tuple containing the electric field array and the magnetic field array for visualization.\n    \"\"\"\n\n    with suppress_output():\n        self.run_dumb_simulation()\n        md = mpb.MPBData(rectify=True, periods=periods, lattice=self.ms.get_lattice())\n        e_field_array = mpb.MPBArray(mode[\"e_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n        h_field_array = mpb.MPBArray(mode[\"h_field\"], lattice=self.ms.get_lattice(), kpoint=mode[\"k_point\"])\n\n        e_field =  md.convert(e_field_array)\n        h_field =  md.convert(h_field_array)            \n        return e_field, h_field \n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.extract_data","title":"<code>extract_data(periods=5)</code>","text":"<p>Extract the data from the simulation. Basically it creates a MPBData object.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 5.</p> <code>5</code> <p>Returns:</p> Type Description <p>mpb.MPBData: The MPB data object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def extract_data(self, periods = 5):\n    \"\"\"\n    Extract the data from the simulation. Basically it creates a MPBData object.\n\n    Args:\n        periods (int, optional): The number of periods to extract. Default is 5.\n\n    Returns:\n        mpb.MPBData: The MPB data object.\n    \"\"\"\n\n    if self.ms is None:\n        raise ValueError(\"Solver is not set. Call set_solver() before extracting data.\")\n\n    self.md = mpb.MPBData(rectify=True, periods=periods, resolution=self.resolution)\n    return self.md\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.find_modes_symmetries","title":"<code>find_modes_symmetries()</code>","text":"<p>Find the symmetries of the modes. Not implemented yet. TODO</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def find_modes_symmetries(self):\n    \"\"\"\n    Find the symmetries of the modes.\n    Not implemented yet. TODO\n    \"\"\"\n    raise NotImplementedError(\"find_modes_symmetries method not implemented yet.\")\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.get_XY_k_points_near_gamma","title":"<code>get_XY_k_points_near_gamma(distance=0.1)</code>","text":"<p>Get the relevant k-points near the gamma point for the X and Y directions. This is useful for plotting the bands with the X and Y directions on the x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance from the gamma point. Default is 0.1.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary with the relevant k-points for the X and Y directions.</p> <code>dict</code> <p>with the k-point names as keys and the k-point vectors as values.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def get_XY_k_points_near_gamma(self, distance = 0.1) -&gt; dict:\n    \"\"\"\n    Get the relevant k-points near the gamma point for the X and Y directions.\n    This is useful for plotting the bands with the X and Y directions on the x-axis.\n\n    Args:\n        distance (float): The distance from the gamma point. Default is 0.1.\n\n    Returns:\n        dict: A dictionary with the relevant k-points for the X and Y directions.\n        with the k-point names as keys and the k-point vectors as values.\n    \"\"\"\n\n    if distance &gt;= 0.5:\n        raise ValueError(\"Distance must be less than 0.5\")\n    relevant_k_points = {\n        'X': mp.Vector3(0.5, 0),\n        '\u0393': mp.Vector3(0, 0, 0),\n        'Y': mp.Vector3(0,0.5, 0)\n    }\n    return relevant_k_points\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.get_high_symmetry_points","title":"<code>get_high_symmetry_points()</code>","text":"<p>Get the high symmetry points for the photonic crystal lattice. This is useful for plotting the bands with the high symmetry points on the x-axis.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary with the high symmetry points for the lattice.</p> <code>dict</code> <p>with the k-point names as keys and the k-point vectors as values.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def get_high_symmetry_points(self) -&gt; dict:\n    \"\"\"\n    Get the high symmetry points for the photonic crystal lattice.\n    This is useful for plotting the bands with the high symmetry points on the x-axis.\n\n    Returns:\n        dict: A dictionary with the high symmetry points for the lattice.\n        with the k-point names as keys and the k-point vectors as values.\n    \"\"\"\n\n    k_high_sym = {}\n    if self.lattice_type == 'square':\n        k_high_sym = {\n            '\u0393': mp.Vector3(0, 0, 0),\n            'X': mp.Vector3(0.5, 0, 0),\n            'M': mp.Vector3(0.5, 0.5, 0)\n        }\n    elif self.lattice_type == 'triangular':\n        k_high_sym = {\n            '\u0393': mp.Vector3(0, 0, 0),\n            'K': mp.Vector3(1/3, 1/3, 0),\n            'M': mp.Vector3(0.5, 0, 0)\n        }\n    return k_high_sym\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.load_photonic_crystal","title":"<code>load_photonic_crystal(pickle_id)</code>  <code>staticmethod</code>","text":"<p>Load a pickled photonic crystal object.</p> <p>Parameters:</p> Name Type Description Default <code>pickle_id</code> <code>str</code> <p>The identifier for the pickle file.</p> required <p>Returns:</p> Name Type Description <code>PhotonicCrystal</code> <code>PhotonicCrystal</code> <p>The loaded photonic crystal object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>@staticmethod\ndef load_photonic_crystal(pickle_id) -&gt; 'PhotonicCrystal':\n    \"\"\"Load a pickled photonic crystal object.\n\n    Args:\n        pickle_id (str): The identifier for the pickle file.\n\n    Returns:\n        PhotonicCrystal: The loaded photonic crystal object.\n    \"\"\"\n    with open(f\"{pickle_id}.pkl\", \"rb\") as f:\n        return pickle.load(f)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.look_for_mode","title":"<code>look_for_mode(polarization, k_point, freq, freq_tolerance=0.01, k_point_max_distance=None)</code>","text":"<p>Look for modes within the specified criteria.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>str</code> <p>The polarization of the mode.</p> required <code>k_point</code> <code>tuple</code> <p>The k-point of the mode.</p> required <code>freq</code> <code>float</code> <p>The frequency of the mode.</p> required <code>freq_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of mode dictionaries that match the criteria.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def look_for_mode(self, polarization, k_point, freq,  freq_tolerance=0.01, k_point_max_distance = None):\n    \"\"\"\n    Look for modes within the specified criteria.\n\n    Args:\n        polarization (str): The polarization of the mode.\n        k_point (tuple): The k-point of the mode.\n        freq (float): The frequency of the mode.\n        freq_tolerance (float): The tolerance for frequency similarity.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n\n    Returns:\n        list: A list of mode dictionaries that match the criteria.\n    \"\"\"\n\n    target_modes = []\n    if k_point_max_distance is None:\n        for mode in self.modes:\n            if mode[\"polarization\"] == polarization and mode[\"k_point\"] == k_point and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                target_modes.append(mode)\n    else:\n        for mode in self.modes:\n            if mode[\"polarization\"] == polarization and np.linalg.norm(np.array(mode[\"k_point\"]) - np.array(k_point)) &lt;= k_point_max_distance and abs(mode[\"freq\"] - freq) &lt;= freq_tolerance:\n                target_modes.append(mode)\n    return target_modes\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.pickle_photonic_crystal","title":"<code>pickle_photonic_crystal(pickle_id)</code>","text":"<p>Pickle the photonic crystal object.</p> <p>Parameters:</p> Name Type Description Default <code>pickle_id</code> <code>str</code> <p>The identifier for the pickle file.</p> required Source code in <code>src/photonic_crystal.py</code> <pre><code>def pickle_photonic_crystal(self, pickle_id):\n    \"\"\"Pickle the photonic crystal object.\n\n    Args:\n        pickle_id (str): The identifier for the pickle file.\n    \"\"\"\n    with open(f\"{pickle_id}.pkl\", \"wb\") as f:\n        pickle.dump(self, f)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_bands","title":"<code>plot_bands(polarization='te', title='Bands', fig=None, color='blue')</code>","text":"<p>Plot the bands of the photonic crystal using Plotly.</p> <p>This method plots the bands for the specified polarization. In Dash and Jupyter Notebook, the plot is interactive and data are shown on hover.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>str</code> <p>The polarization of the bands. Default is 'te'.</p> <code>'te'</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Bands'.</p> <code>'Bands'</code> <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the bands plot to. Default is None.</p> <code>None</code> <code>color</code> <code>str</code> <p>The color of the bands. Default is 'blue'.</p> <code>'blue'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_bands(self, polarization=\"te\", title='Bands', fig=None, color='blue')-&gt; go.Figure:\n    \"\"\"\n    Plot the bands of the photonic crystal using Plotly.\n\n    This method plots the bands for the specified polarization.\n    In Dash and Jupyter Notebook, the plot is interactive and data are shown on hover.\n\n    Args:\n        polarization (str, optional): The polarization of the bands. Default is 'te'.\n        title (str, optional): The title of the plot. Default is 'Bands'.\n        fig (go.Figure, optional): The Plotly figure to add the bands plot to. Default is None.\n        color (str, optional): The color of the bands. Default is 'blue'.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n    if self.freqs[polarization] is None:\n        print(\"Simulation not run yet. Please run the simulation first.\")\n        return\n    freqs = self.freqs[polarization]\n    gaps = self.gaps[polarization]\n\n    xs = list(range(len(freqs)))\n\n    # Extract the interpolated k-points as vectors and format them for hover and click\n    k_points_interpolated = [kp for kp in self.k_points_interpolated]\n\n    if fig is None:\n        fig = go.Figure()\n\n    # Iterate through each frequency band and add them to the plot\n    for band_index, band in enumerate(zip(*freqs)):\n        # Generate hover text with the corresponding k-point and frequency\n        hover_texts = [\n            f\"k-point: ({kp.x:.4f}, {kp.y:.4f}, {kp.z:.4f})&lt;br&gt;frequency: {f:.4f}\"\n            for kp, f in zip(k_points_interpolated, band)\n        ]\n\n\n\n        modes =[]\n        for i, kp in enumerate(k_points_interpolated):\n            mode = self.look_for_mode(polarization, kp, band[i], freq_tolerance=1e-12)\n            modes.append(mode[0])\n\n\n\n        # Add the line trace with hover info\n        fig.add_trace(go.Scatter(\n            x=xs, \n            y=band, \n            mode='lines', \n            line=dict(color=color),\n            text=hover_texts,  # Custom hover text\n            hoverinfo='text',  # Display only the custom hover text\n            customdata=[(kp.x, kp.y, kp.z, f, polarization) for kp, f in zip(k_points_interpolated, band)],  # Attach k-points and frequency as custom data\n            showlegend=False,  # Hide from legend (we\u2019ll add a separate legend entry)\n            legendgroup=polarization,  # Group traces by polarization for toggling visibility\n            visible=True,  # Initially visible\n            selectedpoints=[],  # Placeholder for selected points\n            selected=dict(marker=dict(color=\"red\", size=10)),  # Change color and size of selected points\n            unselected=dict(marker=dict(opacity=0.3))  # Make unselected points more transparent\n        ))\n\n    # Add bandgap shading (optional, grouped with the polarization for toggling visibility)\n    for gap in gaps:\n        if gap[0] &gt; 1:\n            fig.add_shape(\n                type=\"rect\",\n                x0=xs[0], \n                x1=xs[-1],\n                y0=gap[1], \n                y1=gap[2],\n                fillcolor=color, \n                opacity=0.2, \n                line_width=0,\n                layer=\"below\",\n                legendgroup=polarization,  # Group shading with the same polarization\n                visible=True  # Initially visible\n            )\n\n    # Add a single legend entry for toggling visibility\n    fig.add_trace(go.Scatter(\n        x=[None], y=[None],\n        mode='lines',\n        line=dict(color=color),\n        name=f'{polarization.upper()}',  # Legend entry for the polarization\n        legendgroup=polarization,  # Group with the same polarization traces\n        showlegend=True,  # Show the legend entry\n        visible=True,  # Initially visible\n    ))\n\n    # Customize the x-axis \n    if self.use_XY is True:  # Use X and Y directions for the x-axis\n        relevant_k_points = self.get_XY_k_points_near_gamma()\n        fig.update_layout(\n            title=title,\n            xaxis=dict(\n                tickmode='array',\n                tickvals=[i * (len(freqs) - 3) / 2 + i for i in range(3)],\n                ticktext=list(relevant_k_points.keys())  # Only three values, no repetition\n            ),\n            yaxis_title='frequency (c/a)',\n            showlegend=True,\n            dragmode='select',  # Enables rectangular selection\n            clickmode='event+select',  # Enable click events and selection events\n            legend=dict(  # This ensures that clicking the legend will toggle visibility\n                itemclick=\"toggle\",  # Toggle visibility when clicked\n                itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n            )\n        )\n    else:\n        relevant_k_points = self.get_high_symmetry_points() # Use high symmetry points for the x-axis \n                                                            # Gamma, X, M for square lattice and\n                                                            # Gamma, K, M for triangular lattice                                                   \n        fig.update_layout(\n            title=title,\n            xaxis=dict(\n                tickmode='array',\n                tickvals=[i * (len(freqs) - 4) / 3 + i for i in range(4)],\n                ticktext=list(relevant_k_points.keys()) + [list(relevant_k_points.keys())[0]]  # Repeat the first element at the end\n            ),\n            yaxis_title='frequency (c/a)',\n            showlegend=True,\n            dragmode='select',  # Enables rectangular selection\n            clickmode='event+select',  # Enable click events and selection events\n            legend=dict(  # This ensures that clicking the legend will toggle visibility\n                itemclick=\"toggle\",  # Toggle visibility when clicked\n                itemdoubleclick=\"toggleothers\"  # Double-click to hide/show other entries\n            )\n        )\n\n    return fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_epsilon","title":"<code>plot_epsilon(fig=None, title='Epsilon')</code>","text":"<p>Plot the epsilon of the photonic crystal interactively using Plotly. Not implemented in the base class. Must be implemented in the derived class.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the epsilon plot to. Default is None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot. Default is 'Epsilon'.</p> <code>'Epsilon'</code> <p>Returns:</p> Type Description <p>go.Figure: The Plotly figure object.(Not woroking yet, error is thrown)</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_epsilon(self, fig=None, title='Epsilon') :\n    \"\"\"\n    Plot the epsilon of the photonic crystal interactively using Plotly.\n    Not implemented in the base class. Must be implemented in the derived class.\n\n    Args:\n        fig (go.Figure, optional): The Plotly figure to add the epsilon plot to. Default is None.\n        title (str, optional): The title of the plot. Default is 'Epsilon'.\n\n    Returns:\n        go.Figure: The Plotly figure object.(Not woroking yet, error is thrown)\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_field","title":"<code>plot_field(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=5, component=2, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the field visualization. Not implemented in the base class. Must be implemented in the derived class.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity. Default is 0.01.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 5.</p> <code>5</code> <code>component</code> <code>int</code> <p>The component of the field to plot. Default is 2.</p> <code>2</code> <code>quantity</code> <code>str</code> <p>The quantity of the field to plot. Default is \"real\".</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the plot. Default is \"RdBu\".</p> <code>'RdBu'</code> <p>Returns:</p> Type Description <p>tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field(\n    self, \n    target_polarization,\n    target_k_point,\n    target_frequency,\n    frequency_tolerance=0.01,\n    k_point_max_distance=None,\n    periods=5,\n    component: int = 2,\n    quantity: str = \"real\",\n    colorscale: str = \"RdBu\",\n): \n    \"\"\"\n    Plot the field visualization.\n    Not implemented in the base class. Must be implemented in the derived class.\n\n    Args:\n        target_polarization (str): The polarization of the mode.\n        target_k_point (tuple): The k-point of the mode.\n        target_frequency (float): The frequency of the mode.\n        frequency_tolerance (float): The tolerance for frequency similarity. Default is 0.01.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n        periods (int): The number of periods to extract. Default is 5.\n        component (int): The component of the field to plot. Default is 2.\n        quantity (str): The quantity of the field to plot. Default is \"real\".\n        colorscale (str): The colorscale for the plot. Default is \"RdBu\".\n\n    Returns:\n        tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.           \n\n    \"\"\"\n    raise NotImplementedError(\"plot_field method not implemented yet.\")\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_field_components","title":"<code>plot_field_components(target_polarization, target_k_point, target_frequency, frequency_tolerance=0.01, k_point_max_distance=None, periods=1, quantity='real', colorscale='RdBu')</code>","text":"<p>Plot the field visualization. Not implemented in the base class. Must be implemented in the derived class.</p> <p>Parameters:</p> Name Type Description Default <code>target_polarization</code> <code>str</code> <p>The polarization of the mode.</p> required <code>target_k_point</code> <code>tuple</code> <p>The k-point of the mode.</p> required <code>target_frequency</code> <code>float</code> <p>The frequency of the mode.</p> required <code>frequency_tolerance</code> <code>float</code> <p>The tolerance for frequency similarity. Default is 0.01.</p> <code>0.01</code> <code>k_point_max_distance</code> <code>float</code> <p>The maximum distance for k-point similarity. Default is None.</p> <code>None</code> <code>periods</code> <code>int</code> <p>The number of periods to extract. Default is 1.</p> <code>1</code> <code>quantity</code> <code>str</code> <p>The quantity of the field to plot. Default is \"real\".</p> <code>'real'</code> <code>colorscale</code> <code>str</code> <p>The colorscale for the plot. Default is \"RdBu\".</p> <code>'RdBu'</code> <p>Returns:</p> Type Description <p>tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_field_components(\n        self,\n        target_polarization,\n        target_k_point,\n        target_frequency,\n        frequency_tolerance=0.01,\n        k_point_max_distance=None,\n        periods: int = 1,\n        quantity: str = \"real\",\n        colorscale: str = 'RdBu',\n        ):\n\n    \"\"\"\n    Plot the field visualization.\n    Not implemented in the base class. Must be implemented in the derived class.\n\n    Args:\n        target_polarization (str): The polarization of the mode.\n        target_k_point (tuple): The k-point of the mode.\n        target_frequency (float): The frequency of the mode.\n        frequency_tolerance (float): The tolerance for frequency similarity. Default is 0.01.\n        k_point_max_distance (float, optional): The maximum distance for k-point similarity. Default is None.\n        periods (int): The number of periods to extract. Default is 1.\n        quantity (str): The quantity of the field to plot. Default is \"real\".\n        colorscale (str): The colorscale for the plot. Default is \"RdBu\".\n\n    Returns:\n        tuple[go.Figure, go.Figure]: A tuple containing the Plotly figures for the electric and magnetic fields.           \n    \"\"\"\n\n    raise NotImplementedError(\"plot_field_components method not implemented yet.\")\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_mode_fields_normal_to_k","title":"<code>plot_mode_fields_normal_to_k(mode, k)</code>","text":"<p>Plot the fields perpendicular to the wavevector k for the mode. To be tested, not sure if works correctly.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>dict</code> <p>The mode dictionary.</p> required <code>k</code> <code>ndarray</code> <p>The wavevector [kx, ky, kz].</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_mode_fields_normal_to_k(self, mode, k):\n    \"\"\"\n    Plot the fields perpendicular to the wavevector k for the mode.\n    To be tested, not sure if works correctly.\n\n    Args:\n        mode (dict): The mode dictionary.\n        k (numpy.ndarray): The wavevector [kx, ky, kz].\n\n    Returns:\n        tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n    \"\"\"\n    fields = [mode[\"e_field\"], mode[\"h_field\"]]\n    fields_norm_to_k = self._calculate_field_norm_to_k(fields, k)\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n\n\n    fig_e.add_trace(self._field_to_cones(fields_norm_to_k[0], colorscale=\"blues\"))\n    fig_h.add_trace(self._field_to_cones(fields_norm_to_k[1], colorscale=\"reds\"))\n    return fig_e, fig_h \n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_modes_vectorial_fields","title":"<code>plot_modes_vectorial_fields(modes, sizemode='scaled', names=['Electric Field', 'Magnetic Field'])</code>","text":"<p>Plot the vectorial fields of the modes.</p> <p>Parameters:</p> Name Type Description Default <code>modes</code> <code>list</code> <p>The list of modes to plot.</p> required <code>sizemode</code> <code>str</code> <p>The sizemode for the cones. Default is 'scaled'.</p> <code>'scaled'</code> <code>names</code> <code>list</code> <p>The names of the fields. Default is ['Electric Field', 'Magnetic Field'].</p> <code>['Electric Field', 'Magnetic Field']</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_modes_vectorial_fields(self, modes, sizemode=\"scaled\", names=[\"Electric Field\", \"Magnetic Field\"]):\n    \"\"\"\n    Plot the vectorial fields of the modes.\n\n    Args:\n        modes (list): The list of modes to plot.\n        sizemode (str): The sizemode for the cones. Default is 'scaled'.\n        names (list): The names of the fields. Default is ['Electric Field', 'Magnetic Field'].\n\n    Returns:\n        tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n    \"\"\"\n\n    colorscales = [\"blues\", \"reds\", \"greens\", \"purples\", \"oranges\", \"ylorbr\"]\n\n    h_fields = [mode[\"h_field\"] for mode in modes]\n    e_fields = [mode[\"e_field\"] for mode in modes]\n\n    max_norm_h = PhotonicCrystal._calculate_fields_max_norms(h_fields)\n    max_norm_e = PhotonicCrystal._calculate_fields_max_norms(e_fields)\n\n    e_sizeref = max_norm_e\n    h_sizeref = max_norm_h\n\n    e_clim = (0, max_norm_e)\n    h_clim= (0, max_norm_h)\n\n\n    e_fig = go.Figure()\n    h_fig = go.Figure()\n\n    e_cones = PhotonicCrystal._fields_to_cones(e_fields, colorscale=colorscales[0], sizemode=sizemode, sizeref=e_sizeref, clim=e_clim, colorscales=colorscales)\n    h_cones = PhotonicCrystal._fields_to_cones(h_fields, colorscale=colorscales[1], sizemode=sizemode, sizeref=h_sizeref, clim=h_clim, colorscales=colorscales) \n\n\n    for e_cone in e_cones:  \n        e_fig.add_trace(e_cone)\n    for h_cone in h_cones:\n        h_fig.add_trace(h_cone)\n\n\n    e_fig.update_layout(\n        title=names[0],\n        scene=dict(\n        xaxis=dict(title='X'),\n        yaxis=dict(title='Y'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n\n    h_fig.update_layout(\n        title=names[1],\n        scene=dict(\n        xaxis=dict(title='X'),\n        yaxis=dict(title='Y'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n\n    return e_fig, h_fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_sweep_result","title":"<code>plot_sweep_result(data, fig=None)</code>","text":"<p>Plot the sweep result using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list</code> <p>The data from the sweep.</p> required <code>fig</code> <code>Figure</code> <p>The Plotly figure to add the plot to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: The Plotly figure object.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_sweep_result(self, data, fig=None) -&gt; go.Figure:\n    \"\"\"\n    Plot the sweep result using Plotly.\n\n    Args:\n        data (list): The data from the sweep.\n        fig (go.Figure): The Plotly figure to add the plot to.\n\n    Returns:\n        go.Figure: The Plotly figure object.\n    \"\"\"\n\n    if fig is None:\n        fig = go.Figure()\n\n    # For each data parameter value in the x axis, add all the modes frequencies (mode[\"freq\"])in the y axis\n    num_bands = len(data[0]['modes_zeven'])\n    for i in range(num_bands):\n        modes_zeven = [d['modes_zeven'][i] for d in data]\n        modes_zodd = [d['modes_zodd'][i] for d in data]\n        param_values = [d['parameter_value'] for d in data]   \n        fig.add_trace(go.Scatter(x=param_values, y=[m[\"freq\"] for m in modes_zeven], mode='lines+markers', name=f'Band {i} TE', line=dict(color='red'), marker=dict(symbol=i, size=10)))\n        fig.add_trace(go.Scatter(x=param_values, y=[m[\"freq\"] for m in modes_zodd], mode='lines+markers', name=f'Band {i} TM', line=dict(color='blue'), marker=dict(symbol=i, size=10)))\n    fig.update_layout(\n        autosize=False,\n        width=700,\n        height=700,\n    )   \n\n    fig.update_layout(\n        xaxis_title='Parameter Value',\n        yaxis_title='Frequency (c/a)',\n        title=f\"Sweep of {data[0]['parameter_name']}\",\n        showlegend=True\n    )\n\n    return fig\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.plot_vectorial_fields","title":"<code>plot_vectorial_fields(fields, colorscales=['Viridis', 'Viridis'], names=['Field 1', 'Field 2'])</code>","text":"<p>Plot the vectorial fields of the modes.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>list</code> <p>The list of fields to plot.</p> required <code>colorscales</code> <code>list</code> <p>The colorscales for the cones. Default is [\"Viridis\", \"Viridis\"].</p> <code>['Viridis', 'Viridis']</code> <code>names</code> <code>list</code> <p>The names of the fields. Default is [\"Field 1\", \"Field 2\"].</p> <code>['Field 1', 'Field 2']</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the Plotly figures for the electric and magnetic fields.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def plot_vectorial_fields(self, fields, colorscales=[\"Viridis\",\"Viridis\"], names=[\"Field 1\", \"Field 2\"]): \n    \"\"\"\n    Plot the vectorial fields of the modes.\n\n    Args:\n        fields (list): The list of fields to plot.\n        colorscales (list, optional): The colorscales for the cones. Default is [\"Viridis\", \"Viridis\"].\n        names (list, optional): The names of the fields. Default is [\"Field 1\", \"Field 2\"].\n\n    Returns:\n        tuple: A tuple containing the Plotly figures for the electric and magnetic fields.\n    \"\"\"\n\n    fig_e = go.Figure()\n    fig_h = go.Figure()\n    fig_e.add_trace(self._field_to_cones(fields[0], colorscale=colorscales[0]))\n    fig_h.add_trace(self._field_to_cones(fields[1], colorscale=colorscales[1]))\n    fig_e.update_layout(\n        title=names[0],\n        scene=dict(\n        xaxis=dict(title='Y'),\n        yaxis=dict(title='X'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n\n    fig_h.update_layout(\n        title=names[1],\n        scene=dict(\n        xaxis=dict(title='Y'),\n        yaxis=dict(title='X'),\n        zaxis=dict(title='Z')\n        ),\n        margin=dict(l=0, r=0, b=0, t=40),\n        showlegend=True\n    )\n    return fig_e, fig_h\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.run_dumb_simulation","title":"<code>run_dumb_simulation()</code>","text":"<p>Run a dumb simulation.  It is the first band of the gamma point. This is used to quickly extract some values from the simulation later.  For example it can be used to extract epsilon values.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def run_dumb_simulation(self) -&gt; mpb.ModeSolver:    \n    \"\"\"\n    Run a dumb simulation.  It is the first band of the gamma point.\n    This is used to quickly extract some values from the simulation later. \n    For example it can be used to extract epsilon values.\n    \"\"\"\n\n    #run the simulation in the gamma point, find one mode\n    self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                              geometry_lattice=self.geometry_lattice,\n                              k_points=[mp.Vector3()],\n                              resolution=self.resolution,\n                              num_bands=1)\n    with suppress_output():\n        self.ms.run()\n    ms = self.ms\n    return ms\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.run_simulation","title":"<code>run_simulation(runner='run_zeven', polarization=None)</code>","text":"<p>Run the simulation to calculate the frequencies and gaps.</p> <p>Parameters:</p> Name Type Description Default <code>runner</code> <code>str</code> <p>The name of the function to run the simulation. Default is 'run_zeven'.  runner must correspond to an MPB runner. For example:</p> <ul> <li>'run_zeven': Run the simulation for even parity modes in z-axis.</li> <li>'run_zodd': Run the simulation for odd parity modes in z-axis.</li> <li>'run_tm': Run the simulation for transverse magnetic modes.</li> <li>'run_te': Run the simulation for transverse electric modes.</li> <li>'run': Do not consider symmetry.</li> </ul> <code>'run_zeven'</code> <code>polarization</code> <code>str</code> <p>The polarization of the simulation. Default is None. If None, it uses the runner name.</p> <code>None</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def run_simulation(self, runner=\"run_zeven\", polarization=None):\n    \"\"\"\n    Run the simulation to calculate the frequencies and gaps.\n\n    Args:\n        runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n            runner must correspond to an MPB runner. For example:\n\n            - 'run_zeven': Run the simulation for even parity modes in z-axis.\n            - 'run_zodd': Run the simulation for odd parity modes in z-axis.\n            - 'run_tm': Run the simulation for transverse magnetic modes.\n            - 'run_te': Run the simulation for transverse electric modes.\n            - 'run': Do not consider symmetry.\n        polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n\n\n    \"\"\"\n    if self.ms is None:\n        raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n    if polarization is not None:\n        polarization = polarization\n    else:\n        if runner.startswith(\"run_\"):\n            polarization = runner[4:]\n        else:\n            polarization = runner\n\n    # This is a custom mpb output function that stores the fields and frequencies\n    def get_mode_data(ms, band):\n        mode = {\n            \"h_field\": ms.get_hfield(band, bloch_phase=True),\n            \"e_field\": ms.get_efield(band, bloch_phase=True),\n            \"freq\": ms.freqs[band-1],\n            \"k_point\": ms.current_k,\n            \"polarization\": polarization\n        }\n        self.modes.append(mode)\n\n    print(self.k_points_interpolated)\n    with suppress_output():\n        getattr(self.ms, runner)(get_mode_data)\n        self.freqs[polarization] = self.ms.all_freqs\n        self.gaps[polarization] = self.ms.gap_list\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.run_simulation_with_output","title":"<code>run_simulation_with_output(runner='run_zeven', polarization=None)</code>","text":"<p>Run the simulation and get mode data. Mode data are not stored in the crystal object,  but are returned as a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>runner</code> <code>str</code> <p>The name of the function to run the simulation. Default is 'run_zeven'.  runner must correspond to an MPB runner. For example: </p> <ul> <li>'run_zeven': Run the simulation for even parity modes in z-axis.</li> <li>'run_zodd': Run the simulation for odd parity modes in z-axis.</li> <li>'run_tm': Run the simulation for transverse magnetic modes.</li> <li>'run_te': Run the simulation for transverse electric modes.</li> <li>'run': Do not consider symmetry.   </li> </ul> <code>'run_zeven'</code> <code>polarization</code> <code>str</code> <p>The polarization of the simulation. Default is None. If None, it uses the runner name.</p> <code>None</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def run_simulation_with_output(self, runner=\"run_zeven\", polarization=None):\n    \"\"\"\n    Run the simulation and get mode data. Mode data are not stored in the crystal object, \n    but are returned as a list of dictionaries.\n\n    Args:\n        runner (str): The name of the function to run the simulation. Default is 'run_zeven'. \n            runner must correspond to an MPB runner. For example: \n\n            - 'run_zeven': Run the simulation for even parity modes in z-axis.\n            - 'run_zodd': Run the simulation for odd parity modes in z-axis.\n            - 'run_tm': Run the simulation for transverse magnetic modes.\n            - 'run_te': Run the simulation for transverse electric modes.\n            - 'run': Do not consider symmetry.   \n\n        polarization (str, optional): The polarization of the simulation. Default is None. If None, it uses the runner name.\n\n    \"\"\"\n    if self.ms is None:\n        raise ValueError(\"Solver is not set. Call set_solver() before running the simulation.\")\n\n    if polarization is not None:\n        polarization = polarization\n    else:\n        if runner.startswith(\"run_\"):\n            polarization = runner[4:]\n        else:\n            polarization = runner\n    modes=[]\n    # This is a custom mpb output function that stores the fields and frequencies\n    def get_mode_data(ms, band):\n        mode = {\n            \"h_field\": ms.get_hfield(band, bloch_phase=True),\n            \"e_field\": ms.get_efield(band, bloch_phase=True),\n            \"freq\": ms.freqs[band-1],\n            \"k_point\": ms.current_k,\n            \"polarization\": polarization\n        }\n        modes.append(mode)\n    with suppress_output():\n        getattr(self.ms, runner)(get_mode_data)\n    return modes\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.set_solver","title":"<code>set_solver(k_point=None)</code>","text":"<p>Set the mode solver for the simulation.  For how MPB works, it is better to call this method each time you want to run a simulation. This method initializes the mode solver (ms) with the geometry, geometry lattice,  k-points, resolution, and number of bands. If a specific k-point is provided,  the solver is set up for that k-point. Otherwise, it uses the interpolated k-points.</p> <p>Parameters:</p> Name Type Description Default <code>k_point</code> <code>Vector3</code> <p>The k-point for the simulation. Default is None.</p> <code>None</code> Source code in <code>src/photonic_crystal.py</code> <pre><code>def set_solver(self, k_point = None):\n    \"\"\"\n    Set the mode solver for the simulation. \n    For how MPB works, it is better to call this method each time you want to run a simulation.\n    This method initializes the mode solver (ms) with the geometry, geometry lattice, \n    k-points, resolution, and number of bands. If a specific k-point is provided, \n    the solver is set up for that k-point. Otherwise, it uses the interpolated k-points.\n\n    Args:\n        k_point (mp.Vector3, optional): The k-point for the simulation. Default is None.\n\n    \"\"\"\n\n    if k_point is not None:\n        self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                              geometry_lattice=self.geometry_lattice,\n                              k_points=[k_point],\n                              resolution=self.resolution,\n                              num_bands=self.num_bands)\n    else:\n        self.ms = mpb.ModeSolver(geometry=self.geometry.to_list(),\n                                geometry_lattice=self.geometry_lattice,\n                                k_points=self.k_points_interpolated,\n                                resolution=self.resolution,\n                                num_bands=self.num_bands)\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.PhotonicCrystal.sweep_geometry_parameter","title":"<code>sweep_geometry_parameter(param_to_sweep, sweep_values, num_bands=4)</code>","text":"<p>Sweep a parameter of the geometry and run simulations for each value.</p> <p>Parameters:</p> Name Type Description Default <code>param_to_sweep</code> <code>str</code> <p>The parameter to sweep.</p> required <code>sweep_values</code> <code>list</code> <p>The values to sweep.</p> required <code>num_bands</code> <code>int</code> <p>The number of bands to calculate. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of dictionaries with the simulation data.</p> Source code in <code>src/photonic_crystal.py</code> <pre><code>def sweep_geometry_parameter(self, param_to_sweep: str, sweep_values: list, num_bands: int =4)-&gt; list:\n\n    \"\"\"\n    Sweep a parameter of the geometry and run simulations for each value.\n\n    Args:\n        param_to_sweep (str): The parameter to sweep.\n        sweep_values (list): The values to sweep.\n        num_bands (int, optional): The number of bands to calculate. Defaults to 4.\n\n    Returns:\n        list: A list of dictionaries with the simulation data.\n\n    \"\"\"\n    data = []\n    old_geom  = self.geometry\n    old_num_bands = self.num_bands\n\n    partial_geom = self.geometry.to_partial(exclude_key=param_to_sweep)\n    for value in sweep_values:\n        kwargs = {param_to_sweep: value}\n        self.geometry = partial_geom(**kwargs)\n        self.num_bands = num_bands\n        self.set_solver(k_point=mp.Vector3())\n        modes_zeven = self.run_simulation_with_output(runner=\"run_zeven\", polarization=\"zeven\")\n        modes_zodd  = self.run_simulation_with_output(runner=\"run_zodd\", polarization=\"zodd\")\n        data.append({\n            'parameter_value': value,\n            'modes_zeven': modes_zeven,\n            'modes_zodd': modes_zodd,\n            'parameter_name': param_to_sweep,\n        })\n    self.geometry = old_geom\n    self.num_bands = old_num_bands\n    return data\n</code></pre>"},{"location":"photonic_crystal/#src.photonic_crystal.suppress_output","title":"<code>suppress_output()</code>","text":"<p>Context manager to suppress stdout and stderr.</p> <p>This context manager redirects the standard output (stdout) and standard error (stderr) to os.devnull, effectively suppressing any output within its context.</p> <p>Yields:</p> Name Type Description <code>None</code> <p>This context manager does not return any value.</p> Example <pre><code>with suppress_output():\n    print(\"This will not be printed\")\n    raise ValueError(\"This error will not be shown\")\n</code></pre> Source code in <code>src/photonic_crystal.py</code> <pre><code>@contextlib.contextmanager\ndef suppress_output():\n    \"\"\"\n    Context manager to suppress stdout and stderr.\n\n    This context manager redirects the standard output (stdout) and standard error (stderr)\n    to os.devnull, effectively suppressing any output within its context.\n\n    Yields:\n        None: This context manager does not return any value.\n\n    Example:\n        ```python\n        with suppress_output():\n            print(\"This will not be printed\")\n            raise ValueError(\"This error will not be shown\")\n        ```\n    \"\"\"\n    with open(os.devnull, 'w') as devnull:\n        old_stdout = sys.stdout\n        old_stderr = sys.stderr\n        sys.stdout = devnull\n        sys.stderr = devnull\n        try:\n            yield\n        finally:\n            sys.stdout = old_stdout\n            sys.stderr = old_stderr\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_geometries.Crystal_Geometry","title":"<code>Crystal_Geometry</code>","text":"<p>Represents a crystal geometry. This class was done to better handle geometry configuaration in the Dash app. </p> <p>Attributes:</p> Name Type Description <code>material</code> <code>Crystal_Materials</code> <p>The material of the crystal.</p> <code>geometry</code> <code>list</code> <p>List of Meep geometric objects representing the crystal geometry.</p> <code>base_geometry</code> <code>list</code> <p>List of Meep geometric objects representing the base crystal geometry. (bulk, substrate, background)</p> <code>geometry_type</code> <code>str</code> <p>Type of geometry ('circular', 'square', 'rectangular', 'elliptical').</p> <code>atomic_function</code> <code>function</code> <p>Function to add an atomic object to the geometry.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>class Crystal_Geometry:\n\n    \"\"\"\n    Represents a crystal geometry. This class was done to better handle geometry configuaration in the Dash app. \n\n    Attributes:\n        material (Crystal_Materials): The material of the crystal.\n        geometry (list): List of Meep geometric objects representing the crystal geometry.\n        base_geometry (list): List of Meep geometric objects representing the base crystal geometry. (bulk, substrate, background)\n        geometry_type (str): Type of geometry ('circular', 'square', 'rectangular', 'elliptical').\n        atomic_function (function): Function to add an atomic object to the geometry.\n    \"\"\"\n\n\n\n    GEOMETRY_TYPES = ['square', 'circular', 'rectangular', 'elliptical']\n\n\n    def __init__(self, \n                 material : Crystal_Materials,\n                 geometry_type: str = 'circular'\n                 ):\n        self.required_arguments = {\n            \"material\": material,\n            \"geometry_type\": geometry_type,\n        }\n        self.kwargs = {}\n        self.arguments = {**self.required_arguments, **self.kwargs}\n        self.material = material\n        self.geometry =[]\n        self.base_geometry = self.geometry\n        self.geometry_type = geometry_type\n\n        self.atomic_function = None\n\n\n\n    def square_atom(self, a):\n        '''\n        Adds a square atom to the geometry.\n\n        Args:\n            a (float): Length of each side of the square atom.\n\n        Raises:\n            NotImplementedError: If the method is not yet implemented.\n        '''\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n\n    def circular_atom(self, r):\n        '''\n        Adds a circular atom to the geometry.\n\n        Args:\n            r (float): Radius of the circular atom.\n\n        Raises:\n            NotImplementedError: If the method is not yet implemented.\n        '''\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n    def rectangular_atom(self, a, b):\n        '''\n        Adds a rectangular atom to the geometry.\n\n        Args:\n            a (float): Width of the rectangular atom.\n            b (float): Height of the rectangular atom.\n\n        Raises:\n            NotImplementedError: If the method is not yet implemented.\n        '''\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n    def elliptical_atom(self, a, b):\n        '''\n        Adds an elliptical atom to the geometry.\n\n        Args:\n            a (float): Length of the major axis.\n            b (float): Length of the minor axis.\n\n        Raises: \n            NotImplementedError: If the method is not yet implemented.\n        '''\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n    def build_geometry(self):\n        \"\"\"\n        Builds the crystal geometry based on the geometry type and additional keyword arguments.\n\n        Raises:\n            NotImplementedError: If the method is not yet implemented.\n        \"\"\"\n\n        raise NotImplementedError(\"This method is not yet implemented\")\n\n    def geometry_function(self, atomic_function,  **kwargs):\n        \"\"\"\n        Adds an atomic object to the geometry.\n\n        Args:\n            atomic_function (function): Function to add an atomic object to the geometry.\n            **kwargs: Additional keyword arguments specific to the atomic object.\n        \"\"\"\n\n        geometry = self.base_geometry.copy()\n        geometry.append(atomic_function(**kwargs))\n        return geometry \n\n    def to_list(self):\n        \"\"\"\n        Returns the crystal geometry as a list of Meep geometric objects.\n\n        Returns:\n            list: List of Meep geometric objects representing the crystal geometry.\n        \"\"\" \n        return self.geometry.copy()\n\n    def to_partial(self, exclude_key): \n        \"\"\"\n        Returns a partial function with the specified key excluded from the arguments.\n        This is useful for sweeps.\n\n        Args:\n            exclude_key (str): Key to exclude from the arguments.\n\n        Returns:\n            partial: Partial function with the specified key excluded from the arguments.\n        \"\"\" \n        arguments = self.arguments.copy()\n        arguments.pop(exclude_key)\n        return partial(self.__class__, **self.arguments)\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_geometries.Crystal_Geometry.build_geometry","title":"<code>build_geometry()</code>","text":"<p>Builds the crystal geometry based on the geometry type and additional keyword arguments.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def build_geometry(self):\n    \"\"\"\n    Builds the crystal geometry based on the geometry type and additional keyword arguments.\n\n    Raises:\n        NotImplementedError: If the method is not yet implemented.\n    \"\"\"\n\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_geometries.Crystal_Geometry.circular_atom","title":"<code>circular_atom(r)</code>","text":"<p>Adds a circular atom to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float</code> <p>Radius of the circular atom.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def circular_atom(self, r):\n    '''\n    Adds a circular atom to the geometry.\n\n    Args:\n        r (float): Radius of the circular atom.\n\n    Raises:\n        NotImplementedError: If the method is not yet implemented.\n    '''\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_geometries.Crystal_Geometry.elliptical_atom","title":"<code>elliptical_atom(a, b)</code>","text":"<p>Adds an elliptical atom to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Length of the major axis.</p> required <code>b</code> <code>float</code> <p>Length of the minor axis.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def elliptical_atom(self, a, b):\n    '''\n    Adds an elliptical atom to the geometry.\n\n    Args:\n        a (float): Length of the major axis.\n        b (float): Length of the minor axis.\n\n    Raises: \n        NotImplementedError: If the method is not yet implemented.\n    '''\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_geometries.Crystal_Geometry.geometry_function","title":"<code>geometry_function(atomic_function, **kwargs)</code>","text":"<p>Adds an atomic object to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_function</code> <code>function</code> <p>Function to add an atomic object to the geometry.</p> required <code>**kwargs</code> <p>Additional keyword arguments specific to the atomic object.</p> <code>{}</code> Source code in <code>src/crystal_geometries.py</code> <pre><code>def geometry_function(self, atomic_function,  **kwargs):\n    \"\"\"\n    Adds an atomic object to the geometry.\n\n    Args:\n        atomic_function (function): Function to add an atomic object to the geometry.\n        **kwargs: Additional keyword arguments specific to the atomic object.\n    \"\"\"\n\n    geometry = self.base_geometry.copy()\n    geometry.append(atomic_function(**kwargs))\n    return geometry \n</code></pre>"},{"location":"photonic_crystal/#src.crystal_geometries.Crystal_Geometry.rectangular_atom","title":"<code>rectangular_atom(a, b)</code>","text":"<p>Adds a rectangular atom to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Width of the rectangular atom.</p> required <code>b</code> <code>float</code> <p>Height of the rectangular atom.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def rectangular_atom(self, a, b):\n    '''\n    Adds a rectangular atom to the geometry.\n\n    Args:\n        a (float): Width of the rectangular atom.\n        b (float): Height of the rectangular atom.\n\n    Raises:\n        NotImplementedError: If the method is not yet implemented.\n    '''\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_geometries.Crystal_Geometry.square_atom","title":"<code>square_atom(a)</code>","text":"<p>Adds a square atom to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Length of each side of the square atom.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not yet implemented.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def square_atom(self, a):\n    '''\n    Adds a square atom to the geometry.\n\n    Args:\n        a (float): Length of each side of the square atom.\n\n    Raises:\n        NotImplementedError: If the method is not yet implemented.\n    '''\n    raise NotImplementedError(\"This method is not yet implemented\")\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_geometries.Crystal_Geometry.to_list","title":"<code>to_list()</code>","text":"<p>Returns the crystal geometry as a list of Meep geometric objects.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of Meep geometric objects representing the crystal geometry.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def to_list(self):\n    \"\"\"\n    Returns the crystal geometry as a list of Meep geometric objects.\n\n    Returns:\n        list: List of Meep geometric objects representing the crystal geometry.\n    \"\"\" \n    return self.geometry.copy()\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_geometries.Crystal_Geometry.to_partial","title":"<code>to_partial(exclude_key)</code>","text":"<p>Returns a partial function with the specified key excluded from the arguments. This is useful for sweeps.</p> <p>Parameters:</p> Name Type Description Default <code>exclude_key</code> <code>str</code> <p>Key to exclude from the arguments.</p> required <p>Returns:</p> Name Type Description <code>partial</code> <p>Partial function with the specified key excluded from the arguments.</p> Source code in <code>src/crystal_geometries.py</code> <pre><code>def to_partial(self, exclude_key): \n    \"\"\"\n    Returns a partial function with the specified key excluded from the arguments.\n    This is useful for sweeps.\n\n    Args:\n        exclude_key (str): Key to exclude from the arguments.\n\n    Returns:\n        partial: Partial function with the specified key excluded from the arguments.\n    \"\"\" \n    arguments = self.arguments.copy()\n    arguments.pop(exclude_key)\n    return partial(self.__class__, **self.arguments)\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_materials.Crystal_Materials","title":"<code>Crystal_Materials</code>","text":"<p>Crystal_Materials class for defining crystal material properties.</p> <p>This class manages the material properties of different components in a crystal structure, including background, bulk, atom, and substrate materials. Each material is defined by its dielectric properties and nonlinear susceptibility tensors.</p> <p>Usage:</p> <pre><code>Use a dictionary to set the material properties for each component. The dictionary should\ncontain the valid configuration keys for material properties. The material properties can\nbe set using the background, bulk, atom, and substrate properties.\n</code></pre> Example <pre><code>materials = Crystal_Materials()\nmaterials.background = {\n    'epsilon': 1.0,\n}\nmaterials.bulk = {\n    'epsilon_diag': mp.Vector3(3.5, 4.0, 4.0),\n    'epsilon_offdiag': mp.Vector3(0.0, 0.0, 0.0),\n    'E_chi2_diag': mp.Vector3(0.0, 0.0, 0.0),\n}\n\nmaterials.atom = {\n    'epsilon' : 1.0,\n}\n\nmaterials.substrate = {\n    'epsilon' : 1\n}\n</code></pre> <p>Valid configuration parameters for materials:</p> <pre><code>epsilon (float): Dielectric constant of the material.\nepsilon_diag (mp.Vector3): Diagonal elements of the dielectric tensor.\nepsilon_offdiag (mp.Vector3): Off-diagonal elements of the dielectric tensor.\nE_chi2_diag (mp.Vector3): Diagonal elements of the second-order nonlinear susceptibility tensor.\nE_chi3_diag (mp.Vector3): Diagonal elements of the third-order nonlinear susceptibility tensor.\n</code></pre> <p>Attributes:</p> Name Type Description <code>VALID_KEYS</code> <code>list</code> <p>List of valid configuration keys for material properties.</p> <code>_background</code> <code>Medium</code> <p>Background material properties.</p> <code>_bulk</code> <code>Medium</code> <p>Bulk material properties.</p> <code>_atom</code> <code>Medium</code> <p>Atom material properties.</p> <code>_substrate</code> <code>Medium</code> <p>Substrate material properties.</p> <code>background</code> <p>Gets/sets the background material properties.</p> <code>bulk</code> <p>Gets/sets the bulk material properties.</p> <code>atom</code> <p>Gets/sets the atom material properties.</p> <code>substrate</code> <p>Gets/sets the substrate material properties.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If invalid configuration keys are provided when setting material properties.</p> Source code in <code>src/crystal_materials.py</code> <pre><code>class Crystal_Materials(): \n        \"\"\"Crystal_Materials class for defining crystal material properties.\n\n        This class manages the material properties of different components in a crystal structure,\n        including background, bulk, atom, and substrate materials. Each material is defined by its\n        dielectric properties and nonlinear susceptibility tensors.\n\n        Usage:\n\n            Use a dictionary to set the material properties for each component. The dictionary should\n            contain the valid configuration keys for material properties. The material properties can\n            be set using the background, bulk, atom, and substrate properties.\n\n        Example:\n            ```python\n            materials = Crystal_Materials()\n            materials.background = {\n                'epsilon': 1.0,\n            }\n            materials.bulk = {\n                'epsilon_diag': mp.Vector3(3.5, 4.0, 4.0),\n                'epsilon_offdiag': mp.Vector3(0.0, 0.0, 0.0),\n                'E_chi2_diag': mp.Vector3(0.0, 0.0, 0.0),\n            }\n\n            materials.atom = {\n                'epsilon' : 1.0,\n            }\n\n            materials.substrate = {\n                'epsilon' : 1\n            }\n            ```\n\n\n\n\n\n        Valid configuration parameters for materials:\n\n            epsilon (float): Dielectric constant of the material.\n            epsilon_diag (mp.Vector3): Diagonal elements of the dielectric tensor.\n            epsilon_offdiag (mp.Vector3): Off-diagonal elements of the dielectric tensor.\n            E_chi2_diag (mp.Vector3): Diagonal elements of the second-order nonlinear susceptibility tensor.\n            E_chi3_diag (mp.Vector3): Diagonal elements of the third-order nonlinear susceptibility tensor.\n\n        Attributes:\n            VALID_KEYS (list): List of valid configuration keys for material properties.\n            _background (mp.Medium): Background material properties.\n            _bulk (mp.Medium): Bulk material properties.\n            _atom (mp.Medium): Atom material properties.\n            _substrate (mp.Medium): Substrate material properties.\n            background: Gets/sets the background material properties.\n            bulk: Gets/sets the bulk material properties.\n            atom: Gets/sets the atom material properties.\n            substrate: Gets/sets the substrate material properties.\n\n\n\n        Raises:\n            ValueError: If invalid configuration keys are provided when setting material properties.\n        \"\"\"\n        VALID_KEYS = ['epsilon', 'epsilon_diag', 'epsilon_offdiag', 'E_chi2_diag', 'E_chi3_diag']\n\n        def __init__(self):\n            \"\"\"\n            Initializes the Crystal_Materials class.\n\n            \"\"\"\n            self._background = None\n            self._bulk = None\n            self._atom = None\n            self._substrate = None\n\n\n\n        @property\n        def background(self):\n            return self._background\n\n        @property\n        def bulk(self):\n            return self._bulk\n\n        @property   \n        def atom(self):\n            return self._atom\n\n        @property\n        def substrate(self):\n            return self._substrate\n\n        @background.setter\n        def background(self, configuration: dict):\n            if not all(key in self.VALID_KEYS for key in configuration.keys()):\n                raise ValueError(\"Invalid configuration keys\")\n            self._background = mp.Medium(**configuration)\n\n        @bulk.setter\n        def bulk(self, configuration: dict): \n            if not all(key in self.VALID_KEYS for key in configuration.keys()):\n                raise ValueError(\"Invalid configuration keys\")\n            self._bulk = mp.Medium(**configuration)\n\n\n        @atom.setter\n        def atom(self, configuration: dict): \n            if not all(key in self.VALID_KEYS for key in configuration.keys()):\n                raise ValueError(\"Invalid configuration keys\")\n            self._atom = mp.Medium(**configuration)\n\n        @substrate.setter  \n        def substrate(self, configuration: dict):\n            if not all(key in self.VALID_KEYS for key in configuration.keys()):\n                raise ValueError(\"Invalid configuration keys\")\n            self._substrate = mp.Medium(**configuration)\n</code></pre>"},{"location":"photonic_crystal/#src.crystal_materials.Crystal_Materials.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Crystal_Materials class.</p> Source code in <code>src/crystal_materials.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the Crystal_Materials class.\n\n    \"\"\"\n    self._background = None\n    self._bulk = None\n    self._atom = None\n    self._substrate = None\n</code></pre>"}]}